; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24225.1 

	TITLE	E:\Repositories\Blitz3D-Modernized\gxruntime\gxruntime.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	_IID_IAMFilterGraphCallback
;	COMDAT _IID_IAMFilterGraphCallback
CONST	SEGMENT
_IID_IAMFilterGraphCallback DD 056a868fdH
	DW	0ad4H
	DW	011ceH
	DB	0b0H
	DB	0a3H
	DB	00H
	DB	020H
	DB	0afH
	DB	0bH
	DB	0a7H
	DB	070H
CONST	ENDS
PUBLIC	?compare@?$char_traits@D@std@@SAHPBD0I@Z	; std::char_traits<char>::compare
PUBLIC	?_Deallocate@std@@YGXPAXII@Z			; std::_Deallocate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
PUBLIC	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
PUBLIC	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
PUBLIC	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
PUBLIC	?flip@gxRuntime@@QAEX_N@Z			; gxRuntime::flip
PUBLIC	?moveMouse@gxRuntime@@QAEXHH@Z			; gxRuntime::moveMouse
PUBLIC	?windowProc@gxRuntime@@QAEJPAUHWND__@@IIJ@Z	; gxRuntime::windowProc
PUBLIC	??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z ; gxRuntime::gxRuntime
PUBLIC	??1gxRuntime@@AAE@XZ				; gxRuntime::~gxRuntime
PUBLIC	?paint@gxRuntime@@AAEXXZ			; gxRuntime::paint
PUBLIC	?suspend@gxRuntime@@AAEXXZ			; gxRuntime::suspend
PUBLIC	?forceSuspend@gxRuntime@@AAEXXZ			; gxRuntime::forceSuspend
PUBLIC	?resume@gxRuntime@@AAEXXZ			; gxRuntime::resume
PUBLIC	?forceResume@gxRuntime@@AAEXXZ			; gxRuntime::forceResume
PUBLIC	?backupWindowState@gxRuntime@@AAEXXZ		; gxRuntime::backupWindowState
PUBLIC	?restoreWindowState@gxRuntime@@AAEXXZ		; gxRuntime::restoreWindowState
PUBLIC	?setDisplayMode@gxRuntime@@AAE_NHHH_NPAUIDirectDraw7@@@Z ; gxRuntime::setDisplayMode
PUBLIC	?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z ; gxRuntime::openWindowedGraphics
PUBLIC	?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z ; gxRuntime::openExclusiveGraphics
PUBLIC	?allocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z ; std::allocator<gxRuntime::GfxDriver *>::allocate
PUBLIC	??1?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::~vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >
PUBLIC	?push_back@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXABQAUGfxDriver@gxRuntime@@@Z ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::push_back
PUBLIC	?_Reallocate@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reserve
PUBLIC	?enumGfx@gxRuntime@@AAEXXZ			; gxRuntime::enumGfx
PUBLIC	?denumGfx@gxRuntime@@AAEXXZ			; gxRuntime::denumGfx
PUBLIC	?resetInput@gxRuntime@@AAEXXZ			; gxRuntime::resetInput
PUBLIC	?pauseAudio@gxRuntime@@AAEXXZ			; gxRuntime::pauseAudio
PUBLIC	?resumeAudio@gxRuntime@@AAEXXZ			; gxRuntime::resumeAudio
PUBLIC	?backupGraphics@gxRuntime@@AAEXXZ		; gxRuntime::backupGraphics
PUBLIC	?restoreGraphics@gxRuntime@@AAEXXZ		; gxRuntime::restoreGraphics
PUBLIC	?acquireInput@gxRuntime@@AAEXXZ			; gxRuntime::acquireInput
PUBLIC	?unacquireInput@gxRuntime@@AAEXXZ		; gxRuntime::unacquireInput
PUBLIC	?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z ; gxRuntime::openRuntime
PUBLIC	?closeRuntime@gxRuntime@@SGXPAV1@@Z		; gxRuntime::closeRuntime
PUBLIC	?asyncStop@gxRuntime@@QAEXXZ			; gxRuntime::asyncStop
PUBLIC	?asyncRun@gxRuntime@@QAEXXZ			; gxRuntime::asyncRun
PUBLIC	?asyncEnd@gxRuntime@@QAEXXZ			; gxRuntime::asyncEnd
PUBLIC	?idle@gxRuntime@@QAE_NXZ			; gxRuntime::idle
PUBLIC	?delay@gxRuntime@@QAE_NH@Z			; gxRuntime::delay
PUBLIC	?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; gxRuntime::execute
PUBLIC	?setTitle@gxRuntime@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; gxRuntime::setTitle
PUBLIC	?getMilliSecs@gxRuntime@@QAEHXZ			; gxRuntime::getMilliSecs
PUBLIC	?setPointerVisible@gxRuntime@@QAEX_N@Z		; gxRuntime::setPointerVisible
PUBLIC	?commandLine@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; gxRuntime::commandLine
PUBLIC	?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z ; gxRuntime::systemProperty
PUBLIC	?debugStop@gxRuntime@@QAEXXZ			; gxRuntime::debugStop
PUBLIC	?debugStmt@gxRuntime@@QAEXHPBD@Z		; gxRuntime::debugStmt
PUBLIC	?debugEnter@gxRuntime@@QAEXPAX0PBD@Z		; gxRuntime::debugEnter
PUBLIC	?debugLeave@gxRuntime@@QAEXXZ			; gxRuntime::debugLeave
PUBLIC	?debugInfo@gxRuntime@@QAEXPBD@Z			; gxRuntime::debugInfo
PUBLIC	?debugError@gxRuntime@@QAEXPBD@Z		; gxRuntime::debugError
PUBLIC	?debugLog@gxRuntime@@QAEXPBD@Z			; gxRuntime::debugLog
PUBLIC	?numGraphicsDrivers@gxRuntime@@QAEHXZ		; gxRuntime::numGraphicsDrivers
PUBLIC	?graphicsDriverInfo@gxRuntime@@QAEXHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ; gxRuntime::graphicsDriverInfo
PUBLIC	?numGraphicsModes@gxRuntime@@QAEHH@Z		; gxRuntime::numGraphicsModes
PUBLIC	?graphicsModeInfo@gxRuntime@@QAEXHHPAH000@Z	; gxRuntime::graphicsModeInfo
PUBLIC	?windowedModeInfo@gxRuntime@@QAEXPAH@Z		; gxRuntime::windowedModeInfo
PUBLIC	?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z	; gxRuntime::openAudio
PUBLIC	?closeAudio@gxRuntime@@QAEXPAVgxAudio@@@Z	; gxRuntime::closeAudio
PUBLIC	?openInput@gxRuntime@@QAEPAVgxInput@@H@Z	; gxRuntime::openInput
PUBLIC	?closeInput@gxRuntime@@QAEXPAVgxInput@@@Z	; gxRuntime::closeInput
PUBLIC	?openGraphics@gxRuntime@@QAEPAVgxGraphics@@HHHHH@Z ; gxRuntime::openGraphics
PUBLIC	?closeGraphics@gxRuntime@@QAEXPAVgxGraphics@@@Z	; gxRuntime::closeGraphics
PUBLIC	?graphicsLost@gxRuntime@@QAE_NXZ		; gxRuntime::graphicsLost
PUBLIC	?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z ; gxRuntime::openFileSystem
PUBLIC	?closeFileSystem@gxRuntime@@QAEXPAVgxFileSystem@@@Z ; gxRuntime::closeFileSystem
PUBLIC	?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z	; gxRuntime::createTimer
PUBLIC	?freeTimer@gxRuntime@@QAEXPAVgxTimer@@@Z	; gxRuntime::freeTimer
PUBLIC	?enableDirectInput@gxRuntime@@QAEX_N@Z		; gxRuntime::enableDirectInput
PUBLIC	?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z ; gxRuntime::callDll
PUBLIC	?allocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z ; std::allocator<gxRuntime::GfxMode *>::allocate
PUBLIC	?push_back@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXABQAUGfxMode@gxRuntime@@@Z ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::push_back
PUBLIC	?_Reallocate@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reallocate
PUBLIC	?_Reserve@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reserve
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode0
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::find
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rrotate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode0
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase
PUBLIC	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::find
PUBLIC	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Destroy_if_not_nil
PUBLIC	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rrotate
PUBLIC	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >
PUBLIC	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode
PUBLIC	?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode0
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
PUBLIC	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
PUBLIC	?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::clear
PUBLIC	?_Erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Erase
PUBLIC	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lrotate
PUBLIC	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rrotate
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator--
PUBLIC	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator++
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator--
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAUgxDll@@@Z ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,gxDll * &>
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>
PUBLIC	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator--
PUBLIC	??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@Z@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAP6GHPBXHPAXH@Z@Z ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,int (__stdcall*&)(void const *,int,void *,int)>
PUBLIC	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>
PUBLIC	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
PUBLIC	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
PUBLIC	??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>
PUBLIC	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
PUBLIC	??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_nohint<gxTimer * const &,std::_Nil>
PUBLIC	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
PUBLIC	??$_Insert_at@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@_NPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@U_Nil@1@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_at<gxTimer * const &,std::_Nil>
PUBLIC	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
PUBLIC	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >
PUBLIC	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
PUBLIC	??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
PUBLIC	??$_Buynode@ABQAVgxTimer@@@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode<gxTimer * const &>
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_0BE@BCECDIAH@Blitz?5Runtime?5Class?$AA@	; `string'
PUBLIC	??_C@_01CLKCMJKC@?5?$AA@			; `string'
PUBLIC	??_C@_09FCFFOIDA@ddraw?4dll?$AA@		; `string'
PUBLIC	??_C@_0BB@HABCIGJF@SetAppCompatData?$AA@	; `string'
PUBLIC	??_C@_0BK@PLKHMFPL@Flip?5Failed?$CB?5Return?5code?3?$AA@ ; `string'
PUBLIC	??_C@_0BK@GCMBHDCF@Create?5DirectInput?5failed?$AA@ ; `string'
PUBLIC	??_C@_03PBJBJNON@cpu?$AA@			; `string'
PUBLIC	??_C@_05CDGBNGHP@Intel?$AA@			; `string'
PUBLIC	??_C@_02EHCHIAMF@os?$AA@			; `string'
PUBLIC	??_C@_0P@HDGFNHEP@Windows?5NT?53?41?$AA@	; `string'
PUBLIC	??_C@_0L@NEBNHFIE@Windows?595?$AA@		; `string'
PUBLIC	??_C@_0L@GBLDALMJ@Windows?598?$AA@		; `string'
PUBLIC	??_C@_0L@KINKMMPO@Windows?5ME?$AA@		; `string'
PUBLIC	??_C@_0N@MEKDBOKB@Windows?52000?$AA@		; `string'
PUBLIC	??_C@_0L@IFICELHB@Windows?5XP?$AA@		; `string'
PUBLIC	??_C@_0BE@IEOLCCDL@Windows?5Server?52003?$AA@	; `string'
PUBLIC	??_C@_0O@IFKHFILP@Windows?5Vista?$AA@		; `string'
PUBLIC	??_C@_09GOHFIPMO@Windows?57?$AA@		; `string'
PUBLIC	??_C@_06FDOJABFB@appdir?$AA@			; `string'
PUBLIC	??_C@_07HNKELBHJ@apphwnd?$AA@			; `string'
PUBLIC	??_C@_0N@GOJEBJGE@apphinstance?$AA@		; `string'
PUBLIC	??_C@_0L@JFHDMCEL@windowsdir?$AA@		; `string'
PUBLIC	??_C@_09LACDBIEN@systemdir?$AA@			; `string'
PUBLIC	??_C@_07MILKKLHK@tempdir?$AA@			; `string'
PUBLIC	??_C@_09LMDHFOKP@direct3d7?$AA@			; `string'
PUBLIC	??_C@_0BA@HCCHIIGI@direct3ddevice7?$AA@		; `string'
PUBLIC	??_C@_0M@HELILEBA@directdraw7?$AA@		; `string'
PUBLIC	??_C@_0N@BNFCOOOE@directinput7?$AA@		; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ ; `string'
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	___std_terminate:PROC
EXTRN	_FSOUND_SetHWND@4:PROC
EXTRN	_FSOUND_Init@12:PROC
EXTRN	__invalid_parameter_noinfo_noreturn:PROC
EXTRN	_memchr:PROC
EXTRN	_memmove:PROC
EXTRN	?_Xbad_alloc@std@@YAXXZ:PROC			; std::_Xbad_alloc
EXTRN	?_Xlength_error@std@@YAXPBD@Z:PROC		; std::_Xlength_error
EXTRN	?_Xout_of_range@std@@YAXPBD@Z:PROC		; std::_Xout_of_range
EXTRN	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z:PROC ; itoa
EXTRN	?tolower@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z:PROC ; tolower
EXTRN	__imp__Sleep@4:PROC
EXTRN	__imp__GetSystemDirectoryA@8:PROC
EXTRN	__imp__GetWindowsDirectoryA@8:PROC
EXTRN	__imp__GetVersionExA@4:PROC
EXTRN	__imp__FreeLibrary@4:PROC
EXTRN	__imp__GetModuleFileNameA@12:PROC
EXTRN	__imp__GetProcAddress@8:PROC
EXTRN	__imp__LoadLibraryA@4:PROC
EXTRN	__imp__GetTempPathA@8:PROC
EXTRN	__imp__GetStockObject@4:PROC
EXTRN	__imp__GetMessageA@16:PROC
EXTRN	__imp__DispatchMessageA@4:PROC
EXTRN	__imp__PeekMessageA@20:PROC
EXTRN	__imp__PostMessageA@16:PROC
EXTRN	__imp__DefWindowProcA@16:PROC
EXTRN	__imp__RegisterClassA@4:PROC
EXTRN	__imp__UnregisterClassA@8:PROC
EXTRN	__imp__CreateWindowExA@48:PROC
EXTRN	__imp__DestroyWindow@4:PROC
EXTRN	__imp__ShowWindow@8:PROC
EXTRN	__imp__MoveWindow@24:PROC
EXTRN	__imp__SetWindowPos@28:PROC
EXTRN	__imp__SetCapture@4:PROC
EXTRN	__imp__ReleaseCapture@0:PROC
EXTRN	__imp__GetSystemMetrics@4:PROC
EXTRN	__imp__UpdateWindow@4:PROC
EXTRN	__imp__SetForegroundWindow@4:PROC
EXTRN	__imp__BeginPaint@8:PROC
EXTRN	__imp__EndPaint@8:PROC
EXTRN	__imp__InvalidateRect@12:PROC
EXTRN	__imp__SetWindowTextA@8:PROC
EXTRN	__imp__GetClientRect@8:PROC
EXTRN	__imp__GetWindowRect@8:PROC
EXTRN	__imp__MessageBoxA@16:PROC
EXTRN	__imp__ShowCursor@4:PROC
EXTRN	__imp__SetCursorPos@8:PROC
EXTRN	__imp__SetCursor@4:PROC
EXTRN	__imp__GetCursorPos@4:PROC
EXTRN	__imp__ClientToScreen@8:PROC
EXTRN	__imp__ScreenToClient@8:PROC
EXTRN	__imp__GetWindowLongA@8:PROC
EXTRN	__imp__SetWindowLongA@12:PROC
EXTRN	__imp__GetDesktopWindow@0:PROC
EXTRN	__imp__LoadCursorA@8:PROC
EXTRN	__imp__timeSetEvent@20:PROC
EXTRN	__imp__timeKillEvent@4:PROC
EXTRN	__imp__timeGetTime@0:PROC
EXTRN	__imp__timeGetDevCaps@8:PROC
EXTRN	__imp__timeBeginPeriod@4:PROC
EXTRN	__imp__timeEndPeriod@4:PROC
EXTRN	__imp__ShellExecuteA@24:PROC
EXTRN	__imp__CoUninitialize@0:PROC
EXTRN	__imp__CoInitialize@4:PROC
EXTRN	_DirectDrawEnumerateExA@12:PROC
EXTRN	_DirectDrawCreateEx@16:PROC
EXTRN	_DirectInputCreateEx@20:PROC
EXTRN	??0gxAudio@@QAE@PAVgxRuntime@@@Z:PROC		; gxAudio::gxAudio
EXTRN	??1gxAudio@@QAE@XZ:PROC				; gxAudio::~gxAudio
EXTRN	?pause@gxAudio@@QAEXXZ:PROC			; gxAudio::pause
EXTRN	?resume@gxAudio@@QAEXXZ:PROC			; gxAudio::resume
EXTRN	??0gxInput@@QAE@PAVgxRuntime@@PAUIDirectInput7A@@@Z:PROC ; gxInput::gxInput
EXTRN	??1gxInput@@QAE@XZ:PROC				; gxInput::~gxInput
EXTRN	?reset@gxInput@@QAEXXZ:PROC			; gxInput::reset
EXTRN	?acquire@gxInput@@QAE_NXZ:PROC			; gxInput::acquire
EXTRN	?unacquire@gxInput@@QAEXXZ:PROC			; gxInput::unacquire
EXTRN	?wm_keydown@gxInput@@QAEXH@Z:PROC		; gxInput::wm_keydown
EXTRN	?wm_keyup@gxInput@@QAEXH@Z:PROC			; gxInput::wm_keyup
EXTRN	?wm_mousedown@gxInput@@QAEXH@Z:PROC		; gxInput::wm_mousedown
EXTRN	?wm_mouseup@gxInput@@QAEXH@Z:PROC		; gxInput::wm_mouseup
EXTRN	?wm_mousemove@gxInput@@QAEXHH@Z:PROC		; gxInput::wm_mousemove
EXTRN	?wm_mousewheel@gxInput@@QAEXH@Z:PROC		; gxInput::wm_mousewheel
EXTRN	?getSurface@gxCanvas@@QBEPAUIDirectDrawSurface7@@XZ:PROC ; gxCanvas::getSurface
EXTRN	?setModify@gxCanvas@@QAEXH@Z:PROC		; gxCanvas::setModify
EXTRN	?getModify@gxCanvas@@QBEHXZ:PROC		; gxCanvas::getModify
EXTRN	??0gxGraphics@@QAE@PAVgxRuntime@@PAUIDirectDraw7@@PAUIDirectDrawSurface7@@2_N@Z:PROC ; gxGraphics::gxGraphics
EXTRN	??1gxGraphics@@QAE@XZ:PROC			; gxGraphics::~gxGraphics
EXTRN	?backup@gxGraphics@@QAEXXZ:PROC			; gxGraphics::backup
EXTRN	?restore@gxGraphics@@QAE_NXZ:PROC		; gxGraphics::restore
EXTRN	?vwait@gxGraphics@@QAEXXZ:PROC			; gxGraphics::vwait
EXTRN	?getWidth@gxGraphics@@QBEHXZ:PROC		; gxGraphics::getWidth
EXTRN	?getHeight@gxGraphics@@QBEHXZ:PROC		; gxGraphics::getHeight
EXTRN	?getFrontCanvas@gxGraphics@@QBEPAVgxCanvas@@XZ:PROC ; gxGraphics::getFrontCanvas
EXTRN	?getBackCanvas@gxGraphics@@QBEPAVgxCanvas@@XZ:PROC ; gxGraphics::getBackCanvas
EXTRN	??0gxFileSystem@@QAE@XZ:PROC			; gxFileSystem::gxFileSystem
EXTRN	??1gxFileSystem@@QAE@XZ:PROC			; gxFileSystem::~gxFileSystem
EXTRN	??0gxTimer@@QAE@PAVgxRuntime@@H@Z:PROC		; gxTimer::gxTimer
EXTRN	??1gxTimer@@QAE@XZ:PROC				; gxTimer::~gxTimer
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memcpy:PROC
EXTRN	_memset:PROC
EXTRN	_IID_IDirectDraw7:BYTE
EXTRN	_IID_IDirectInput7A:BYTE
EXTRN	_IID_IDirect3D7:BYTE
EXTRN	_IID_IDirect3DRGBDevice:BYTE
EXTRN	_IID_IDirect3DHALDevice:BYTE
EXTRN	_IID_IDirect3DTnLHalDevice:BYTE
EXTRN	___security_cookie:DWORD
_BSS	SEGMENT
?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 018H DUP (?) ; app_title
?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 018H DUP (?) ; app_close
?runtime@@3PAVgxRuntime@@A DD 01H DUP (?)		; runtime
?busy@@3_NA DB	01H DUP (?)				; busy
	ALIGN	4

?suspended@@3_NA DB 01H DUP (?)				; suspended
	ALIGN	4

?run_flag@@3_NC DB 01H DUP (?)				; run_flag
	ALIGN	4

?desktop_desc@@3U_DDSURFACEDESC2@@A DB 07cH DUP (?)	; desktop_desc
	ALIGN	8

?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A DQ 01H DUP (?) ; libs
?gfx_mode@@3HA DD 01H DUP (?)				; gfx_mode
?gfx_lost@@3_NA DB 01H DUP (?)				; gfx_lost
	ALIGN	4

?auto_suspend@@3_NA DB 01H DUP (?)			; auto_suspend
	ALIGN	4

?mod_cnt@@3HA DD 01H DUP (?)				; mod_cnt
?timerID@@3IA DD 01H DUP (?)				; timerID
?clipper@@3PAUIDirectDrawClipper@@A DD 01H DUP (?)	; clipper
?primSurf@@3PAUIDirectDrawSurface7@@A DD 01H DUP (?)	; primSurf
?debugger@@3PAVDebugger@@A DD 01H DUP (?)		; debugger
?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A DQ 01H DUP (?) ; timers
?maxDevType@@3HA DD 01H DUP (?)				; maxDevType
_BSS	ENDS
;	COMDAT ?save_esp@?1??callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z@4PAXA
_BSS	SEGMENT
?save_esp@?1??callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z@4PAXA DD 01H DUP (?) ; `gxRuntime::callDll'::`2'::save_esp
_BSS	ENDS
CRT$XCU	SEGMENT
?app_title$initializer$@@3P6AXXZA DD FLAT:??__Eapp_title@@YAXXZ ; app_title$initializer$
CRT$XCU	ENDS
;	COMDAT ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@ DB 'map/set<T> too l'
	DB	'ong', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@BNFCOOOE@directinput7?$AA@
CONST	SEGMENT
??_C@_0N@BNFCOOOE@directinput7?$AA@ DB 'directinput7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HELILEBA@directdraw7?$AA@
CONST	SEGMENT
??_C@_0M@HELILEBA@directdraw7?$AA@ DB 'directdraw7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@HCCHIIGI@direct3ddevice7?$AA@
CONST	SEGMENT
??_C@_0BA@HCCHIIGI@direct3ddevice7?$AA@ DB 'direct3ddevice7', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09LMDHFOKP@direct3d7?$AA@
CONST	SEGMENT
??_C@_09LMDHFOKP@direct3d7?$AA@ DB 'direct3d7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07MILKKLHK@tempdir?$AA@
CONST	SEGMENT
??_C@_07MILKKLHK@tempdir?$AA@ DB 'tempdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LACDBIEN@systemdir?$AA@
CONST	SEGMENT
??_C@_09LACDBIEN@systemdir?$AA@ DB 'systemdir', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@JFHDMCEL@windowsdir?$AA@
CONST	SEGMENT
??_C@_0L@JFHDMCEL@windowsdir?$AA@ DB 'windowsdir', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@GOJEBJGE@apphinstance?$AA@
CONST	SEGMENT
??_C@_0N@GOJEBJGE@apphinstance?$AA@ DB 'apphinstance', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HNKELBHJ@apphwnd?$AA@
CONST	SEGMENT
??_C@_07HNKELBHJ@apphwnd?$AA@ DB 'apphwnd', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06FDOJABFB@appdir?$AA@
CONST	SEGMENT
??_C@_06FDOJABFB@appdir?$AA@ DB 'appdir', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GOHFIPMO@Windows?57?$AA@
CONST	SEGMENT
??_C@_09GOHFIPMO@Windows?57?$AA@ DB 'Windows 7', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@IFKHFILP@Windows?5Vista?$AA@
CONST	SEGMENT
??_C@_0O@IFKHFILP@Windows?5Vista?$AA@ DB 'Windows Vista', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@IEOLCCDL@Windows?5Server?52003?$AA@
CONST	SEGMENT
??_C@_0BE@IEOLCCDL@Windows?5Server?52003?$AA@ DB 'Windows Server 2003', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@IFICELHB@Windows?5XP?$AA@
CONST	SEGMENT
??_C@_0L@IFICELHB@Windows?5XP?$AA@ DB 'Windows XP', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@MEKDBOKB@Windows?52000?$AA@
CONST	SEGMENT
??_C@_0N@MEKDBOKB@Windows?52000?$AA@ DB 'Windows 2000', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KINKMMPO@Windows?5ME?$AA@
CONST	SEGMENT
??_C@_0L@KINKMMPO@Windows?5ME?$AA@ DB 'Windows ME', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@GBLDALMJ@Windows?598?$AA@
CONST	SEGMENT
??_C@_0L@GBLDALMJ@Windows?598?$AA@ DB 'Windows 98', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@NEBNHFIE@Windows?595?$AA@
CONST	SEGMENT
??_C@_0L@NEBNHFIE@Windows?595?$AA@ DB 'Windows 95', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@HDGFNHEP@Windows?5NT?53?41?$AA@
CONST	SEGMENT
??_C@_0P@HDGFNHEP@Windows?5NT?53?41?$AA@ DB 'Windows NT 3.1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02EHCHIAMF@os?$AA@
CONST	SEGMENT
??_C@_02EHCHIAMF@os?$AA@ DB 'os', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05CDGBNGHP@Intel?$AA@
CONST	SEGMENT
??_C@_05CDGBNGHP@Intel?$AA@ DB 'Intel', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03PBJBJNON@cpu?$AA@
CONST	SEGMENT
??_C@_03PBJBJNON@cpu?$AA@ DB 'cpu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@GCMBHDCF@Create?5DirectInput?5failed?$AA@
CONST	SEGMENT
??_C@_0BK@GCMBHDCF@Create?5DirectInput?5failed?$AA@ DB 'Create DirectInpu'
	DB	't failed', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLKHMFPL@Flip?5Failed?$CB?5Return?5code?3?$AA@
CONST	SEGMENT
??_C@_0BK@PLKHMFPL@Flip?5Failed?$CB?5Return?5code?3?$AA@ DB 'Flip Failed!'
	DB	' Return code:', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@HABCIGJF@SetAppCompatData?$AA@
CONST	SEGMENT
??_C@_0BB@HABCIGJF@SetAppCompatData?$AA@ DB 'SetAppCompatData', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09FCFFOIDA@ddraw?4dll?$AA@
CONST	SEGMENT
??_C@_09FCFFOIDA@ddraw?4dll?$AA@ DB 'ddraw.dll', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_01CLKCMJKC@?5?$AA@
CONST	SEGMENT
??_C@_01CLKCMJKC@?5?$AA@ DB ' ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@BCECDIAH@Blitz?5Runtime?5Class?$AA@
CONST	SEGMENT
??_C@_0BE@BCECDIAH@Blitz?5Runtime?5Class?$AA@ DB 'Blitz Runtime Class', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z$66 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z$66
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z$66 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z$0
__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z$66
__ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z$42 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z$0
__unwindtable$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z$42
__ehfuncinfo$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z$0
__ehfuncinfo$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??__Flibs@@YAXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??__Flibs@@YAXXZ$1
__ehfuncinfo$??__Flibs@@YAXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??__Flibs@@YAXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z$16
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ$0
__ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z$16
__ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z$2
__ehfuncinfo$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z$0
__ehfuncinfo$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z$0
__ehfuncinfo$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z$0
__ehfuncinfo$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z$0
__ehfuncinfo$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z$2
__ehfuncinfo$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	05H
	DD	FLAT:__unwindtable$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$77
	DD	01H
	DD	FLAT:__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$243
	DD	01H
	DD	FLAT:__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$417
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?closeRuntime@gxRuntime@@SGXPAV1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?closeRuntime@gxRuntime@@SGXPAV1@@Z$17
__ehfuncinfo$?closeRuntime@gxRuntime@@SGXPAV1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?closeRuntime@gxRuntime@@SGXPAV1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z$0
__ehfuncinfo$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z$0
__ehfuncinfo$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z$0
__ehfuncinfo$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1gxRuntime@@AAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$3
__ehfuncinfo$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?flip@gxRuntime@@QAEX_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?flip@gxRuntime@@QAEX_N@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?flip@gxRuntime@@QAEX_N@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?flip@gxRuntime@@QAEX_N@Z$1
__ehfuncinfo$?flip@gxRuntime@@QAEX_N@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?flip@gxRuntime@@QAEX_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0
__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1
__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	01H
	DD	00H
	DD	01H
	DD	00H
__ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	02H
	DD	FLAT:__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$110
	DD	00H
	DD	00H
	DD	03H
	DD	01H
	DD	FLAT:__catchsym$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$111
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?app_close$initializer$@@3P6AXXZA DD FLAT:??__Eapp_close@@YAXXZ ; app_close$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?libs$initializer$@@3P6AXXZA DD FLAT:??__Elibs@@YAXXZ	; libs$initializer$
CRT$XCU	ENDS
CRT$XCU	SEGMENT
?timers$initializer$@@3P6AXXZA DD FLAT:??__Etimers@@YAXXZ ; timers$initializer$
CRT$XCU	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVgxTimer@@ABQAV1@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAVgxTimer@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVgxTimer@@ABQAV1@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAVgxTimer@@ABQAV2@@Z PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::construct<gxTimer *,gxTimer * const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAVgxTimer@@ABQAV1@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAVgxTimer@@ABQAV2@@Z ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::construct<gxTimer *,gxTimer * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@P6GHPBXHPAXH@Z@std@@YG$$QAP6GHPBXHPAXH@ZAAP6GH0H1H@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@P6GHPBXHPAXH@Z@std@@YG$$QAP6GHPBXHPAXH@ZAAP6GH0H1H@Z@Z PROC ; std::forward<int (__stdcall*)(void const *,int,void *,int)>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@P6GHPBXHPAXH@Z@std@@YG$$QAP6GHPBXHPAXH@ZAAP6GH0H1H@Z@Z ENDP ; std::forward<int (__stdcall*)(void const *,int,void *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@PAUgxDll@@@std@@YG$$QAPAUgxDll@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@PAUgxDll@@@std@@YG$$QAPAUgxDll@@AAPAU1@@Z PROC ; std::forward<gxDll *>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@PAUgxDll@@@std@@YG$$QAPAUgxDll@@AAPAU1@@Z ENDP ; std::forward<gxDll *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVgxTimer@@ABQAV1@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAVgxTimer@@ABQAV3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAVgxTimer@@ABQAV1@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAVgxTimer@@ABQAV3@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<gxTimer *,gxTimer * const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAVgxTimer@@ABQAV1@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAVgxTimer@@ABQAV3@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<gxTimer *,gxTimer * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	edi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	test	edi, edi
	je	SHORT $LN3@construct
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	pop	esi
$LN3@construct:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	pop	ebp
	ret	8
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	edi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	test	edi, edi
	je	SHORT $LN3@construct
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	pop	esi
$LN3@construct:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 738  : 		}

	pop	ebp
	ret	8
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAVgxTimer@@ABQAV1@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAVgxTimer@@ABQAV2@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAVgxTimer@@ABQAV1@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAVgxTimer@@ABQAV2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<gxTimer *,gxTimer * const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAVgxTimer@@ABQAV1@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAVgxTimer@@ABQAV2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<gxTimer *,gxTimer * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUGfxDriver@gxRuntime@@PAPAU12@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUGfxDriver@gxRuntime@@PAPAU12@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00@Z PROC ; std::_Copy_memmove<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	pop	ebp
	ret	12					; 0000000cH
??$_Copy_memmove@PAPAUGfxDriver@gxRuntime@@PAPAU12@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAPAUGfxMode@gxRuntime@@PAPAU12@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAPAUGfxMode@gxRuntime@@PAPAU12@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00@Z PROC ; std::_Copy_memmove<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);
; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);
; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);
; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi
	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax
	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi

; 2308 : 	}

	pop	ebp
	ret	12					; 0000000cH
??$_Copy_memmove@PAPAUGfxMode@gxRuntime@@PAPAU12@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00@Z ENDP ; std::_Copy_memmove<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode_if_nil<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &>, COMDAT
; _this$ = ecx

; 1629 : 		{	// node exists, just return it

	push	ebp
	mov	ebp, esp

; 1630 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[ebp]

; 1631 : 		}

	pop	ebp
	ret	8
??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode_if_nil<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	edi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	test	edi, edi
	je	SHORT $LN8@construct
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	pop	esi
$LN8@construct:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Node$ = 8						; size = 4
___formal$ = 12						; size = 4
??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode_if_nil<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &>, COMDAT
; _this$ = ecx

; 1629 : 		{	// node exists, just return it

	push	ebp
	mov	ebp, esp

; 1630 : 		return (_Node);

	mov	eax, DWORD PTR __Node$[ebp]

; 1631 : 		}

	pop	ebp
	ret	8
??$_Buynode_if_nil@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PAU21@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode_if_nil<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	edi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	test	edi, edi
	je	SHORT $LN8@construct
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	pop	esi
$LN8@construct:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@ABQAVgxTimer@@@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@ABQAVgxTimer@@@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode<gxTimer * const &>, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

	push	ebp
	mov	ebp, esp

; 881  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode0

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	edx, DWORD PTR [eax+16]

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [eax+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edx, edx
	je	SHORT $LN47@Buynode
	mov	ecx, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [edx], ecx
$LN47@Buynode:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 896  : 		}

	pop	ebp
	ret	4
??$_Buynode@ABQAVgxTimer@@@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode<gxTimer * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAUGfxDriver@gxRuntime@@PAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAUGfxDriver@gxRuntime@@PAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<gxRuntime::GfxDriver *,gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >, COMDAT

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 294  : 	}

	pop	ebp
	ret	24					; 00000018H
??$_Uninitialized_move_al_unchecked1@PAUGfxDriver@gxRuntime@@PAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<gxRuntime::GfxDriver *,gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@PAUGfxDriver@gxRuntime@@PAU12@@std@@YG?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUGfxDriver@gxRuntime@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@PAUGfxDriver@gxRuntime@@PAU12@@std@@YG?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUGfxDriver@gxRuntime@@0@Z PROC ; std::_Ptr_move_cat<gxRuntime::GfxDriver *,gxRuntime::GfxDriver *>, COMDAT

; 809  : 	{	// return pointer move optimization category for pointers

	push	ebp
	mov	ebp, esp

; 810  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 811  : 	}

	pop	ebp
	ret	12					; 0000000cH
??$_Ptr_move_cat@PAUGfxDriver@gxRuntime@@PAU12@@std@@YG?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUGfxDriver@gxRuntime@@0@Z ENDP ; std::_Ptr_move_cat<gxRuntime::GfxDriver *,gxRuntime::GfxDriver *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAUGfxMode@gxRuntime@@PAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAUGfxMode@gxRuntime@@PAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<gxRuntime::GfxMode *,gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >, COMDAT

; 292  : 	{	// move [_First, _Last) to raw _Dest, using default _Alloc construct, memmove optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 294  : 	}

	pop	ebp
	ret	24					; 00000018H
??$_Uninitialized_move_al_unchecked1@PAUGfxMode@gxRuntime@@PAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@U_Really_trivial_ptr_iterator_tag@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<gxRuntime::GfxMode *,gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@PAUGfxMode@gxRuntime@@PAU12@@std@@YG?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUGfxMode@gxRuntime@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@PAUGfxMode@gxRuntime@@PAU12@@std@@YG?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUGfxMode@gxRuntime@@0@Z PROC ; std::_Ptr_move_cat<gxRuntime::GfxMode *,gxRuntime::GfxMode *>, COMDAT

; 809  : 	{	// return pointer move optimization category for pointers

	push	ebp
	mov	ebp, esp

; 810  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 811  : 	}

	pop	ebp
	ret	12					; 0000000cH
??$_Ptr_move_cat@PAUGfxMode@gxRuntime@@PAU12@@std@@YG?AU_Really_trivial_ptr_iterator_tag@0@ABQAPAUGfxMode@gxRuntime@@0@Z ENDP ; std::_Ptr_move_cat<gxRuntime::GfxMode *,gxRuntime::GfxMode *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 97612892				; 05d1745cH
	jb	SHORT $LN5@Insert_at

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	edi, DWORD PTR __Node$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN91@Insert_at
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN91@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	$LN183@Insert_at
	jmp	$LN833@Insert_at
$LN5@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1837 : 		_Newnode->_Parent = _Wherenode;

	mov	ebx, DWORD PTR __Node$[ebp]
	inc	eax
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ebx+4], eax

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1842 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[ebp], 0
	je	SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	ecx, DWORD PTR [edi]

; 1848 : 			if (_Wherenode == _Lmost())

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1850 : 			}
; 1851 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	ecx, DWORD PTR [edi]

; 1854 : 			if (_Wherenode == _Rmost())

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1855 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
$LL2@Insert_at:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN832@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1878 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN479@Insert_at

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN479@Insert_at:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2119 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN480@Insert_at

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN831@Insert_at
$LN480@Insert_at:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN482@Insert_at

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN831@Insert_at
$LN482@Insert_at:

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	SHORT $LN831@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN832@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1904 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN678@Insert_at

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN678@Insert_at:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2089 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN679@Insert_at

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN682@Insert_at
$LN679@Insert_at:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN681@Insert_at

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2093 : 		else

	jmp	SHORT $LN682@Insert_at
$LN681@Insert_at:

; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN682@Insert_at:

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN831@Insert_at:

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1916 : 		}

	pop	ebp
	ret	20					; 00000014H
$LN833@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN183@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1831 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN835@Insert_at:
$LN830@Insert_at:
	int	3
??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z PROC ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z ENDP ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	edi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	test	edi, edi
	je	SHORT $LN13@construct
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	pop	esi
$LN13@construct:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	pop	ebp
	ret	8
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool>::pair<std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool><std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@1@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 4
??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@1@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

	mov	eax, DWORD PTR [edi+4]
	cmp	eax, 97612892				; 05d1745cH
	jb	SHORT $LN5@Insert_at

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	edi, DWORD PTR __Node$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN91@Insert_at
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN91@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	$LN183@Insert_at
	jmp	$LN833@Insert_at
$LN5@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1837 : 		_Newnode->_Parent = _Wherenode;

	mov	ebx, DWORD PTR __Node$[ebp]
	inc	eax
	mov	DWORD PTR [edi+4], eax
	mov	eax, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ebx+4], eax

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

	mov	ecx, DWORD PTR [edi]
	cmp	eax, ecx
	jne	SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

	mov	DWORD PTR [ecx+4], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1842 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+8], ebx
	jmp	SHORT $LN11@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[ebp], 0
	je	SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	ecx, DWORD PTR [edi]

; 1848 : 			if (_Wherenode == _Lmost())

	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 1850 : 			}
; 1851 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [eax+8], ebx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	ecx, DWORD PTR [edi]

; 1854 : 			if (_Wherenode == _Rmost())

	cmp	eax, DWORD PTR [ecx+8]
	jne	SHORT $LN11@Insert_at

; 1855 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [ecx+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
$LL2@Insert_at:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN832@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1878 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN479@Insert_at

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN479@Insert_at:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2119 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN480@Insert_at

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN831@Insert_at
$LN480@Insert_at:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN482@Insert_at

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN831@Insert_at
$LN482@Insert_at:

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	SHORT $LN831@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN832@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1904 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN678@Insert_at

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN678@Insert_at:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2089 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN679@Insert_at

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN682@Insert_at
$LN679@Insert_at:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN681@Insert_at

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2093 : 		else

	jmp	SHORT $LN682@Insert_at
$LN681@Insert_at:

; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN682@Insert_at:

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN831@Insert_at:

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1916 : 		}

	pop	ebp
	ret	20					; 00000014H
$LN833@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN183@Insert_at:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1831 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN835@Insert_at:
$LN830@Insert_at:
	int	3
??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@1@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z PROC ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z ENDP ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	push	edi

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	edi, DWORD PTR __Ptr$[ebp]
	test	edi, edi
	je	SHORT $LN13@construct
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Args_0>$[ebp]
	mov	ecx, edi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax
	pop	esi
$LN13@construct:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 997  : 		}

	pop	ebp
	ret	8
??$construct@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@_N@std@@YG$$QA_NAA_N@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@_N@std@@YG$$QA_NAA_N@Z PROC			; std::forward<bool>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@_N@std@@YG$$QA_NAA_N@Z ENDP			; std::forward<bool>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YG$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode_if_nil@ABQAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@U_Nil@1@ABQAVgxTimer@@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val$ = 12						; size = 4
??$_Buynode_if_nil@ABQAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@U_Nil@1@ABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode_if_nil<gxTimer * const &>, COMDAT
; _this$ = ecx

; 1635 : 		{	// node doesn't exist, make it

	push	ebp
	mov	ebp, esp

; 1636 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));

	push	DWORD PTR __Val$[ebp]
	call	??$_Buynode@ABQAVgxTimer@@@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode<gxTimer * const &>

; 1637 : 		}

	pop	ebp
	ret	8
??$_Buynode_if_nil@ABQAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@U_Nil@1@ABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode_if_nil<gxTimer * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU21@@Z PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::construct<std::_Tree_node<gxTimer *,void *> *,std::_Tree_node<gxTimer *,void *> * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU21@@Z ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::construct<std::_Tree_node<gxTimer *,void *> *,std::_Tree_node<gxTimer *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN108@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
$LN108@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAUGfxDriver@gxRuntime@@PAPAU12@@std@@YGAAPAPAUGfxDriver@gxRuntime@@AAPAPAU12@PAPAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAUGfxDriver@gxRuntime@@PAPAU12@@std@@YGAAPAPAUGfxDriver@gxRuntime@@AAPAPAU12@PAPAU12@@Z PROC ; std::_Rechecked<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 458  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

	pop	ebp
	ret	8
??$_Rechecked@PAPAUGfxDriver@gxRuntime@@PAPAU12@@std@@YGAAPAPAUGfxDriver@gxRuntime@@AAPAPAU12@PAPAU12@@Z ENDP ; std::_Rechecked<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAPAUGfxDriver@gxRuntime@@PAPAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAPAUGfxDriver@gxRuntime@@PAPAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *,std::allocator<gxRuntime::GfxDriver *> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 306  : 	}

	pop	ebp
	ret	16					; 00000010H
??$_Uninitialized_move_al_unchecked@PAPAUGfxDriver@gxRuntime@@PAPAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *,std::allocator<gxRuntime::GfxDriver *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAUGfxDriver@gxRuntime@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAUGfxDriver@gxRuntime@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@@Z PROC ; std::_Unchecked<gxRuntime::GfxDriver * *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	ebp
	ret	4
??$_Unchecked@PAPAUGfxDriver@gxRuntime@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@@Z ENDP ; std::_Unchecked<gxRuntime::GfxDriver * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAPAUGfxMode@gxRuntime@@PAPAU12@@std@@YGAAPAPAUGfxMode@gxRuntime@@AAPAPAU12@PAPAU12@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAPAUGfxMode@gxRuntime@@PAPAU12@@std@@YGAAPAPAUGfxMode@gxRuntime@@AAPAPAU12@PAPAU12@@Z PROC ; std::_Rechecked<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp

; 458  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 459  : 	return (_Dest);
; 460  : 	}

	pop	ebp
	ret	8
??$_Rechecked@PAPAUGfxMode@gxRuntime@@PAPAU12@@std@@YGAAPAPAUGfxMode@gxRuntime@@AAPAPAU12@PAPAU12@@Z ENDP ; std::_Rechecked<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAPAUGfxMode@gxRuntime@@PAPAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAPAUGfxMode@gxRuntime@@PAPAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *,std::allocator<gxRuntime::GfxMode *> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 306  : 	}

	pop	ebp
	ret	16					; 00000010H
??$_Uninitialized_move_al_unchecked@PAPAUGfxMode@gxRuntime@@PAPAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *,std::allocator<gxRuntime::GfxMode *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAPAUGfxMode@gxRuntime@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAPAUGfxMode@gxRuntime@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@@Z PROC ; std::_Unchecked<gxRuntime::GfxMode * *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	ebp
	ret	4
??$_Unchecked@PAPAUGfxMode@gxRuntime@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@@Z ENDP ; std::_Unchecked<gxRuntime::GfxMode * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVgxTimer@@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAVgxTimer@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVgxTimer@@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAVgxTimer@@@Z PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::destroy<gxTimer *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAVgxTimer@@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAVgxTimer@@@Z ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::destroy<gxTimer *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::destroy<std::_Tree_node<gxTimer *,void *> *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::destroy<std::_Tree_node<gxTimer *,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0ABV?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z PROC ; std::allocator<char>::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$allocator@D@std@@QAEXPAPADAAPAD@Z ENDP ; std::allocator<char>::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z PROC	; std::allocator<char>::destroy<char *>, COMDAT
; _this$ = ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	ret	4
??$destroy@PAD@?$allocator@D@std@@QAEXPAPAD@Z ENDP	; std::allocator<char>::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN16@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN108@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
$LN108@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 745  : 		}

	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@AAV10@@Z PROC ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGAAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@AAV10@@Z ENDP ; std::forward<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@ABQAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@ABQAU23@@Z PROC ; std::allocator<gxRuntime::GfxDriver *>::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@ABQAU23@@Z ENDP ; std::allocator<gxRuntime::GfxDriver *>::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@AAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@AAPAU23@@Z PROC ; std::allocator<gxRuntime::GfxDriver *>::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@AAPAU23@@Z ENDP ; std::allocator<gxRuntime::GfxDriver *>::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@ABQAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@ABQAU23@@Z PROC ; std::allocator<gxRuntime::GfxMode *>::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@ABQAU23@@Z ENDP ; std::allocator<gxRuntime::GfxMode *>::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@AAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@AAPAU23@@Z PROC ; std::allocator<gxRuntime::GfxMode *>::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN3@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN3@construct:

; 738  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@AAPAU23@@Z ENDP ; std::allocator<gxRuntime::GfxMode *>::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
tv875 = -36						; size = 4
_this$ = -32						; size = 4
__Addleft$2 = -28					; size = 1
__Wherenode$1$ = -24					; size = 4
__Left_size$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, ecx
	mov	DWORD PTR _this$[ebp], edx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [edx]

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	al, 1
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv875[ebp], edi

; 1772 : 		_TRY_BEGIN
; 1773 : 		_Nodeptr _Trynode = _Root();
; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	DWORD PTR __Wherenode$1$[ebp], ecx
	mov	ebx, DWORD PTR [edi+4]

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], al

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [ebx+13], 0
	jne	$LN3@Insert_noh
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	esi, DWORD PTR [edx+20]
	mov	DWORD PTR __Left_size$1$[ebp], eax
	npad	1
$LL2@Insert_noh:

; 1780 : 			if (_Leftish)

	cmp	BYTE PTR __Leftish$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	ecx, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1779 : 			_Wherenode = _Trynode;

	mov	DWORD PTR __Wherenode$1$[ebp], ebx

; 1780 : 			if (_Leftish)

	je	$LN5@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	esi, 16					; 00000010H
	jb	SHORT $LN103@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN104@Insert_noh
$LN103@Insert_noh:
	mov	esi, edx
$LN104@Insert_noh:
	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN127@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN127@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [eax]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, DWORD PTR __Left_size$1$[ebp]
	cmp	edi, eax
	mov	edx, eax
	cmovb	edx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 517  : 		return (_Count == 0 ? 0

	test	edx, edx
	je	SHORT $LN131@Insert_noh
	sub	edx, 4
	jb	SHORT $LN364@Insert_noh
	npad	5
$LL365@Insert_noh:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN363@Insert_noh
	add	ecx, 4
	add	esi, 4
	sub	edx, 4
	jae	SHORT $LL365@Insert_noh
$LN364@Insert_noh:
	cmp	edx, -4					; fffffffcH
	je	SHORT $LN362@Insert_noh
$LN363@Insert_noh:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [esi]
	jne	SHORT $LN366@Insert_noh
	cmp	edx, -3					; fffffffdH
	je	SHORT $LN362@Insert_noh
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [esi+1]
	jne	SHORT $LN366@Insert_noh
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN362@Insert_noh
	mov	al, BYTE PTR [ecx+2]
	cmp	al, BYTE PTR [esi+2]
	jne	SHORT $LN366@Insert_noh
	cmp	edx, -1
	je	SHORT $LN362@Insert_noh
	mov	al, BYTE PTR [ecx+3]
	cmp	al, BYTE PTR [esi+3]
	je	SHORT $LN362@Insert_noh
$LN366@Insert_noh:
	sbb	eax, eax
	or	eax, 1
	jmp	SHORT $LN367@Insert_noh
$LN362@Insert_noh:
	xor	eax, eax
$LN367@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN133@Insert_noh
	mov	eax, DWORD PTR __Left_size$1$[ebp]
$LN131@Insert_noh:

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	eax, edi
	jbe	SHORT $LN379@Insert_noh

; 2102 : 			return (-1);

	or	eax, -1

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1781 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	xor	al, 1

; 1782 : 					this->_Key(_Trynode),
; 1783 : 					this->_Kfn(_Val));	// favor left end
; 1784 : 			else

	jmp	$LN380@Insert_noh
$LN379@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN133@Insert_noh:

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1781 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	xor	al, 1

; 1782 : 					this->_Key(_Trynode),
; 1783 : 					this->_Kfn(_Val));	// favor left end
; 1784 : 			else

	jmp	$LN380@Insert_noh
$LN5@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN187@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN187@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	esi, 16					; 00000010H
	jb	SHORT $LN209@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN210@Insert_noh
$LN209@Insert_noh:
	mov	esi, edx
$LN210@Insert_noh:

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [eax]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	edx, edi
	mov	eax, DWORD PTR __Left_size$1$[ebp]
	cmp	eax, edi
	cmovb	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 517  : 		return (_Count == 0 ? 0

	test	edx, edx
	je	SHORT $LN214@Insert_noh
	sub	edx, 4
	jb	SHORT $LN370@Insert_noh
	npad	3
$LL371@Insert_noh:
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN369@Insert_noh
	add	esi, 4
	add	ecx, 4
	sub	edx, 4
	jae	SHORT $LL371@Insert_noh
$LN370@Insert_noh:
	cmp	edx, -4					; fffffffcH
	je	SHORT $LN368@Insert_noh
$LN369@Insert_noh:
	mov	al, BYTE PTR [esi]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN372@Insert_noh
	cmp	edx, -3					; fffffffdH
	je	SHORT $LN368@Insert_noh
	mov	al, BYTE PTR [esi+1]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN372@Insert_noh
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN368@Insert_noh
	mov	al, BYTE PTR [esi+2]
	cmp	al, BYTE PTR [ecx+2]
	jne	SHORT $LN372@Insert_noh
	cmp	edx, -1
	je	SHORT $LN368@Insert_noh
	mov	al, BYTE PTR [esi+3]
	cmp	al, BYTE PTR [ecx+3]
	je	SHORT $LN368@Insert_noh
$LN372@Insert_noh:
	sbb	eax, eax
	or	eax, 1
	jmp	SHORT $LN373@Insert_noh
$LN368@Insert_noh:
	xor	eax, eax
$LN373@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN216@Insert_noh
	mov	eax, DWORD PTR __Left_size$1$[ebp]
$LN214@Insert_noh:

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	edi, eax
	jbe	SHORT $LN381@Insert_noh

; 2102 : 			return (-1);

	or	eax, -1
	jmp	SHORT $LN216@Insert_noh
$LN381@Insert_noh:

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN216@Insert_noh:

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
$LN380@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1785 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

	mov	BYTE PTR __Addleft$2[ebp], al

; 1786 : 					this->_Kfn(_Val),
; 1787 : 					this->_Key(_Trynode));	// favor right end
; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	test	al, al
	je	SHORT $LN16@Insert_noh
	mov	ebx, DWORD PTR [ebx]
	jmp	SHORT $LN17@Insert_noh
$LN16@Insert_noh:
	mov	ebx, DWORD PTR [ebx+8]
$LN17@Insert_noh:

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [ebx+13], 0
	mov	edx, DWORD PTR __Val$[ebp]
	mov	esi, DWORD PTR [edx+20]
	je	$LL2@Insert_noh
	mov	ecx, DWORD PTR __Wherenode$1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR tv875[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	esi, ecx
	mov	DWORD PTR __Where$4[ebp], esi

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1798 : 			if (!_Addleft)

	test	al, al
	je	SHORT $LN12@Insert_noh

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, DWORD PTR [edi]

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	mov	edi, DWORD PTR __Val$[ebp]
	push	edi
	push	ecx
	push	1
	mov	ecx, edx
$LN383@Insert_noh:
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator--
	mov	esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:

; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	mov	ebx, DWORD PTR _this$[ebp]
	mov	ecx, ebx
	push	edi
	push	eax
	call	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()

; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	mov	ecx, ebx
	push	DWORD PTR __Newnode$[ebp]
	test	al, al
	je	SHORT $LN13@Insert_noh
	push	edi
	push	DWORD PTR __Wherenode$1$[ebp]
	push	DWORD PTR __Addleft$2[ebp]
	jmp	SHORT $LN383@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z$0:

; 1814 : 				return (_Pairib(_Where, false));
; 1815 : 				}
; 1816 : 			}
; 1817 : 		_CATCH_ALL
; 1818 : 		_Destroy_if_not_nil(_Newnode);

	push	DWORD PTR __Newnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Destroy_if_not_nil

; 1819 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN384@Insert_noh:
$LN13@Insert_noh:

; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				{	// duplicate, don't insert
; 1813 : 				_Destroy_if_not_nil(_Newnode);

	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Destroy_if_not_nil
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN378@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi

; 881  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode0
	mov	edi, eax

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	ebx, DWORD PTR [edi+16]

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [edi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ebx, ebx
	je	SHORT $LN47@Buynode
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, ebx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ebx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ebx+24], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 895  : 		return (_Pnode);

	mov	eax, edi
	pop	esi
$LN47@Buynode:
	pop	edi
	pop	ebx

; 896  : 		}

	pop	ebp
	ret	4
??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
_TEXT	SEGMENT
tv875 = -36						; size = 4
_this$ = -32						; size = 4
__Addleft$2 = -28					; size = 1
__Wherenode$1$ = -24					; size = 4
__Left_size$1$ = -20					; size = 4
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 4
??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	edx, ecx
	mov	DWORD PTR _this$[ebp], edx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [edx]

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	al, 1
	mov	ecx, edi
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv875[ebp], edi

; 1772 : 		_TRY_BEGIN
; 1773 : 		_Nodeptr _Trynode = _Root();
; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();

	mov	DWORD PTR __Wherenode$1$[ebp], ecx
	mov	ebx, DWORD PTR [edi+4]

; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], al

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [ebx+13], 0
	jne	$LN3@Insert_noh
	mov	edx, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [edx+16]
	mov	esi, DWORD PTR [edx+20]
	mov	DWORD PTR __Left_size$1$[ebp], eax
	npad	1
$LL2@Insert_noh:

; 1780 : 			if (_Leftish)

	cmp	BYTE PTR __Leftish$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	ecx, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1779 : 			_Wherenode = _Trynode;

	mov	DWORD PTR __Wherenode$1$[ebp], ebx

; 1780 : 			if (_Leftish)

	je	$LN5@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	esi, 16					; 00000010H
	jb	SHORT $LN103@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN104@Insert_noh
$LN103@Insert_noh:
	mov	esi, edx
$LN104@Insert_noh:
	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN127@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN127@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [eax]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, DWORD PTR __Left_size$1$[ebp]
	cmp	edi, eax
	mov	edx, eax
	cmovb	edx, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 517  : 		return (_Count == 0 ? 0

	test	edx, edx
	je	SHORT $LN131@Insert_noh
	sub	edx, 4
	jb	SHORT $LN364@Insert_noh
	npad	5
$LL365@Insert_noh:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN363@Insert_noh
	add	ecx, 4
	add	esi, 4
	sub	edx, 4
	jae	SHORT $LL365@Insert_noh
$LN364@Insert_noh:
	cmp	edx, -4					; fffffffcH
	je	SHORT $LN362@Insert_noh
$LN363@Insert_noh:
	mov	al, BYTE PTR [ecx]
	cmp	al, BYTE PTR [esi]
	jne	SHORT $LN366@Insert_noh
	cmp	edx, -3					; fffffffdH
	je	SHORT $LN362@Insert_noh
	mov	al, BYTE PTR [ecx+1]
	cmp	al, BYTE PTR [esi+1]
	jne	SHORT $LN366@Insert_noh
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN362@Insert_noh
	mov	al, BYTE PTR [ecx+2]
	cmp	al, BYTE PTR [esi+2]
	jne	SHORT $LN366@Insert_noh
	cmp	edx, -1
	je	SHORT $LN362@Insert_noh
	mov	al, BYTE PTR [ecx+3]
	cmp	al, BYTE PTR [esi+3]
	je	SHORT $LN362@Insert_noh
$LN366@Insert_noh:
	sbb	eax, eax
	or	eax, 1
	jmp	SHORT $LN367@Insert_noh
$LN362@Insert_noh:
	xor	eax, eax
$LN367@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN133@Insert_noh
	mov	eax, DWORD PTR __Left_size$1$[ebp]
$LN131@Insert_noh:

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	eax, edi
	jbe	SHORT $LN379@Insert_noh

; 2102 : 			return (-1);

	or	eax, -1

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1781 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	xor	al, 1

; 1782 : 					this->_Key(_Trynode),
; 1783 : 					this->_Kfn(_Val));	// favor left end
; 1784 : 			else

	jmp	$LN380@Insert_noh
$LN379@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN133@Insert_noh:

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1781 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	xor	al, 1

; 1782 : 					this->_Key(_Trynode),
; 1783 : 					this->_Kfn(_Val));	// favor left end
; 1784 : 			else

	jmp	$LN380@Insert_noh
$LN5@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN187@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN187@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	esi, 16					; 00000010H
	jb	SHORT $LN209@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN210@Insert_noh
$LN209@Insert_noh:
	mov	esi, edx
$LN210@Insert_noh:

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [eax]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	edx, edi
	mov	eax, DWORD PTR __Left_size$1$[ebp]
	cmp	eax, edi
	cmovb	edx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 517  : 		return (_Count == 0 ? 0

	test	edx, edx
	je	SHORT $LN214@Insert_noh
	sub	edx, 4
	jb	SHORT $LN370@Insert_noh
	npad	3
$LL371@Insert_noh:
	mov	eax, DWORD PTR [esi]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN369@Insert_noh
	add	esi, 4
	add	ecx, 4
	sub	edx, 4
	jae	SHORT $LL371@Insert_noh
$LN370@Insert_noh:
	cmp	edx, -4					; fffffffcH
	je	SHORT $LN368@Insert_noh
$LN369@Insert_noh:
	mov	al, BYTE PTR [esi]
	cmp	al, BYTE PTR [ecx]
	jne	SHORT $LN372@Insert_noh
	cmp	edx, -3					; fffffffdH
	je	SHORT $LN368@Insert_noh
	mov	al, BYTE PTR [esi+1]
	cmp	al, BYTE PTR [ecx+1]
	jne	SHORT $LN372@Insert_noh
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN368@Insert_noh
	mov	al, BYTE PTR [esi+2]
	cmp	al, BYTE PTR [ecx+2]
	jne	SHORT $LN372@Insert_noh
	cmp	edx, -1
	je	SHORT $LN368@Insert_noh
	mov	al, BYTE PTR [esi+3]
	cmp	al, BYTE PTR [ecx+3]
	je	SHORT $LN368@Insert_noh
$LN372@Insert_noh:
	sbb	eax, eax
	or	eax, 1
	jmp	SHORT $LN373@Insert_noh
$LN368@Insert_noh:
	xor	eax, eax
$LN373@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN216@Insert_noh
	mov	eax, DWORD PTR __Left_size$1$[ebp]
$LN214@Insert_noh:

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	edi, eax
	jbe	SHORT $LN381@Insert_noh

; 2102 : 			return (-1);

	or	eax, -1
	jmp	SHORT $LN216@Insert_noh
$LN381@Insert_noh:

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN216@Insert_noh:

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
$LN380@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1785 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

	mov	BYTE PTR __Addleft$2[ebp], al

; 1786 : 					this->_Kfn(_Val),
; 1787 : 					this->_Key(_Trynode));	// favor right end
; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	test	al, al
	je	SHORT $LN16@Insert_noh
	mov	ebx, DWORD PTR [ebx]
	jmp	SHORT $LN17@Insert_noh
$LN16@Insert_noh:
	mov	ebx, DWORD PTR [ebx+8]
$LN17@Insert_noh:

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [ebx+13], 0
	mov	edx, DWORD PTR __Val$[ebp]
	mov	esi, DWORD PTR [edx+20]
	je	$LL2@Insert_noh
	mov	ecx, DWORD PTR __Wherenode$1$[ebp]
	mov	edx, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR tv875[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	esi, ecx
	mov	DWORD PTR __Where$4[ebp], esi

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1798 : 			if (!_Addleft)

	test	al, al
	je	SHORT $LN12@Insert_noh

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	ecx, DWORD PTR [edi]

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	mov	edi, DWORD PTR __Val$[ebp]
	push	edi
	push	ecx
	push	1
	mov	ecx, edx
$LN383@Insert_noh:
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$_Insert_at@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@1@_NPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@1@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_at<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator--
	mov	esi, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:

; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	mov	edi, DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	mov	ebx, DWORD PTR _this$[ebp]
	mov	ecx, ebx
	push	edi
	push	eax
	call	??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()

; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	mov	ecx, ebx
	push	DWORD PTR __Newnode$[ebp]
	test	al, al
	je	SHORT $LN13@Insert_noh
	push	edi
	push	DWORD PTR __Wherenode$1$[ebp]
	push	DWORD PTR __Addleft$2[ebp]
	jmp	SHORT $LN383@Insert_noh
__catch$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z$0:

; 1814 : 				return (_Pairib(_Where, false));
; 1815 : 				}
; 1816 : 			}
; 1817 : 		_CATCH_ALL
; 1818 : 		_Destroy_if_not_nil(_Newnode);

	push	DWORD PTR __Newnode$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Destroy_if_not_nil

; 1819 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN384@Insert_noh:
$LN13@Insert_noh:

; 1810 : 					_STD forward<_Valty>(_Val), _Newnode), true));
; 1811 : 			else
; 1812 : 				{	// duplicate, don't insert
; 1813 : 				_Destroy_if_not_nil(_Newnode);

	call	?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Destroy_if_not_nil
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN378@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
_<_Val_0>$ = 8						; size = 4
??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >, COMDAT
; _this$ = ecx

; 880  : 		{	// allocate a node with defaults and set links and value

	push	ebp
	mov	ebp, esp
	push	ebx
	push	edi

; 881  : 		_Nodeptr _Pnode = _Buynode0();

	call	?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode0
	mov	edi, eax

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	ebx, DWORD PTR [edi+16]

; 882  : 
; 883  : 		this->_Color(_Pnode) = _Red;

	mov	WORD PTR [edi+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ebx, ebx
	je	SHORT $LN47@Buynode
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR _<_Val_0>$[ebp]
	mov	ecx, ebx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ebx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ebx+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ebx+24], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 895  : 		return (_Pnode);

	mov	eax, edi
	pop	esi
$LN47@Buynode:
	pop	edi
	pop	ebx

; 896  : 		}

	pop	ebp
	ret	4
??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@$$QA_N@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@$$QA_N@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [ecx+4], al

; 173  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_NX$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@std@@QAE@$$QAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@$$QA_N@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool>::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,bool,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_at@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@_NPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@U_Nil@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Addleft$ = 12						; size = 1
__Wherenode$ = 16					; size = 4
__Val$ = 20						; size = 4
__Node$ = 24						; size = 1
??$_Insert_at@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@_NPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@U_Nil@1@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_at<gxTimer * const &,std::_Nil>, COMDAT
; _this$ = ecx

; 1827 : 		{	// add node with value next to _Wherenode, to left if _Addleft

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 1828 : 		if (max_size() - 1 <= this->_Mysize())

	cmp	DWORD PTR [edi+4], 214748363		; 0ccccccbH
	jae	$LN688@Insert_at

; 1636 : 		return (this->_Buynode(_STD forward<_Valty>(_Val)));

	push	DWORD PTR __Val$[ebp]
	call	??$_Buynode@ABQAVgxTimer@@@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@@Z ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode<gxTimer * const &>

; 1832 : 			}
; 1833 : 		_Nodeptr _Newnode = _Buynode_if_nil(_Node,
; 1834 : 			_STD forward<_Valty>(_Val));
; 1835 : 
; 1836 : 		++this->_Mysize();

	inc	DWORD PTR [edi+4]
	mov	ebx, eax

; 1837 : 		_Newnode->_Parent = _Wherenode;

	mov	ecx, DWORD PTR __Wherenode$[ebp]
	mov	DWORD PTR [ebx+4], ecx

; 1838 : 
; 1839 : 		if (_Wherenode == this->_Myhead())

	mov	eax, DWORD PTR [edi]
	cmp	ecx, eax
	jne	SHORT $LN6@Insert_at

; 1840 : 			{	// first node in tree, just set head values
; 1841 : 			_Root() = _Newnode;

	mov	DWORD PTR [eax+4], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1842 : 			_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1843 : 			_Rmost() = _Newnode;

	mov	eax, DWORD PTR [edi]
	jmp	SHORT $LN685@Insert_at
$LN6@Insert_at:

; 1844 : 			}
; 1845 : 		else if (_Addleft)

	cmp	BYTE PTR __Addleft$[ebp], 0
	je	SHORT $LN8@Insert_at

; 1846 : 			{	// add to left of _Wherenode
; 1847 : 			this->_Left(_Wherenode) = _Newnode;

	mov	DWORD PTR [ecx], ebx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 1848 : 			if (_Wherenode == _Lmost())

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN11@Insert_at

; 1849 : 				_Lmost() = _Newnode;

	mov	DWORD PTR [eax], ebx

; 1850 : 			}
; 1851 : 		else

	jmp	SHORT $LN11@Insert_at
$LN8@Insert_at:

; 1852 : 			{	// add to right of _Wherenode
; 1853 : 			this->_Right(_Wherenode) = _Newnode;

	mov	DWORD PTR [ecx+8], ebx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1854 : 			if (_Wherenode == _Rmost())

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN11@Insert_at
$LN685@Insert_at:

; 1855 : 				_Rmost() = _Newnode;

	mov	DWORD PTR [eax+8], ebx
$LN11@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [ebx+4]
	mov	esi, ebx
	cmp	BYTE PTR [eax+12], 0
	jne	$LN3@Insert_at
$LL2@Insert_at:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi+4]

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [eax+4]

; 1860 : 			if (this->_Parent(_Pnode)
; 1861 : 				== this->_Left(this->_Parent(this->_Parent(_Pnode))))

	mov	ecx, DWORD PTR [edx]
	cmp	eax, ecx
	jne	SHORT $LN12@Insert_at

; 1862 : 				{	// fixup red-red in left subtree
; 1863 : 				_Wherenode =

	mov	ecx, DWORD PTR [edx+8]

; 1864 : 					this->_Right(this->_Parent(this->_Parent(_Pnode)));
; 1865 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	je	SHORT $LN687@Insert_at

; 1866 : 					{	// parent has two red children, blacken both
; 1867 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;
; 1868 : 					this->_Color(_Wherenode) = this->_Black;
; 1869 : 					this->_Color(this->_Parent(this->_Parent(_Pnode)))
; 1870 : 						= this->_Red;
; 1871 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));
; 1872 : 					}
; 1873 : 				else
; 1874 : 					{	// parent has red and black children
; 1875 : 					if (_Pnode == this->_Right(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN16@Insert_at

; 1876 : 						{	// rotate right child to left
; 1877 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1878 : 						_Lrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lrotate
$LN16@Insert_at:

; 1879 : 						}
; 1880 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1881 : 						this->_Black;	// propagate red up
; 1882 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1883 : 						this->_Red;
; 1884 : 					_Rrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR [ecx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN335@Insert_at

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN335@Insert_at:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2119 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN336@Insert_at

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN686@Insert_at
$LN336@Insert_at:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN338@Insert_at

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	$LN686@Insert_at
$LN338@Insert_at:

; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx+8], ecx

; 1885 : 					}
; 1886 : 				}
; 1887 : 			else

	jmp	SHORT $LN686@Insert_at
$LN12@Insert_at:

; 1888 : 				{	// fixup red-red in right subtree
; 1889 : 				_Wherenode =
; 1890 : 					this->_Left(this->_Parent(this->_Parent(_Pnode)));
; 1891 : 				if (this->_Color(_Wherenode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN17@Insert_at
$LN687@Insert_at:

; 1892 : 					{	// parent has two red children, blacken both
; 1893 : 					this->_Color(this->_Parent(_Pnode)) = this->_Black;

	mov	BYTE PTR [eax+12], 1

; 1894 : 					this->_Color(_Wherenode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1895 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1896 : 						this->_Red;
; 1897 : 					_Pnode = this->_Parent(this->_Parent(_Pnode));

	mov	eax, DWORD PTR [esi+4]
	mov	esi, DWORD PTR [eax+4]

; 1898 : 					}
; 1899 : 				else

	jmp	SHORT $LN18@Insert_at
$LN17@Insert_at:

; 1900 : 					{	// parent has red and black children
; 1901 : 					if (_Pnode == this->_Left(this->_Parent(_Pnode)))

	cmp	esi, DWORD PTR [eax]
	jne	SHORT $LN19@Insert_at

; 1902 : 						{	// rotate left child to right
; 1903 : 						_Pnode = this->_Parent(_Pnode);

	mov	esi, eax

; 1904 : 						_Rrotate(_Pnode);

	mov	ecx, edi
	push	esi
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rrotate
$LN19@Insert_at:

; 1905 : 						}
; 1906 : 					this->_Color(this->_Parent(_Pnode)) =

	mov	eax, DWORD PTR [esi+4]
	mov	BYTE PTR [eax+12], 1

; 1907 : 						this->_Black;	// propagate red up
; 1908 : 					this->_Color(this->_Parent(this->_Parent(_Pnode))) =

	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 0

; 1909 : 						this->_Red;
; 1910 : 					_Lrotate(this->_Parent(this->_Parent(_Pnode)));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [eax+4]

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	edx, DWORD PTR [ecx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [ecx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN534@Insert_at

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], ecx
$LN534@Insert_at:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 2089 : 		if (_Wherenode == _Root())

	cmp	ecx, DWORD PTR [eax+4]
	jne	SHORT $LN535@Insert_at

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], edx

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	jmp	SHORT $LN538@Insert_at
$LN535@Insert_at:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN537@Insert_at

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], edx

; 2093 : 		else

	jmp	SHORT $LN538@Insert_at
$LN537@Insert_at:

; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], edx
$LN538@Insert_at:

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [edx], ecx
$LN686@Insert_at:

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [ecx+4], edx
$LN18@Insert_at:

; 1856 : 			}
; 1857 : 
; 1858 : 		for (_Nodeptr _Pnode = _Newnode;
; 1859 : 			this->_Color(this->_Parent(_Pnode)) == this->_Red; )

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+12], 0
	je	$LL2@Insert_at
$LN3@Insert_at:

; 1911 : 					}
; 1912 : 				}
; 1913 : 
; 1914 : 		this->_Color(_Root()) = this->_Black;	// root is always black

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi
	mov	eax, DWORD PTR [eax+4]
	mov	BYTE PTR [eax+12], 1

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 1915 : 		return (iterator(_Newnode, &this->_Get_data()));
; 1916 : 		}

	pop	ebp
	ret	20					; 00000014H
$LN688@Insert_at:

; 1829 : 			{	// tree would get too big, fail
; 1830 : 			_Destroy_if_not_nil(_Node);
; 1831 : 			_Xlength_error("map/set<T> too long");

	push	OFFSET ??_C@_0BE@JONHPENG@map?1set?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN690@Insert_at:
$LN684@Insert_at:
	int	3
??$_Insert_at@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@_NPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@U_Nil@1@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_at<gxTimer * const &,std::_Nil>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAVgxTimer@@@std@@YGABQAVgxTimer@@ABQAV1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAVgxTimer@@@std@@YGABQAVgxTimer@@ABQAV1@@Z PROC ; std::forward<gxTimer * const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@ABQAVgxTimer@@@std@@YGABQAVgxTimer@@ABQAV1@@Z ENDP ; std::forward<gxTimer * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@YGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@YGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@YGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@YGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@YGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@YGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<std::_Tree_node<gxTimer *,void *> *,std::_Tree_node<gxTimer *,void *> * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<std::_Tree_node<gxTimer *,void *> *,std::_Tree_node<gxTimer *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAU?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@YGAAPAU?$_Tree_node@PAVgxTimer@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAU?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@YGAAPAU?$_Tree_node@PAVgxTimer@@PAX@0@AAPAU10@@Z PROC ; std::forward<std::_Tree_node<gxTimer *,void *> * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAPAU?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@YGAAPAU?$_Tree_node@PAVgxTimer@@PAX@0@AAPAU10@@Z ENDP ; std::forward<std::_Tree_node<gxTimer *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT

; 863  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN18@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN110@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	8
$LN110@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	8
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUGfxDriver@gxRuntime@@PAPAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUGfxDriver@gxRuntime@@PAPAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z PROC ; std::_Uninitialized_move<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *,std::allocator<gxRuntime::GfxDriver *> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 319  : 	}

	pop	ebp
	ret	16					; 00000010H
??$_Uninitialized_move@PAPAUGfxDriver@gxRuntime@@PAPAU12@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<gxRuntime::GfxDriver * *,gxRuntime::GfxDriver * *,std::allocator<gxRuntime::GfxDriver *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAUGfxMode@gxRuntime@@@std@@PAPAUGfxMode@gxRuntime@@@std@@YGXPAPAUGfxMode@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAUGfxMode@gxRuntime@@@std@@PAPAUGfxMode@gxRuntime@@@std@@YGXPAPAUGfxMode@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<gxRuntime::GfxMode *>,gxRuntime::GfxMode * *>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	16					; 00000010H
??$_Destroy_range1@V?$allocator@PAUGfxMode@gxRuntime@@@std@@PAPAUGfxMode@gxRuntime@@@std@@YGXPAPAUGfxMode@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<gxRuntime::GfxMode *>,gxRuntime::GfxMode * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAPAUGfxMode@gxRuntime@@PAPAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAPAUGfxMode@gxRuntime@@PAPAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z PROC ; std::_Uninitialized_move<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *,std::allocator<gxRuntime::GfxMode *> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Dest$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory

; 319  : 	}

	pop	ebp
	ret	16					; 00000010H
??$_Uninitialized_move@PAPAUGfxMode@gxRuntime@@PAPAU12@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@00AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<gxRuntime::GfxMode * *,gxRuntime::GfxMode * *,std::allocator<gxRuntime::GfxMode *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	8
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YGABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YGABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABU10@@Z PROC ; std::forward<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@@std@@YGABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@0@ABU10@@Z ENDP ; std::forward<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	8
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVgxTimer@@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAVgxTimer@@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAVgxTimer@@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAVgxTimer@@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<gxTimer *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	8
??$destroy@PAVgxTimer@@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAVgxTimer@@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<gxTimer *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAD@std@@YG$$QADAAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAD@std@@YG$$QADAAD@Z PROC			; std::move<char &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	4
??$move@AAD@std@@YG$$QADAAD@Z ENDP			; std::move<char &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Zero_then_variadic_args_t@std@@@std@@YG$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YG$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z PROC ; std::forward<std::_Zero_then_variadic_args_t>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@U_Zero_then_variadic_args_t@std@@@std@@YG$$QAU_Zero_then_variadic_args_t@0@AAU10@@Z ENDP ; std::forward<std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABU?$less@PAVgxTimer@@@std@@@std@@YGABU?$less@PAVgxTimer@@@0@ABU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABU?$less@PAVgxTimer@@@std@@@std@@YGABU?$less@PAVgxTimer@@@0@ABU10@@Z PROC ; std::forward<std::less<gxTimer *> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@ABU?$less@PAVgxTimer@@@std@@@std@@YGABU?$less@PAVgxTimer@@@0@ABU10@@Z ENDP ; std::forward<std::less<gxTimer *> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	8
??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@1@PAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0ABV?$allocator@D@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$allocator@D@std@@@std@@YGABV?$allocator@D@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$allocator@D@std@@@std@@YGABV?$allocator@D@0@ABV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@ABV?$allocator@D@std@@@std@@YGABV?$allocator@D@0@ABV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SGXAAV?$allocator@D@1@PAPADAAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SGXAAV?$allocator@D@1@PAPADAAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PADAAPAD@?$allocator_traits@V?$allocator@D@std@@@std@@SGXAAV?$allocator@D@1@PAPADAAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAD@std@@YGAAPADAAPAD@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAD@std@@YGAAPADAAPAD@Z PROC		; std::forward<char * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAPAD@std@@YGAAPADAAPAD@Z ENDP		; std::forward<char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SGXAAV?$allocator@D@1@PAPAD@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SGXAAV?$allocator@D@1@PAPAD@Z PROC ; std::allocator_traits<std::allocator<char> >::destroy<char *>, COMDAT

; 864  : 		_Al.destroy(_Ptr);
; 865  : 		}

	ret	8
??$destroy@PAD@?$allocator_traits@V?$allocator@D@std@@@std@@SGXAAV?$allocator@D@1@PAPAD@Z ENDP ; std::allocator_traits<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1039 : 	}

	ret	12					; 0000000cH
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1052 : 	_Left = _STD move(_Right);
; 1053 : 	}

	ret	12					; 0000000cH
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YG$$QAV?$allocator@D@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@D@std@@@std@@YG$$QAV?$allocator@D@0@AAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@V?$allocator@D@std@@@std@@YG$$QAV?$allocator@D@0@AAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@PAPAUGfxDriver@gxRuntime@@@std@@YGXPAPAUGfxDriver@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@PAPAUGfxDriver@gxRuntime@@@std@@YGXPAPAUGfxDriver@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<gxRuntime::GfxDriver *>,gxRuntime::GfxDriver * *>, COMDAT

; 1108 : 		// nothing to do
; 1109 : 	}

	ret	16					; 00000010H
??$_Destroy_range1@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@PAPAUGfxDriver@gxRuntime@@@std@@YGXPAPAUGfxDriver@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<gxRuntime::GfxDriver *>,gxRuntime::GfxDriver * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >, COMDAT

; 863  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN18@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN18@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN110@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	8
$LN110@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 865  : 		}

	pop	ebp
	ret	8
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGXAAV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@1@PAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@0@Z PROC ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], eax

; 173  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??$?0AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@AAV01@X$0A@@?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@std@@QAE@AAV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@0@Z ENDP ; std::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >::pair<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > ><std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &,std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > &,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YG$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YG$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YG$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8DD@std@@YG_NABV?$allocator@D@0@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?8DD@std@@YG_NABV?$allocator@D@0@0@Z PROC		; std::operator==<char,char>, COMDAT

; 796  : 	return (true);

	mov	al, 1

; 797  : 	}

	ret	8
??$?8DD@std@@YG_NABV?$allocator@D@0@0@Z ENDP		; std::operator==<char,char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?8V?$allocator@D@std@@V01@@std@@YG_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8V?$allocator@D@std@@V01@@std@@YG_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator==<std::allocator<char>,std::allocator<char> >, COMDAT

; 1017 : 	return (static_cast<const _Ty&>(_Left)

	mov	al, 1

; 1018 : 		== static_cast<const _Other&>(_Right));
; 1019 : 	}

	ret	8
??$?8V?$allocator@D@std@@V01@@std@@YG_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator==<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxDriver@gxRuntime@@@1@PAPAUGfxDriver@gxRuntime@@ABQAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxDriver@gxRuntime@@@1@PAPAUGfxDriver@gxRuntime@@ABQAU34@@Z PROC ; std::allocator_traits<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxDriver@gxRuntime@@@1@PAPAUGfxDriver@gxRuntime@@ABQAU34@@Z ENDP ; std::allocator_traits<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAUGfxDriver@gxRuntime@@@std@@YGABQAUGfxDriver@gxRuntime@@ABQAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAUGfxDriver@gxRuntime@@@std@@YGABQAUGfxDriver@gxRuntime@@ABQAU12@@Z PROC ; std::forward<gxRuntime::GfxDriver * const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@ABQAUGfxDriver@gxRuntime@@@std@@YGABQAUGfxDriver@gxRuntime@@ABQAU12@@Z ENDP ; std::forward<gxRuntime::GfxDriver * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxDriver@gxRuntime@@@1@PAPAUGfxDriver@gxRuntime@@AAPAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxDriver@gxRuntime@@@1@PAPAUGfxDriver@gxRuntime@@AAPAU34@@Z PROC ; std::allocator_traits<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxDriver@gxRuntime@@@1@PAPAUGfxDriver@gxRuntime@@AAPAU34@@Z ENDP ; std::allocator_traits<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAUGfxDriver@gxRuntime@@@std@@YGAAPAUGfxDriver@gxRuntime@@AAPAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUGfxDriver@gxRuntime@@@std@@YGAAPAUGfxDriver@gxRuntime@@AAPAU12@@Z PROC ; std::forward<gxRuntime::GfxDriver * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAPAUGfxDriver@gxRuntime@@@std@@YGAAPAUGfxDriver@gxRuntime@@AAPAU12@@Z ENDP ; std::forward<gxRuntime::GfxDriver * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxMode@gxRuntime@@@1@PAPAUGfxMode@gxRuntime@@ABQAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxMode@gxRuntime@@@1@PAPAUGfxMode@gxRuntime@@ABQAU34@@Z PROC ; std::allocator_traits<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxMode@gxRuntime@@@1@PAPAUGfxMode@gxRuntime@@ABQAU34@@Z ENDP ; std::allocator_traits<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABQAUGfxMode@gxRuntime@@@std@@YGABQAUGfxMode@gxRuntime@@ABQAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABQAUGfxMode@gxRuntime@@@std@@YGABQAUGfxMode@gxRuntime@@ABQAU12@@Z PROC ; std::forward<gxRuntime::GfxMode * const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@ABQAUGfxMode@gxRuntime@@@std@@YGABQAUGfxMode@gxRuntime@@ABQAU12@@Z ENDP ; std::forward<gxRuntime::GfxMode * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxMode@gxRuntime@@@1@PAPAUGfxMode@gxRuntime@@AAPAU34@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxMode@gxRuntime@@@1@PAPAUGfxMode@gxRuntime@@AAPAU34@@Z PROC ; std::allocator_traits<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN8@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN8@construct:

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);
; 858  : 		}

	pop	ebp
	ret	12					; 0000000cH
??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGXAAV?$allocator@PAUGfxMode@gxRuntime@@@1@PAPAUGfxMode@gxRuntime@@AAPAU34@@Z ENDP ; std::allocator_traits<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAUGfxMode@gxRuntime@@@std@@YGAAPAUGfxMode@gxRuntime@@AAPAU12@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUGfxMode@gxRuntime@@@std@@YGAAPAUGfxMode@gxRuntime@@AAPAU12@@Z PROC ; std::forward<gxRuntime::GfxMode * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAPAUGfxMode@gxRuntime@@@std@@YGAAPAUGfxMode@gxRuntime@@AAPAU12@@Z ENDP ; std::forward<gxRuntime::GfxMode * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
___formal$ = 16						; size = 1
??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z PROC ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >, COMDAT

; 1099 : 	{	// return distance between iterators; input

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Last$[ebp]
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 1100 : 	_Iter_diff_t<_InIt> _Off = 0;

	xor	esi, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 1101 : 	for (; _First != _Last; ++_First)

	je	SHORT $LN56@Distance1
$LL14@Distance1:

; 1102 : 		++_Off;

	inc	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN49@Distance1

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN46@Distance1

; 63   : 			_Ptr = _Mytree::_Min(

	mov	eax, edx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN26@Distance1
	npad	6
$LL25@Distance1:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	eax, edx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL25@Distance1

; 65   : 		else

	jmp	SHORT $LN26@Distance1
$LN46@Distance1:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN57@Distance1
$LL9@Distance1:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN57@Distance1

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL9@Distance1
$LN57@Distance1:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	eax, edx
$LN26@Distance1:
	mov	DWORD PTR __First$[ebp], eax
$LN49@Distance1:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 1101 : 	for (; _First != _Last; ++_First)

	jne	SHORT $LL14@Distance1
$LN56@Distance1:

; 1103 : 
; 1104 : 	return (_Off);

	mov	eax, esi
	pop	esi

; 1105 : 	}

	pop	ebp
	ret	12					; 0000000cH
??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ENDP ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Val_0>$ = 12						; size = 4
??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT
; _this$ = ecx

; 1075 : 		{	// try to insert value_type(_Val...), favoring right side

	push	ebp
	mov	ebp, esp
	push	edi

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[ebp]
	mov	edi, ecx
	call	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >

; 1077 : 		return (_Insert_nohint(false,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1077 : 		return (_Insert_nohint(false,

	mov	ecx, edi
	push	eax
	push	0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi

; 1078 : 			this->_Myval(_Newnode), _Newnode));
; 1079 : 		}

	pop	ebp
	ret	8
??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YG$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YG$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z PROC ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YG$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z ENDP ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@ZX$0A@@?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAP6GHPBXHPAXH@Z@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@ZX$0A@@?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAP6GHPBXHPAXH@Z@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,int (__stdcall*&)(void const *,int,void *,int),void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Val1$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 172  : 		{	// construct from moved values

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+24], eax

; 173  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@ZX$0A@@?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAP6GHPBXHPAXH@Z@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,int (__stdcall*&)(void const *,int,void *,int),void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAP6GHPBXHPAXH@Z@std@@YGAAP6GHPBXHPAXH@ZAAP6GH0H1H@Z@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAP6GHPBXHPAXH@Z@std@@YGAAP6GHPBXHPAXH@ZAAP6GH0H1H@Z@Z PROC ; std::forward<int (__stdcall*&)(void const *,int,void *,int)>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAP6GHPBXHPAXH@Z@std@@YGAAP6GHPBXHPAXH@ZAAP6GH0H1H@Z@Z ENDP ; std::forward<int (__stdcall*&)(void const *,int,void *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_<_Val_0>$ = 12						; size = 4
??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >, COMDAT
; _this$ = ecx

; 1075 : 		{	// try to insert value_type(_Val...), favoring right side

	push	ebp
	mov	ebp, esp
	push	edi

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	DWORD PTR _<_Val_0>$[ebp]
	mov	edi, ecx
	call	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >

; 1077 : 		return (_Insert_nohint(false,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1077 : 		return (_Insert_nohint(false,

	mov	ecx, edi
	push	eax
	push	0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi

; 1078 : 			this->_Myval(_Newnode), _Newnode));
; 1079 : 		}

	pop	ebp
	ret	8
??$emplace@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::emplace<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YG$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YG$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z PROC ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YG$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z ENDP ; std::forward<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@X$0A@@?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAPAUgxDll@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Val1$ = 8						; size = 4
__Val2$ = 12						; size = 4
??$?0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@X$0A@@?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAPAUgxDll@@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,gxDll * &,void,0>, COMDAT
; _this$ = ecx

; 172  : 		{	// construct from moved values

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Val1$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 172  : 		{	// construct from moved values

	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	eax, DWORD PTR __Val2$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+24], eax

; 173  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@X$0A@@?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@AAPAUgxDll@@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *><std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,gxDll * &,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAPAUgxDll@@@std@@YGAAPAUgxDll@@AAPAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAPAUgxDll@@@std@@YGAAPAUgxDll@@AAPAU1@@Z PROC ; std::forward<gxDll * &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@AAPAUgxDll@@@std@@YGAAPAUgxDll@@AAPAU1@@Z ENDP ; std::forward<gxDll * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@ABV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z
_TEXT	SEGMENT
_this$1$ = -28						; size = 4
tv489 = -24						; size = 4
__Addleft$2 = -20					; size = 1
__$EHRec$ = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
$T3 = 12						; size = 4
__Where$4 = 12						; size = 4
__Leftish$ = 12						; size = 1
__Val$ = 16						; size = 4
__Newnode$ = 20						; size = 1
??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_nohint<gxTimer * const &,std::_Nil>, COMDAT
; _this$ = ecx

; 1771 : 		{	// try to insert node, on left if _Leftish

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 16					; 00000010H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR [ebx]

; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	dl, 1
	mov	edi, DWORD PTR __Val$[ebp]
	mov	esi, ecx
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	DWORD PTR tv489[ebp], ecx

; 1772 : 		_TRY_BEGIN
; 1773 : 		_Nodeptr _Trynode = _Root();

	mov	eax, DWORD PTR [ecx+4]

; 1774 : 		_Nodeptr _Wherenode = this->_Myhead();
; 1775 : 		bool _Addleft = true;	// add to left of head if tree empty

	mov	BYTE PTR __Addleft$2[ebp], dl

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@Insert_noh
	mov	ecx, DWORD PTR [edi]
	mov	bl, BYTE PTR __Leftish$[ebp]
$LL2@Insert_noh:

; 1778 : 			{	// look for leaf to insert before (_Addleft) or after
; 1779 : 			_Wherenode = _Trynode;

	mov	esi, eax

; 1780 : 			if (_Leftish)

	test	bl, bl
	je	SHORT $LN5@Insert_noh
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 239  : 		return (_Left < _Right);

	cmp	DWORD PTR [eax+16], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1781 : 				_Addleft = !_DEBUG_LT_PRED(this->_Getcomp(),

	setae	dl

; 1782 : 					this->_Key(_Trynode),
; 1783 : 					this->_Kfn(_Val));	// favor left end
; 1784 : 			else

	jmp	SHORT $LN243@Insert_noh
$LN5@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 239  : 		return (_Left < _Right);

	cmp	ecx, DWORD PTR [eax+16]
	setb	dl
$LN243@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1785 : 				_Addleft = _DEBUG_LT_PRED(this->_Getcomp(),

	mov	BYTE PTR __Addleft$2[ebp], dl

; 1786 : 					this->_Kfn(_Val),
; 1787 : 					this->_Key(_Trynode));	// favor right end
; 1788 : 			_Trynode = _Addleft ? this->_Left(_Trynode)

	test	dl, dl
	je	SHORT $LN16@Insert_noh
	mov	eax, DWORD PTR [eax]
	jmp	SHORT $LN17@Insert_noh
$LN16@Insert_noh:
	mov	eax, DWORD PTR [eax+8]
$LN17@Insert_noh:

; 1776 : 
; 1777 : 		while (!this->_Isnil(_Trynode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Insert_noh
	mov	ecx, DWORD PTR tv489[ebp]
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN3@Insert_noh:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, esi
	mov	DWORD PTR __Where$4[ebp], eax

; 1789 : 				: this->_Right(_Trynode);
; 1790 : 			}
; 1791 : 
; 1792 : 		if (this->_Multi)
; 1793 : 			return (_Pairib(_Insert_at(_Addleft, _Wherenode,
; 1794 : 				_STD forward<_Valty>(_Val), _Newnode), true));
; 1795 : 		else
; 1796 : 			{	// insert only if unique
; 1797 : 			iterator _Where = iterator(_Wherenode, &this->_Get_data());
; 1798 : 			if (!_Addleft)

	test	dl, dl
	je	SHORT $LN12@Insert_noh

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR [ecx]

; 1799 : 				;	// need to test if insert after is okay
; 1800 : 			else if (_Where == begin())

	jne	SHORT $LN11@Insert_noh

; 1801 : 				return (_Pairib(_Insert_at(true, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	edi
	push	esi
	push	1
$LN244@Insert_noh:
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, ebx
	push	eax
	call	??$_Insert_at@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@1@_NPAU?$_Tree_node@PAVgxTimer@@PAX@1@ABQAVgxTimer@@U_Nil@1@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_at<gxTimer * const &,std::_Nil>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [eax+4], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN11@Insert_noh:

; 310  : 		--static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$4[ebp]
	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator--
	mov	eax, DWORD PTR __Where$4[ebp]
$LN12@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 239  : 		return (_Left < _Right);

	mov	ecx, DWORD PTR [eax+16]
	cmp	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1806 : 			if (_DEBUG_LT_PRED(this->_Getcomp(),

	jae	SHORT $LN13@Insert_noh

; 1807 : 				this->_Key(_Where._Mynode()),
; 1808 : 				this->_Kfn(_Val)))
; 1809 : 				return (_Pairib(_Insert_at(_Addleft, _Wherenode,

	push	DWORD PTR __Newnode$[ebp]
	push	edi
	push	esi
	push	DWORD PTR __Addleft$2[ebp]
	jmp	SHORT $LN244@Insert_noh
__catch$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z$0:

; 1815 : 				}
; 1816 : 			}
; 1817 : 		_CATCH_ALL
; 1818 : 		_Destroy_if_not_nil(_Newnode);
; 1819 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8
$LN245@Insert_noh:
$LN13@Insert_noh:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1814 : 				return (_Pairib(_Where, false));

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1821 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN242@Insert_noh:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_nohint<gxTimer * const &,std::_Nil>
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YG$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YG$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	4
??$move@AAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YG$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::construct<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU21@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<std::_Tree_node<gxTimer *,void *> *,std::_Tree_node<gxTimer *,void *> * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@AAPAU12@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@AAPAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::construct<std::_Tree_node<gxTimer *,void *> *,std::_Tree_node<gxTimer *,void *> * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN20@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN20@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN112@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
$LN112@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@D@std@@YGPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@D@std@@YGPADAAD@Z PROC			; std::addressof<char>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@D@std@@YGPADAAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAD@std@@SGPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAD@std@@SGPADAAD@Z PROC	; std::pointer_traits<char *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 280  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 281  : 		}

	pop	ebp
	ret	4
?pointer_to@?$pointer_traits@PAD@std@@SGPADAAD@Z ENDP	; std::pointer_traits<char *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUGfxDriver@gxRuntime@@@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEPAPAUGfxDriver@gxRuntime@@PAPAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUGfxDriver@gxRuntime@@@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEPAPAUGfxDriver@gxRuntime@@PAPAU23@00@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Umove<gxRuntime::GfxDriver * *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Ptr$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAUGfxDriver@gxRuntime@@@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEPAPAUGfxDriver@gxRuntime@@PAPAU23@00@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Umove<gxRuntime::GfxDriver * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAUGfxMode@gxRuntime@@@std@@PAPAUGfxMode@gxRuntime@@@std@@YGXPAPAUGfxMode@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUGfxMode@gxRuntime@@@std@@PAPAUGfxMode@gxRuntime@@@std@@YGXPAPAUGfxMode@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<gxRuntime::GfxMode *>,gxRuntime::GfxMode * *>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	12					; 0000000cH
??$_Destroy_range@V?$allocator@PAUGfxMode@gxRuntime@@@std@@PAPAUGfxMode@gxRuntime@@@std@@YGXPAPAUGfxMode@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<gxRuntime::GfxMode *>,gxRuntime::GfxMode * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAPAUGfxMode@gxRuntime@@@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEPAPAUGfxMode@gxRuntime@@PAPAU23@00@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAPAUGfxMode@gxRuntime@@@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEPAPAUGfxMode@gxRuntime@@PAPAU23@00@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Umove<gxRuntime::GfxMode * *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __First$[ebp]
	push	esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, DWORD PTR __Ptr$[ebp]
	push	edi

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edi, DWORD PTR __Last$[ebp]
	sub	edi, eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edi
	push	eax
	push	esi
	call	_memmove
	add	esp, 12					; 0000000cH

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	lea	eax, DWORD PTR [edi+esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1661 : 		}

	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAPAUGfxMode@gxRuntime@@@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEPAPAUGfxMode@gxRuntime@@PAPAU23@00@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Umove<gxRuntime::GfxMode * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@SGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@SGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>, COMDAT

; 61   : 		{	// extract key from element value

	push	ebp
	mov	ebp, esp

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 63   : 		}

	pop	ebp
	ret	4
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@SGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@YGPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@YGPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@YGPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@SGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@SGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>, COMDAT

; 61   : 		{	// extract key from element value

	push	ebp
	mov	ebp, esp

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Val$[ebp]

; 63   : 		}

	pop	ebp
	ret	4
??$_Kfn@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@SGABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0>::_Kfn<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1><std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > > const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@YGPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@YGPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@YGPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAVgxTimer@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAVgxTimer@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAVgxTimer@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAVgxTimer@@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<gxTimer *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAVgxTimer@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAVgxTimer@@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<gxTimer *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAVgxTimer@@@std@@YGPAPAVgxTimer@@AAPAV1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAVgxTimer@@@std@@YGPAPAVgxTimer@@AAPAV1@@Z PROC ; std::addressof<gxTimer *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@PAVgxTimer@@@std@@YGPAPAVgxTimer@@AAPAV1@@Z ENDP ; std::addressof<gxTimer *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$swap@DX@std@@YGXAAD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$swap@DX@std@@YGXAAD0@Z PROC				; std::swap<char,void>, COMDAT

; 48   : 	{	// exchange values stored at _Left and _Right

	push	ebp
	mov	ebp, esp

; 49   : 	_Ty _Tmp = _STD move(_Left);
; 50   : 	_Left = _STD move(_Right);

	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Left$[ebp]
	push	ebx
	mov	al, BYTE PTR [ecx]
	mov	bl, BYTE PTR [edx]
	mov	BYTE PTR [edx], al

; 51   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ecx], bl
	pop	ebx

; 52   : 	}

	pop	ebp
	ret	8
??$swap@DX@std@@YGXAAD0@Z ENDP				; std::swap<char,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0ABU?$less@PAVgxTimer@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAVgxTimer@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
_<_Val2_0>$ = 16					; size = 4
??$?0ABU?$less@PAVgxTimer@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAVgxTimer@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1><std::less<gxTimer *> const &,std::_Zero_then_variadic_args_t>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 568  : 		_Mysize(0)

	mov	DWORD PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 290  : 		}

	ret	12					; 0000000cH
??$?0ABU?$less@PAVgxTimer@@@std@@U_Zero_then_variadic_args_t@1@@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAE@U_One_then_variadic_args_t@1@ABU?$less@PAVgxTimer@@@1@$$QAU_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1><std::less<gxTimer *> const &,std::_Zero_then_variadic_args_t>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@YGPAPAU?$_Tree_node@PAVgxTimer@@PAX@0@AAPAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@YGPAPAU?$_Tree_node@PAVgxTimer@@PAX@0@AAPAU10@@Z PROC ; std::addressof<std::_Tree_node<gxTimer *,void *> *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@YGPAPAU?$_Tree_node@PAVgxTimer@@PAX@0@AAPAU10@@Z ENDP ; std::addressof<std::_Tree_node<gxTimer *,void *> *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 598  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 598  : 		}

	ret	4
??$?0ABV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@ABV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const &,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PADAAPAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPADAAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::construct<char *,char * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YGPADPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@D@std@@YGPADPAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	4
??$_Unfancy@D@std@@YGPADPAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>, COMDAT
; _this$ = ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);
; 1004 : 		}

	ret	4
??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@PAD@std@@YGPAPADAAPAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@PAD@std@@YGPAPADAAPAD@Z PROC		; std::addressof<char *>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@PAD@std@@YGPAPADAAPAD@Z ENDP		; std::addressof<char *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z PROC ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1044 : 	typename _Alty::propagate_on_container_copy_assignment _Tag;
; 1045 : 	_Pocca(_Left, _Right, _Tag);
; 1046 : 	}

	ret	8
??$_Pocca@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@ABU10@@Z ENDP ; std::_Pocca<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >, COMDAT

; 1063 : 	typename _Alty::propagate_on_container_move_assignment _Tag;
; 1064 : 	_Pocma(_Left, _Right, _Tag);
; 1065 : 	}

	ret	8
??$_Pocma@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YGXAAU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::_Pocma<std::_Wrap_alloc<std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >, COMDAT
; _this$ = ecx

; 953  : 		}

	mov	eax, ecx
	ret	4
??$?0V?$allocator@D@std@@@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAV?$allocator@D@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> ><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z PROC ; std::operator<<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2519 : 	{	// test if string < string

	push	ebp
	mov	ebp, esp

; 729  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN25@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN25@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	edx, DWORD PTR __Left$[ebp]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	edi, DWORD PTR [edx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN48@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN48@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	esi, DWORD PTR [esi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, esi

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [edi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	ecx
	push	edx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN55@operator

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN57@operator

; 2102 : 			return (-1);

	or	eax, -1
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi

; 2521 : 	}

	pop	ebp
	ret	8
$LN57@operator:

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN55@operator:
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi

; 2521 : 	}

	pop	ebp
	ret	8
??$?MDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@0@Z ENDP ; std::operator<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@PAPAUGfxDriver@gxRuntime@@@std@@YGXPAPAUGfxDriver@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@PAPAUGfxDriver@gxRuntime@@@std@@YGXPAPAUGfxDriver@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<gxRuntime::GfxDriver *>,gxRuntime::GfxDriver * *>, COMDAT

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<
; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	ret	12					; 0000000cH
??$_Destroy_range@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@PAPAUGfxDriver@gxRuntime@@@std@@YGXPAPAUGfxDriver@gxRuntime@@0AAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<gxRuntime::GfxDriver *>,gxRuntime::GfxDriver * *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1><>, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	mov	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 281  : 		}

	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Wherenode$1$ = -8					; size = 4
__Right_size$1$ = -4					; size = 4
__Keyval$ = 8						; size = 4
??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 2059 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ebx, DWORD PTR [ecx]
	push	edi
	mov	DWORD PTR __Wherenode$1$[ebp], ebx

; 2060 : 		_Nodeptr _Pnode = _Root();

	mov	edi, DWORD PTR [ebx+4]

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [edi+13], 0
	jne	$LN140@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	esi

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Right_size$1$[ebp], edx
$LL2@Lbound:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN86@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN87@Lbound
$LN86@Lbound:
	mov	esi, ecx
$LN87@Lbound:
	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	ecx, DWORD PTR [eax+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN109@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN109@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	ebx, DWORD PTR [ecx]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	ebx, DWORD PTR __Right_size$1$[ebp]
	cmovb	edx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 517  : 		return (_Count == 0 ? 0

	test	edx, edx
	je	SHORT $LN114@Lbound
	sub	edx, 4
	jb	SHORT $LN136@Lbound
	npad	1
$LL137@Lbound:
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN135@Lbound
	add	eax, 4
	add	esi, 4
	sub	edx, 4
	jae	SHORT $LL137@Lbound
$LN136@Lbound:
	cmp	edx, -4					; fffffffcH
	je	SHORT $LN134@Lbound
$LN135@Lbound:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN138@Lbound
	cmp	edx, -3					; fffffffdH
	je	SHORT $LN134@Lbound
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN138@Lbound
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN134@Lbound
	mov	cl, BYTE PTR [eax+2]
	cmp	cl, BYTE PTR [esi+2]
	jne	SHORT $LN138@Lbound
	cmp	edx, -1
	je	SHORT $LN134@Lbound
	mov	al, BYTE PTR [eax+3]
	cmp	al, BYTE PTR [esi+3]
	je	SHORT $LN134@Lbound
$LN138@Lbound:
	sbb	eax, eax
	or	eax, 1
	jmp	SHORT $LN139@Lbound
$LN134@Lbound:
	xor	eax, eax
$LN139@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2098 : 		if (_Ans != 0)

	test	eax, eax
	je	SHORT $LN114@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2064 : 			if (_Compare(this->_Key(_Pnode), _Keyval))

	mov	edx, DWORD PTR __Right_size$1$[ebp]
	jns	SHORT $LN4@Lbound
$LN133@Lbound:

; 2065 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	edi, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR __Wherenode$1$[ebp]
$LN5@Lbound:

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [edi+13], 0
	mov	ecx, DWORD PTR __Keyval$[ebp]
	je	$LL2@Lbound
	pop	esi
$LN140@Lbound:
	pop	edi

; 2070 : 				}
; 2071 : 
; 2072 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, ebx
	pop	ebx

; 2073 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN114@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2101 : 		if (_Left_size < _Right_size)

	mov	edx, DWORD PTR __Right_size$1$[ebp]
	cmp	ebx, edx
	jb	SHORT $LN133@Lbound
$LN4@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2068 : 				_Wherenode = _Pnode;

	mov	ebx, edi

; 2069 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR __Wherenode$1$[ebp], ebx
	jmp	SHORT $LN5@Lbound
??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__Wherenode$1$ = -8					; size = 4
__Right_size$1$ = -4					; size = 4
__Keyval$ = 8						; size = 4
??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 2059 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ebx, DWORD PTR [ecx]
	push	edi
	mov	DWORD PTR __Wherenode$1$[ebp], ebx

; 2060 : 		_Nodeptr _Pnode = _Root();

	mov	edi, DWORD PTR [ebx+4]

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [edi+13], 0
	jne	$LN140@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR __Keyval$[ebp]
	push	esi

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR __Right_size$1$[ebp], edx
$LL2@Lbound:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	eax, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN86@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN87@Lbound
$LN86@Lbound:
	mov	esi, ecx
$LN87@Lbound:
	cmp	DWORD PTR [eax+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	ecx, DWORD PTR [eax+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN109@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN109@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	ebx, DWORD PTR [ecx]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	ebx, DWORD PTR __Right_size$1$[ebp]
	cmovb	edx, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 517  : 		return (_Count == 0 ? 0

	test	edx, edx
	je	SHORT $LN114@Lbound
	sub	edx, 4
	jb	SHORT $LN136@Lbound
	npad	1
$LL137@Lbound:
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR [esi]
	jne	SHORT $LN135@Lbound
	add	eax, 4
	add	esi, 4
	sub	edx, 4
	jae	SHORT $LL137@Lbound
$LN136@Lbound:
	cmp	edx, -4					; fffffffcH
	je	SHORT $LN134@Lbound
$LN135@Lbound:
	mov	cl, BYTE PTR [eax]
	cmp	cl, BYTE PTR [esi]
	jne	SHORT $LN138@Lbound
	cmp	edx, -3					; fffffffdH
	je	SHORT $LN134@Lbound
	mov	cl, BYTE PTR [eax+1]
	cmp	cl, BYTE PTR [esi+1]
	jne	SHORT $LN138@Lbound
	cmp	edx, -2					; fffffffeH
	je	SHORT $LN134@Lbound
	mov	cl, BYTE PTR [eax+2]
	cmp	cl, BYTE PTR [esi+2]
	jne	SHORT $LN138@Lbound
	cmp	edx, -1
	je	SHORT $LN134@Lbound
	mov	al, BYTE PTR [eax+3]
	cmp	al, BYTE PTR [esi+3]
	je	SHORT $LN134@Lbound
$LN138@Lbound:
	sbb	eax, eax
	or	eax, 1
	jmp	SHORT $LN139@Lbound
$LN134@Lbound:
	xor	eax, eax
$LN139@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2098 : 		if (_Ans != 0)

	test	eax, eax
	je	SHORT $LN114@Lbound
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2064 : 			if (_Compare(this->_Key(_Pnode), _Keyval))

	mov	edx, DWORD PTR __Right_size$1$[ebp]
	jns	SHORT $LN4@Lbound
$LN133@Lbound:

; 2065 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	edi, DWORD PTR [edi+8]
	mov	ebx, DWORD PTR __Wherenode$1$[ebp]
$LN5@Lbound:

; 2061 : 		_Nodeptr _Wherenode = this->_Myhead();	// end() if search fails
; 2062 : 
; 2063 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [edi+13], 0
	mov	ecx, DWORD PTR __Keyval$[ebp]
	je	$LL2@Lbound
	pop	esi
$LN140@Lbound:
	pop	edi

; 2070 : 				}
; 2071 : 
; 2072 : 		return (_Wherenode);	// return best remembered candidate

	mov	eax, ebx
	pop	ebx

; 2073 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN114@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2101 : 		if (_Left_size < _Right_size)

	mov	edx, DWORD PTR __Right_size$1$[ebp]
	cmp	ebx, edx
	jb	SHORT $LN133@Lbound
$LN4@Lbound:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2068 : 				_Wherenode = _Pnode;

	mov	ebx, edi

; 2069 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR __Wherenode$1$[ebp], ebx
	jmp	SHORT $LN5@Lbound
??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Ptr$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN20@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN20@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN112@destroy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
$LN112@destroy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 1004 : 		}

	pop	ebp
	ret	4
??$destroy@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGPAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@AAU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z
_TEXT	SEGMENT
tv444 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>, COMDAT
; _this$ = ecx

; 1988 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 1992 : 
; 1993 : 		while (!this->_Isnil(_Pnode))

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edi, DWORD PTR [ecx]

; 1990 : 		_Nodeptr _Lonode = this->_Myhead();	// end() if search fails
; 1991 : 		_Nodeptr _Hinode = this->_Myhead();	// end() if search fails

	mov	ecx, edi

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [edi+4]
	mov	DWORD PTR tv444[ebp], eax

; 1989 : 		_Nodeptr _Pnode = _Root();

	mov	eax, DWORD PTR [eax]

; 1992 : 
; 1993 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@Eqrange
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 239  : 		return (_Left < _Right);

	mov	esi, DWORD PTR [ebx]
	npad	2
$LL2@Eqrange:
	mov	edx, DWORD PTR [eax+16]
	cmp	edx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1994 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), this->_Key(_Pnode), _Keyval))

	jae	SHORT $LN6@Eqrange

; 1995 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]

; 1996 : 			else

	jmp	SHORT $LN7@Eqrange
$LN6@Eqrange:

; 1999 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN8@Eqrange
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 239  : 		return (_Left < _Right);

	cmp	esi, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1999 : 						&& _DEBUG_LT_PRED(this->_Getcomp(), _Keyval,

	cmovb	ecx, eax
$LN8@Eqrange:

; 2000 : 						this->_Key(_Pnode)))
; 2001 : 					_Hinode = _Pnode;	// _Pnode greater, remember it
; 2002 : 				_Lonode = _Pnode;

	mov	edi, eax

; 2003 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]
$LN7@Eqrange:

; 1992 : 
; 1993 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Eqrange
	pop	esi
$LN3@Eqrange:

; 2004 : 				}
; 2005 : 
; 2006 : 		_Pnode = this->_Isnil(_Hinode) ? _Root()

	cmp	BYTE PTR [ecx+13], 0
	mov	eax, ecx
	cmovne	eax, DWORD PTR tv444[ebp]
	mov	eax, DWORD PTR [eax]

; 2007 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2008 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN5@Eqrange
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 239  : 		return (_Left < _Right);

	mov	edx, DWORD PTR [ebx]
$LL4@Eqrange:
	cmp	edx, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2009 : 			if (_DEBUG_LT_PRED(this->_Getcomp(), _Keyval, this->_Key(_Pnode)))

	jae	SHORT $LN9@Eqrange

; 2010 : 				{	// _Pnode greater than _Keyval, remember it
; 2011 : 				_Hinode = _Pnode;

	mov	ecx, eax

; 2012 : 				_Pnode = this->_Left(_Pnode);	// descend left subtree

	mov	eax, DWORD PTR [eax]

; 2013 : 				}
; 2014 : 			else

	jmp	SHORT $LN10@Eqrange
$LN9@Eqrange:

; 2015 : 				_Pnode = this->_Right(_Pnode);	// descend right subtree

	mov	eax, DWORD PTR [eax+8]
$LN10@Eqrange:

; 2007 : 			: this->_Left(_Hinode);	// continue scan for upper bound
; 2008 : 		while (!this->_Isnil(_Pnode))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Eqrange
$LN5@Eqrange:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	DWORD PTR [eax+4], ecx
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2020 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>, COMDAT
; _this$ = ecx

; 2024 : 		{	// find leftmost node not less than _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2025 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Ans$[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Ans$[ebp+4]
	mov	DWORD PTR [eax+4], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2029 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> const >, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@YGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABU10@@Z PROC ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> const >, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@$$CBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@YGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABU10@@Z ENDP ; std::addressof<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> const >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 598  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 598  : 		}

	ret	4
??$?0U?$_Wrap_alloc@V?$allocator@D@std@@@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::_Wrap_alloc<std::allocator<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YG$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YG$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<char> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	ebp
	ret	4
??$move@AAU?$_Wrap_alloc@V?$allocator@D@std@@@std@@@std@@YG$$QAU?$_Wrap_alloc@V?$allocator@D@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<char> > &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YG$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YG$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z PROC ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	ebp
	ret	4
??$forward@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YG$$QAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAV10@@Z ENDP ; std::forward<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >, COMDAT
; _this$ = ecx

; 1202 : 		{	// assign [_First, _Last), input iterators

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN14@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN15@assign
$LN14@assign:
	mov	edx, ecx
$LN15@assign:

; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

	mov	eax, DWORD PTR [ecx+16]
	add	eax, edx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN48@assign

; 1203 : 		return (replace(begin(), end(), _First, _Last));

	push	DWORD PTR __Last$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1203 : 		return (replace(begin(), end(), _First, _Last));

	push	DWORD PTR __First$[ebp]
	push	eax
	push	edx
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

	pop	ebp
	ret	8
$LN48@assign:

; 1203 : 		return (replace(begin(), end(), _First, _Last));

	push	DWORD PTR __Last$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, ecx

; 1203 : 		return (replace(begin(), end(), _First, _Last));

	push	DWORD PTR __First$[ebp]
	push	eax
	push	edx
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace

; 1204 : 		}

	pop	ebp
	ret	8
??$assign@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign<std::_String_iterator<std::_String_val<std::_Simple_types<char> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 398  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 211  : 		return (_Ptr - _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[ebp]
	sub	eax, DWORD PTR [ecx]

; 399  : 		return (*(_Mybase *)this - _Right);
; 400  : 		}

	pop	ebp
	ret	4
??G?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ
_TEXT	SEGMENT
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 340  : 		return ((reference)**(_Mybase *)this);

	mov	eax, DWORD PTR [ecx]

; 341  : 		}

	ret	0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEAADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 322  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 323  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PADPBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?9V?$allocator@D@std@@V01@@std@@YG_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?9V?$allocator@D@std@@V01@@std@@YG_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z PROC ; std::operator!=<std::allocator<char>,std::allocator<char> >, COMDAT

; 1026 : 	return (!(_Left == _Right));

	xor	al, al

; 1027 : 	}

	ret	8
??$?9V?$allocator@D@std@@V01@@std@@YG_NABU?$_Wrap_alloc@V?$allocator@D@std@@@0@0@Z ENDP ; std::operator!=<std::allocator<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat, COMDAT
; _this$ = ecx

; 270  : 		}

	ret	4
?_Compat@?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==, COMDAT
; _this$ = ecx

; 220  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 221  : 		_Compat(_Right);
; 222  : 		return (_Ptr == _Right._Ptr);
; 223  : 		}

	pop	ebp
	ret	4
??8?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-, COMDAT
; _this$ = ecx

; 209  : 		{	// return difference of iterators

	push	ebp
	mov	ebp, esp

; 210  : 		_Compat(_Right);
; 211  : 		return (_Ptr - _Right._Ptr);

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR __Right$[ebp]
	sub	eax, DWORD PTR [ecx]

; 212  : 		}

	pop	ebp
	ret	4
??G?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEHABV01@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ
_TEXT	SEGMENT
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT
; _this$ = ecx

; 68   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 69   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 70   : 		const auto _Contptr = _Mycont ? _Mycont->_Myptr() : 0;
; 71   : 		if (_Mycont == 0
; 72   : 			|| _Ptr == nullptr_t{}
; 73   : 			|| _Unfancy(_Ptr) < _Contptr
; 74   : 			|| _Contptr + _Mycont->_Mysize <= _Unfancy(_Ptr))
; 75   : 			{	// report error
; 76   : 			_DEBUG_ERROR("string iterator not dereferencable");
; 77   : 			_SCL_SECURE_OUT_OF_RANGE;
; 78   : 			}
; 79   : 
; 80   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 81   : 		_SCL_SECURE_VALIDATE(_Ptr != nullptr_t{});
; 82   : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 83   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 84   : 		const auto _Contptr = _Mycont->_Myptr();
; 85   : 		_SCL_SECURE_VALIDATE_RANGE(_Contptr <= _Unfancy(_Ptr) && _Unfancy(_Ptr) < _Contptr + _Mycont->_Mysize);
; 86   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 87   : 
; 88   : 		_Analysis_assume_(_Ptr != nullptr_t{});
; 89   : 
; 90   : 		return (*_Ptr);

	mov	eax, DWORD PTR [ecx]

; 91   : 		}

	ret	0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QBEABDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
__Pstring$ = 12						; size = 4
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT
; _this$ = ecx

; 49   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [ecx], eax

; 50   : 		this->_Adopt(_Pstring);
; 51   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QAE@PBDPBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@ABQAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@ABQAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxDriver@gxRuntime@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@ABQAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@AAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@AAPAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxDriver@gxRuntime@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@AAPAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::construct<gxRuntime::GfxDriver *,gxRuntime::GfxDriver * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@PAUGfxDriver@gxRuntime@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAUGfxDriver@gxRuntime@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@@Z PROC ; std::_Unfancy<gxRuntime::GfxDriver *>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	4
??$_Unfancy@PAUGfxDriver@gxRuntime@@@std@@YGPAPAUGfxDriver@gxRuntime@@PAPAU12@@Z ENDP ; std::_Unfancy<gxRuntime::GfxDriver *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@QAUGfxDriver@gxRuntime@@@std@@YGPBQAUGfxDriver@gxRuntime@@ABQAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAUGfxDriver@gxRuntime@@@std@@YGPBQAUGfxDriver@gxRuntime@@ABQAU12@@Z PROC ; std::addressof<gxRuntime::GfxDriver * const>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@QAUGfxDriver@gxRuntime@@@std@@YGPBQAUGfxDriver@gxRuntime@@ABQAU12@@Z ENDP ; std::addressof<gxRuntime::GfxDriver * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@ABQAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@ABQAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxMode@gxRuntime@@ABQAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@ABQAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * const &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@AAPAU23@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@AAPAU23@@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR __Ptr$[ebp]
	test	ecx, ecx
	je	SHORT $LN13@construct
	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [ecx], eax
$LN13@construct:

; 995  : 		_Mytraits::construct(*this, _Ptr,
; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	ebp
	ret	8
??$construct@PAUGfxMode@gxRuntime@@AAPAU12@@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@AAPAU23@@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::construct<gxRuntime::GfxMode *,gxRuntime::GfxMode * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@PAUGfxMode@gxRuntime@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@PAUGfxMode@gxRuntime@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@@Z PROC ; std::_Unfancy<gxRuntime::GfxMode *>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	ebp
	ret	4
??$_Unfancy@PAUGfxMode@gxRuntime@@@std@@YGPAPAUGfxMode@gxRuntime@@PAPAU12@@Z ENDP ; std::_Unfancy<gxRuntime::GfxMode *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@QAUGfxMode@gxRuntime@@@std@@YGPBQAUGfxMode@gxRuntime@@ABQAU12@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@QAUGfxMode@gxRuntime@@@std@@YGPBQAUGfxMode@gxRuntime@@ABQAU12@@Z PROC ; std::addressof<gxRuntime::GfxMode * const>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	ebp
	ret	4
??$addressof@QAUGfxMode@gxRuntime@@@std@@YGPBQAUGfxMode@gxRuntime@@ABQAU12@@Z ENDP ; std::addressof<gxRuntime::GfxMode * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@SGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@ABU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@SGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@ABU32@@Z PROC ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> const *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 280  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 281  : 		}

	pop	ebp
	ret	4
?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@SGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@ABU32@@Z ENDP ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> const *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@SGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@ABU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@SGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@ABU32@@Z PROC ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> const *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp

; 280  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 281  : 		}

	pop	ebp
	ret	4
?pointer_to@?$pointer_traits@PBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@SGPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@ABU32@@Z ENDP ; std::pointer_traits<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> const *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
$T1 = 12						; size = 1
__Last$ = 12						; size = 4
??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0@Z PROC ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >, COMDAT

; 1125 : 	{	// return distance between iterators

	push	ebp
	mov	ebp, esp

; 1126 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Last$[ebp]
	push	DWORD PTR __First$[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >

; 1127 : 	}

	pop	ebp
	ret	8
??$distance@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0@Z ENDP ; std::distance<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@X@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@X@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::insert<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>,void>, COMDAT
; _this$ = ecx

; 193  : 		{	// insert _Val

	push	ebp
	mov	ebp, esp
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 193  : 		{	// insert _Val

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	call	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >

; 1077 : 		return (_Insert_nohint(false,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1077 : 		return (_Insert_nohint(false,

	mov	ecx, edi
	push	eax
	push	0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 194  : 		return (this->emplace(_STD forward<_Valty>(_Val)));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi

; 195  : 		}

	pop	ebp
	ret	8
??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@X@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::insert<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZX$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZX$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),void,0>, COMDAT
; _this$ = ecx

; 200  : 		{	// construct from moved compatible pair

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 200  : 		{	// construct from moved compatible pair

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax

; 201  : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZX$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN9@pair:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	ret	0
$LN101@pair:
	mov	BYTE PTR [esi], 0
	pop	esi
	ret	0
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@Z@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAP6GHPBXHPAXH@Z@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@Z@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAP6GHPBXHPAXH@Z@Z PROC ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,int (__stdcall*&)(void const *,int,void *,int)>, COMDAT

; 324  : 	{	// return pair composed from arguments

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, esi
	push	-1
	push	0
	push	DWORD PTR __Val1$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Val2$[ebp]

; 325  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 326  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 327  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

	mov	eax, esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], ecx
	pop	esi

; 328  : 		_STD forward<_Ty2>(_Val2)));
; 329  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@Z@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAP6GHPBXHPAXH@Z@Z ENDP ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,int (__stdcall*&)(void const *,int,void *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN13@scalar:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN105@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN106@scalar
$LN105@scalar:
	mov	eax, esi
$LN106@scalar:
	test	BYTE PTR ___flags$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	je	SHORT $LN112@scalar
	push	28					; 0000001cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN112@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN9@pair:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	ret	0
$LN101@pair:
	mov	BYTE PTR [esi], 0
	pop	esi
	ret	0
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator--

; 425  : 		--static_cast<_Mybase&>(*this);
; 426  : 		return (*this);

	mov	eax, esi
	pop	esi

; 427  : 		}

	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 385  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

	pop	ebp
	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

	pop	ebp
	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

	mov	eax, esi
	pop	esi

; 314  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 278  : 		{	// postincrement

	push	ebp
	mov	ebp, esp

; 279  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], edx

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator++

; 280  : 		++*this;
; 281  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 282  : 		}

	pop	ebp
	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

	mov	eax, esi
	pop	esi

; 275  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@XZ
_TEXT	SEGMENT
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator->, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 254  : 		return (pointer_traits<pointer>::pointer_to(**this));
; 255  : 		}

	ret	0
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));
; 250  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@X@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@X@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::insert<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>,void>, COMDAT
; _this$ = ecx

; 193  : 		{	// insert _Val

	push	ebp
	mov	ebp, esp
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	DWORD PTR __Val$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 193  : 		{	// insert _Val

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	call	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >

; 1077 : 		return (_Insert_nohint(false,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1077 : 		return (_Insert_nohint(false,

	mov	ecx, edi
	push	eax
	push	0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 194  : 		return (this->emplace(_STD forward<_Valty>(_Val)));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi

; 195  : 		}

	pop	ebp
	ret	8
??$insert@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@X@?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::insert<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>,void>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@X$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@X$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,void,0>, COMDAT
; _this$ = ecx

; 200  : 		{	// construct from moved compatible pair

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 200  : 		{	// construct from moved compatible pair

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 199  : 			second(_STD forward<_Other2>(_Right.second))

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+24], eax

; 201  : 		}

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	4
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@X$0A@@?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *><std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,void,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN9@pair:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	ret	0
$LN101@pair:
	mov	BYTE PTR [esi], 0
	pop	esi
	ret	0
??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
;	COMDAT ??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAUgxDll@@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Val1$ = 12						; size = 4
__Val2$ = 16						; size = 4
??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAUgxDll@@@Z PROC ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,gxDll * &>, COMDAT

; 324  : 	{	// return pair composed from arguments

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, esi
	push	-1
	push	0
	push	DWORD PTR __Val1$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Val2$[ebp]

; 325  : 	typedef pair<typename _Unrefwrap<_Ty1>::type,
; 326  : 		typename _Unrefwrap<_Ty2>::type> _Mypair;
; 327  : 	return (_Mypair(_STD forward<_Ty1>(_Val1),

	mov	eax, esi

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [esi+24], ecx
	pop	esi

; 328  : 		_STD forward<_Ty2>(_Val2)));
; 329  : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAUgxDll@@@Z ENDP ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,gxDll * &>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2479 : 	{	// test for string vs. NTCS equality

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN7@operator
	xor	esi, esi
	jmp	SHORT $LN8@operator
$LN7@operator:
	mov	esi, edx
	lea	ecx, DWORD PTR [esi+1]
$LL37@operator:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL37@operator
	sub	esi, ecx
$LN8@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR __Left$[ebp]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	edi, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN28@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN28@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2146 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [edi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, esi
	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	edx
	push	ecx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN38@operator

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN39@operator

; 2102 : 			return (-1);

	or	eax, -1
	test	eax, eax
	pop	edi
	sete	al
	pop	esi

; 2480 : 	return (_Left.compare(_Right) == 0);
; 2481 : 	}

	pop	ebp
	ret	8
$LN39@operator:

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
	test	eax, eax
$LN38@operator:
	pop	edi
	sete	al
	pop	esi

; 2480 : 	return (_Left.compare(_Right) == 0);
; 2481 : 	}

	pop	ebp
	ret	8
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_t$ = 12						; size = 24
?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z PROC ; toDir, COMDAT

; 1125 : static string toDir( string t ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR $T2[ebp], 0

; 1126 : 	if( t.size() && t[t.size()-1]!='\\' ) t+='\\';

	mov	ecx, DWORD PTR _t$[ebp+16]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	ecx, ecx
	je	SHORT $LN2@toDir
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _t$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR _t$[ebp]
	cmovae	eax, DWORD PTR _t$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1126 : 	if( t.size() && t[t.size()-1]!='\\' ) t+='\\';

	cmp	BYTE PTR [ecx+eax-1], 92		; 0000005cH
	je	SHORT $LN2@toDir
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1060 : 		return (append((size_type)1, _Ch));

	push	92					; 0000005cH
	push	1
	lea	ecx, DWORD PTR _t$[ebp]
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@toDir:

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	lea	eax, DWORD PTR _t$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _t$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN283@toDir
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
	push	DWORD PTR _t$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN283@toDir:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1127 : 	return t;

	mov	eax, esi

; 1128 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z$0:
	lea	ecx, DWORD PTR _t$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ENDP ; toDir
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@ABQAVgxTimer@@@Z
_TEXT	SEGMENT
$T1 = 8							; size = 1
___$ReturnUdt$ = 8					; size = 4
__Val$ = 12						; size = 4
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@ABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::insert<0,0>, COMDAT
; _this$ = ecx

; 1203 : 		{	// try to insert node with value _Val, favoring right side

	push	ebp
	mov	ebp, esp

; 1204 : 		return (_Insert_nohint(false,

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Val$[ebp]
	push	0
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_nohint<gxTimer * const &,std::_Nil>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1205 : 			_Val, _Nil()));
; 1206 : 		}

	pop	ebp
	ret	8
??$insert@$0A@$0A@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@ABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::insert<0,0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?enumDriver@@YGHPAU_GUID@@PAD1PAXPAUHMONITOR__@@@Z
_TEXT	SEGMENT
_dir3d$ = -8						; size = 4
_dd$ = -4						; size = 4
_d$ = 8							; size = 4
_guid$ = 8						; size = 4
_desc$ = 12						; size = 4
_name$ = 16						; size = 4
_context$ = 20						; size = 4
_hm$ = 24						; size = 4
?enumDriver@@YGHPAU_GUID@@PAD1PAXPAUHMONITOR__@@@Z PROC	; enumDriver, COMDAT

; 1009 : static BOOL WINAPI enumDriver( GUID FAR *guid,LPSTR desc,LPSTR name,LPVOID context,HMONITOR hm ){

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1010 : 	IDirectDraw7 *dd;
; 1011 : 	if( DirectDrawCreateEx( guid,(void**)&dd,IID_IDirectDraw7,0 )<0 ) return 0;

	lea	eax, DWORD PTR _dd$[ebp]
	push	edi
	mov	edi, DWORD PTR _guid$[ebp]
	push	0
	push	OFFSET _IID_IDirectDraw7
	push	eax
	push	edi
	call	_DirectDrawCreateEx@16
	test	eax, eax
	jns	SHORT $LN2@enumDriver
	xor	eax, eax
	pop	edi

; 1037 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN2@enumDriver:

; 1012 : 
; 1013 : 	if( !guid && !desktop_desc.ddpfPixelFormat.dwRGBBitCount ){

	test	edi, edi
	jne	SHORT $LN3@enumDriver
	cmp	DWORD PTR ?desktop_desc@@3U_DDSURFACEDESC2@@A+84, edi
	jne	SHORT $LN3@enumDriver

; 1014 : 		desktop_desc.dwSize=sizeof(desktop_desc);
; 1015 : 		dd->GetDisplayMode( &desktop_desc );

	mov	eax, DWORD PTR _dd$[ebp]
	mov	DWORD PTR ?desktop_desc@@3U_DDSURFACEDESC2@@A, 124 ; 0000007cH
	push	OFFSET ?desktop_desc@@3U_DDSURFACEDESC2@@A
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+48]
$LN3@enumDriver:

; 1018 : 	gxRuntime::GfxDriver *d=d_new gxRuntime::GfxDriver;

	push	esi
	push	276					; 00000114H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	add	esp, 4
	test	esi, esi
	je	SHORT $LN6@enumDriver
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi+28], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+32], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+36], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1018 : 	gxRuntime::GfxDriver *d=d_new gxRuntime::GfxDriver;

	jmp	SHORT $LN144@enumDriver
$LN6@enumDriver:
	xor	esi, esi
$LN144@enumDriver:
	mov	DWORD PTR _d$[ebp], esi

; 1020 : 	d->guid=guid ? d_new GUID( *guid ) : 0;

	test	edi, edi
	je	SHORT $LN10@enumDriver
	push	16					; 00000010H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	test	eax, eax
	je	SHORT $LN10@enumDriver
	movups	xmm0, XMMWORD PTR [edi]
	movups	XMMWORD PTR [eax], xmm0
	jmp	SHORT $LN11@enumDriver
$LN10@enumDriver:
	xor	eax, eax
$LN11@enumDriver:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR _desc$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1020 : 	d->guid=guid ? d_new GUID( *guid ) : 0;

	mov	DWORD PTR [esi], eax
	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN141@enumDriver
	xor	ecx, ecx
	jmp	SHORT $LN142@enumDriver
$LN141@enumDriver:
	mov	ecx, edx
	lea	edi, DWORD PTR [ecx+1]
	npad	2
$LL143@enumDriver:
	mov	al, BYTE PTR [ecx]
	inc	ecx
	test	al, al
	jne	SHORT $LL143@enumDriver
	sub	ecx, edi
$LN142@enumDriver:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	ecx
	push	edx
	lea	ecx, DWORD PTR [esi+4]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1024 : 	memset( &d->d3d_desc,0,sizeof(d->d3d_desc) );

	push	236					; 000000ecH
	lea	eax, DWORD PTR [esi+40]
	push	0
	push	eax
	call	_memset

; 1025 : 	IDirect3D7 *dir3d;
; 1026 : 	if( dd->QueryInterface( IID_IDirect3D7,(void**)&dir3d )>=0 ){

	mov	eax, DWORD PTR _dd$[ebp]
	lea	edx, DWORD PTR _dir3d$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	OFFSET _IID_IDirect3D7
	push	eax
	call	DWORD PTR [ecx]
	pop	ebx
	test	eax, eax
	js	SHORT $LN4@enumDriver

; 1027 : 		maxDevType=0;
; 1028 : 		dir3d->EnumDevices( enumDevice,d );

	mov	eax, DWORD PTR _dir3d$[ebp]
	push	esi
	push	OFFSET ?enumDevice@@YGJPAD0PAU_D3DDeviceDesc7@@PAX@Z ; enumDevice
	push	eax
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?maxDevType@@3HA, 0
	call	DWORD PTR [ecx+12]

; 1029 : 		dir3d->Release();

	mov	eax, DWORD PTR _dir3d$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
$LN4@enumDriver:

; 1030 : 	}
; 1031 : #endif
; 1032 : 	vector<gxRuntime::GfxDriver*> *drivers=(vector<gxRuntime::GfxDriver*>*)context;
; 1033 : 	drivers->push_back( d );

	mov	ecx, DWORD PTR _context$[ebp]
	lea	eax, DWORD PTR _d$[ebp]
	push	eax
	call	?push_back@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXABQAUGfxDriver@gxRuntime@@@Z ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::push_back

; 1034 : 	dd->EnumDisplayModes( 0,0,d,enumMode );

	mov	eax, DWORD PTR _dd$[ebp]
	push	OFFSET ?enumMode@@YGJPAU_DDSURFACEDESC2@@PAX@Z ; enumMode
	push	DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR [eax]
	push	0
	push	0
	push	eax
	call	DWORD PTR [ecx+32]

; 1035 : 	dd->Release();

	mov	eax, DWORD PTR _dd$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
	pop	esi

; 1036 : 	return 1;

	mov	eax, 1
	pop	edi

; 1037 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?enumDriver@@YGHPAU_GUID@@PAD1PAXPAUHMONITOR__@@@Z ENDP	; enumDriver
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?enumDevice@@YGJPAD0PAU_D3DDeviceDesc7@@PAX@Z
_TEXT	SEGMENT
_guid$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_desc$ = 8						; size = 4
_name$ = 12						; size = 4
_devDesc$ = 16						; size = 4
_context$ = 20						; size = 4
?enumDevice@@YGJPAD0PAU_D3DDeviceDesc7@@PAX@Z PROC	; enumDevice, COMDAT

; 994  : static HRESULT CALLBACK enumDevice( char *desc,char *name,D3DDEVICEDESC7 *devDesc,void *context ){

	push	ebp
	mov	ebp, esp
	sub	esp, 20					; 00000014H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx

; 996  : 	GUID guid=devDesc->deviceGUID;

	mov	ebx, DWORD PTR _devDesc$[ebp]
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	lea	ecx, DWORD PTR _guid$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _context$[ebp]
	mov	edx, OFFSET _IID_IDirect3DRGBDevice
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 996  : 	GUID guid=devDesc->deviceGUID;

	movups	xmm0, XMMWORD PTR [ebx+196]
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	esi, 12					; 0000000cH
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 996  : 	GUID guid=devDesc->deviceGUID;

	movups	XMMWORD PTR _guid$[ebp], xmm0
$LL24@enumDevice:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN23@enumDevice
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL24@enumDevice
	jmp	SHORT $LN30@enumDevice
$LN23@enumDevice:
	lea	ecx, DWORD PTR _guid$[ebp]
	mov	edx, OFFSET _IID_IDirect3DHALDevice
	mov	esi, 12					; 0000000cH
$LL26@enumDevice:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN4@enumDevice
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL26@enumDevice
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 998  : 	else if( guid==IID_IDirect3DHALDevice ) t=2;

	mov	eax, 2

; 999  : 	else if( guid==IID_IDirect3DTnLHalDevice ) t=3;

	jmp	SHORT $LN21@enumDevice
$LN4@enumDevice:
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	lea	ecx, DWORD PTR _guid$[ebp]
	mov	edx, OFFSET _IID_IDirect3DTnLHalDevice
	mov	esi, 12					; 0000000cH
$LL28@enumDevice:
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN30@enumDevice
	add	ecx, 4
	add	edx, 4
	sub	esi, 4
	jae	SHORT $LL28@enumDevice
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 999  : 	else if( guid==IID_IDirect3DTnLHalDevice ) t=3;

	mov	eax, 3
$LN21@enumDevice:

; 1000 : 	if( t>1 && t>maxDevType ){

	cmp	eax, DWORD PTR ?maxDevType@@3HA
	jle	SHORT $LN30@enumDevice

; 1001 : 		maxDevType=t;
; 1002 : 		gxRuntime::GfxDriver *d=(gxRuntime::GfxDriver*)context;
; 1003 : 		d->d3d_desc=*devDesc;

	add	edi, 40					; 00000028H
	mov	DWORD PTR ?maxDevType@@3HA, eax
	mov	ecx, 59					; 0000003bH
	mov	esi, ebx
	rep movsd
$LN30@enumDevice:

; 1004 : 	}
; 1005 : 	return D3DENUMRET_OK;
; 1006 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, 1
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?enumDevice@@YGJPAD0PAU_D3DDeviceDesc7@@PAX@Z ENDP	; enumDevice
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?enumMode@@YGJPAU_DDSURFACEDESC2@@PAX@Z
_TEXT	SEGMENT
_m$1 = 8						; size = 4
_desc$ = 8						; size = 4
_context$ = 12						; size = 4
?enumMode@@YGJPAU_DDSURFACEDESC2@@PAX@Z PROC		; enumMode, COMDAT

; 981  : static HRESULT WINAPI enumMode( DDSURFACEDESC2 *desc,void *context ){

	push	ebp
	mov	ebp, esp
	push	esi

; 982  : 	int dp=desc->ddpfPixelFormat.dwRGBBitCount;

	mov	esi, DWORD PTR _desc$[ebp]
	mov	eax, DWORD PTR [esi+84]

; 983  : 	if( dp==16 || dp==24 || dp==32 ){

	cmp	eax, 16					; 00000010H
	je	SHORT $LN3@enumMode
	cmp	eax, 24					; 00000018H
	je	SHORT $LN3@enumMode
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN6@enumMode
$LN3@enumMode:
	push	edi

; 984  : 		gxRuntime::GfxMode *m=d_new gxRuntime::GfxMode;

	push	124					; 0000007cH
	call	??2@YAPAXI@Z				; operator new

; 985  : 		m->desc=*desc;

	mov	edi, eax
	mov	DWORD PTR _m$1[ebp], eax
	mov	ecx, 31					; 0000001fH

; 986  : 		gxRuntime::GfxDriver *d=(gxRuntime::GfxDriver*)context;
; 987  : 		d->modes.push_back( m );

	lea	eax, DWORD PTR _m$1[ebp]
	rep movsd
	mov	ecx, DWORD PTR _context$[ebp]
	add	esp, 4
	push	eax
	lea	ecx, DWORD PTR [ecx+28]
	call	?push_back@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXABQAUGfxMode@gxRuntime@@@Z ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::push_back
	pop	edi
$LN6@enumMode:

; 988  : 	}
; 989  : 	return DDENUMRET_OK;

	mov	eax, 1
	pop	esi

; 990  : }

	pop	ebp
	ret	8
?enumMode@@YGJPAU_DDSURFACEDESC2@@PAX@Z ENDP		; enumMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?timerCallback@@YGXIIKKK@Z
_TEXT	SEGMENT
_id$ = 8						; size = 4
_msg$ = 12						; size = 4
_user$ = 16						; size = 4
_dw1$ = 20						; size = 4
_dw2$ = 24						; size = 4
?timerCallback@@YGXIIKKK@Z PROC				; timerCallback, COMDAT

; 718  : 	if( gfx_mode ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 0
	je	SHORT $LN3@timerCallb

; 719  : 		gxCanvas *f=runtime->graphics->getFrontCanvas();

	mov	ecx, DWORD PTR ?runtime@@3PAVgxRuntime@@A
	push	esi
	mov	ecx, DWORD PTR [ecx+16]
	call	?getFrontCanvas@gxGraphics@@QBEPAVgxCanvas@@XZ ; gxGraphics::getFrontCanvas
	mov	esi, eax

; 720  : 		if( f->getModify()!=mod_cnt ){

	mov	ecx, esi
	call	?getModify@gxCanvas@@QBEHXZ		; gxCanvas::getModify
	cmp	eax, DWORD PTR ?mod_cnt@@3HA
	je	SHORT $LN5@timerCallb

; 721  : 			mod_cnt=f->getModify();

	mov	ecx, esi
	call	?getModify@gxCanvas@@QBEHXZ		; gxCanvas::getModify
	mov	DWORD PTR ?mod_cnt@@3HA, eax

; 722  : 			InvalidateRect( runtime->hwnd,0,false );

	mov	eax, DWORD PTR ?runtime@@3PAVgxRuntime@@A
	push	0
	push	0
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__InvalidateRect@12
$LN5@timerCallb:
	pop	esi
$LN3@timerCallb:

; 723  : 		}
; 724  : 	}
; 725  : }

	ret	20					; 00000014H
?timerCallback@@YGXIIKKK@Z ENDP				; timerCallback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Left$ = 12						; size = 4
__Right$ = 16						; size = 4
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2417 : 	{	// return NTCS + string

	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR __Left$[ebp]
	push	esi
	mov	DWORD PTR $T1[ebp], 0
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN9@operator
	xor	eax, eax
	jmp	SHORT $LN10@operator
$LN9@operator:
	mov	eax, edx
	lea	esi, DWORD PTR [eax+1]
	npad	3
$LL143@operator:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL143@operator
	sub	eax, esi
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	mov	ecx, DWORD PTR __Right$[ebp]
	push	eax
	push	edx
	push	0
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	mov	ecx, esi
	push	eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 2418 : 	return (_STD move(_Right.insert(0, _Left)));

	mov	eax, esi
	pop	esi

; 2419 : 	}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

	pop	ebp
	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

	pop	ebp
	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

	mov	eax, esi
	pop	esi

; 314  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator++, COMDAT
; _this$ = ecx

; 278  : 		{	// postincrement

	push	ebp
	mov	ebp, esp

; 279  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], edx

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator++

; 280  : 		++*this;
; 281  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 282  : 		}

	pop	ebp
	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

	mov	eax, esi
	pop	esi

; 275  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBEABQAVgxTimer@@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBEABQAVgxTimer@@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));
; 250  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QBEABQAVgxTimer@@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@PAVgxTimer@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@PAVgxTimer@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@PAVgxTimer@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@PAVgxTimer@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@PAVgxTimer@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@PAVgxTimer@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAEPAXI@Z PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN13@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN13@scalar:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN105@scalar
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN106@scalar
$LN105@scalar:
	mov	eax, esi
$LN106@scalar:
	test	BYTE PTR ___flags$[ebp], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	je	SHORT $LN112@scalar
	push	28					; 0000001cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN112@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_G?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAEPAXI@Z ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ PROC ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN9@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN9@pair:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN101@pair
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	ret	0
$LN101@pair:
	mov	BYTE PTR [esi], 0
	pop	esi
	ret	0
??1?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ ENDP ; std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>::~pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator--, COMDAT
; _this$ = ecx

; 424  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator--

; 425  : 		--static_cast<_Mybase&>(*this);
; 426  : 		return (*this);

	mov	eax, esi
	pop	esi

; 427  : 		}

	ret	0
??F?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z PROC ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >, COMDAT
; _this$ = ecx

; 384  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 385  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z ENDP ; std::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::_Tree_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator!=, COMDAT
; _this$ = ecx

; 340  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	setne	al

; 341  : 		return (!(*this == _Right));
; 342  : 		}

	pop	ebp
	ret	4
??9?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator==, COMDAT
; _this$ = ecx

; 324  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [ecx]
	cmp	ecx, DWORD PTR [eax]
	sete	al

; 325  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 326  : 		if (this->_Getcont() != _Right._Getcont())
; 327  : 			{	// report error
; 328  : 			_DEBUG_ERROR("map/set iterators incompatible");
; 329  : 			_SCL_SECURE_INVALID_ARGUMENT;
; 330  : 			}
; 331  : 
; 332  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 333  : 		_SCL_SECURE_VALIDATE(this->_Getcont() == _Right._Getcont());
; 334  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 335  : 
; 336  : 		return (this->_Ptr == _Right._Ptr);
; 337  : 		}

	pop	ebp
	ret	4
??8?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator==
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator--, COMDAT
; _this$ = ecx

; 285  : 		{	// predecrement

	push	esi
	mov	esi, ecx

; 286  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 287  : 		if (this->_Getcont() == 0
; 288  : 			|| this->_Ptr == nullptr_t{})
; 289  : 			{	// report error
; 290  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 291  : 			_SCL_SECURE_OUT_OF_RANGE;
; 292  : 			}
; 293  : 
; 294  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 295  : 		--static_cast<_Mybase&>(*this);
; 296  : 		if (_Ptrsav == this->_Ptr)
; 297  : 			{	// report error
; 298  : 			_DEBUG_ERROR("map/set iterator not decrementable");
; 299  : 			_SCL_SECURE_OUT_OF_RANGE;
; 300  : 			}
; 301  : 
; 302  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 303  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 304  : 
; 305  : 		_Nodeptr _Ptrsav = this->_Ptr;
; 306  : 		--static_cast<_Mybase&>(*this);
; 307  : 		_SCL_SECURE_VALIDATE(_Ptrsav != this->_Ptr);
; 308  : 
; 309  :  #else /* _ITERATOR_DEBUG_LEVEL == 0 */
; 310  : 		--static_cast<_Mybase&>(*this);

	call	??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator--

; 311  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 312  : 
; 313  : 		return (*this);

	mov	eax, esi
	pop	esi

; 314  : 		}

	ret	0
??F?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator++, COMDAT
; _this$ = ecx

; 278  : 		{	// postincrement

	push	ebp
	mov	ebp, esp

; 279  : 		_Myiter _Tmp = *this;

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [esi], edx

; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator++

; 280  : 		++*this;
; 281  : 		return (_Tmp);

	mov	eax, esi
	pop	esi

; 282  : 		}

	pop	ebp
	ret	8
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE?AV01@H@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator++, COMDAT
; _this$ = ecx

; 258  : 		{	// preincrement

	push	esi
	mov	esi, ecx

; 259  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 260  : 		if (this->_Getcont() == 0
; 261  : 			|| this->_Ptr == nullptr_t{}
; 262  : 			|| _Mytree::_Isnil(this->_Ptr))
; 263  : 			{	// report error
; 264  : 			_DEBUG_ERROR("map/set iterator not incrementable");
; 265  : 			_SCL_SECURE_OUT_OF_RANGE;
; 266  : 			}
; 267  : 
; 268  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 269  : 		_SCL_SECURE_VALIDATE(this->_Getcont() != 0 && this->_Ptr != nullptr_t{});
; 270  : 		_SCL_SECURE_VALIDATE_RANGE(!_Mytree::_Isnil(this->_Ptr));
; 271  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 272  : 
; 273  : 		++static_cast<_Mybase&>(*this);

	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator++

; 274  : 		return (*this);

	mov	eax, esi
	pop	esi

; 275  : 		}

	ret	0
??E?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@XZ
_TEXT	SEGMENT
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator->, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 254  : 		return (pointer_traits<pointer>::pointer_to(**this));
; 255  : 		}

	ret	0
??C?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBEPBU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator->
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@XZ
_TEXT	SEGMENT
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator*, COMDAT
; _this$ = ecx

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR [ecx]
	add	eax, 16					; 00000010H

; 232  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 233  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 234  : 		if (_Mycont == 0
; 235  : 			|| this->_Ptr == nullptr_t{}
; 236  : 			|| this->_Ptr == _Mycont->_Myhead)
; 237  : 			{	// report error
; 238  : 			_DEBUG_ERROR("map/set iterator not dereferencable");
; 239  : 			_SCL_SECURE_OUT_OF_RANGE;
; 240  : 			}
; 241  : 
; 242  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 243  : 		_SCL_SECURE_VALIDATE(this->_Ptr != nullptr_t{});
; 244  : 		const auto _Mycont = static_cast<const _Mytree *>(this->_Getcont());
; 245  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 246  : 		_SCL_SECURE_VALIDATE_RANGE(this->_Ptr != _Mycont->_Myhead);
; 247  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 248  : 
; 249  : 		return (_Mytree::_Myval(this->_Ptr));
; 250  : 		}

	ret	0
??D?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QBEABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >, COMDAT
; _this$ = ecx

; 214  : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 215  : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 210  : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::_Mynode, COMDAT
; _this$ = ecx

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR [ecx]

; 124  : 		}

	ret	0
?_Mynode@?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::_Mynode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator--, COMDAT
; _this$ = ecx

; 84   : 		{	// predecrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 85   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN4@operator

; 86   : 			_Ptr = _Mytree::_Right(_Ptr);	// end() ==> rightmost

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edx], eax

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN4@operator:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax]

; 87   : 		else if (!_Mytree::_Isnil(_Mytree::_Left(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN40@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN23@operator
$LL22@operator:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL22@operator

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
$LN40@operator:

; 88   : 			_Ptr = _Mytree::_Max(
; 89   : 				_Mytree::_Left(_Ptr));	// ==> largest of left subtree
; 90   : 		else
; 91   : 			{	// climb looking for left subtree
; 92   : 			_Nodeptr _Pnode;
; 93   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 94   : 				&& _Ptr == _Mytree::_Left(_Pnode))

	mov	ecx, DWORD PTR [eax+4]
	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN3@operator
	npad	4
$LL2@operator:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [ecx]
	jne	SHORT $LN3@operator

; 95   : 				_Ptr = _Pnode;	// ==> parent while left subtree

	mov	DWORD PTR [edx], ecx
	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 96   : 			if (_Mytree::_Isnil(_Ptr))

	mov	eax, DWORD PTR [edx]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN47@operator
$LN23@operator:

; 97   : 				;	// begin() shouldn't be decremented, don't move
; 98   : 			else
; 99   : 				_Ptr = _Pnode;	// ==> parent if not head

	mov	DWORD PTR [edx], ecx
$LN47@operator:

; 100  : 			}
; 101  : 		return (*this);

	mov	eax, edx

; 102  : 		}

	ret	0
??F?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator--
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator++, COMDAT
; _this$ = ecx

; 59   : 		{	// preincrement

	mov	edx, ecx

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN41@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [eax+8]

; 61   : 			;	// end() shouldn't be incremented, don't move
; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN34@operator

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN19@operator
	npad	5
$LL18@operator:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL18@operator
$LN19@operator:

; 63   : 			_Ptr = _Mytree::_Min(

	mov	DWORD PTR [edx], ecx

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
$LN34@operator:

; 64   : 				_Mytree::_Right(_Ptr));	// ==> smallest of right subtree
; 65   : 		else
; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN3@operator
$LL2@operator:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax+8]
	jne	SHORT $LN3@operator

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@operator
$LN3@operator:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR [edx], eax
$LN41@operator:

; 72   : 			}
; 73   : 		return (*this);

	mov	eax, edx

; 74   : 		}

	ret	0
??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator++
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
__Plist$ = 12						; size = 4
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 44   : 		{	// construct with node pointer _Pnode

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR __Pnode$[ebp]
	mov	DWORD PTR [ecx], eax

; 45   : 		this->_Adopt(_Plist);
; 46   : 		}

	mov	eax, ecx
	pop	ebp
	ret	8
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@PBV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@1@@Z ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ PROC ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>, COMDAT
; _this$ = ecx

; 38   : 		: _Ptr()

	mov	DWORD PTR [ecx], 0

; 40   : 		}

	mov	eax, ecx
	ret	0
??0?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAE@XZ ENDP ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??__Ftimers@@YAXXZ
text$yd	SEGMENT
$T1 = -4						; size = 4
??__Ftimers@@YAXXZ PROC					; `dynamic atexit destructor for 'timers'', COMDAT
	push	ebp
	mov	ebp, esp
	push	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A

; 2168 : 		erase(begin(), end());

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	esi
	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase

; 726  : 		_Freeheadnode(_Myhead());

	mov	esi, DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A

; 839  : 		_Getal().destroy(

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	esi
	call	??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [esi+4]

; 841  : 		_Getal().destroy(

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	eax
	call	??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [esi+8]

; 843  : 		_Getal().destroy(

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	eax
	call	??$destroy@PAU?$_Tree_node@PAVgxTimer@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@PAVgxTimer@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::destroy<std::_Tree_node<gxTimer *,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	esi
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??__Ftimers@@YAXXZ ENDP					; `dynamic atexit destructor for 'timers''
text$yd	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ??__Etimers@@YAXXZ
text$di	SEGMENT
??__Etimers@@YAXXZ PROC					; `dynamic initializer for 'timers'', COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	call	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 721  : 		_Myhead() = _Buyheadnode();

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A

; 567  : 		: _Myhead(),

	mov	DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A, 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A+4, 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 59   : static set<gxTimer*> timers;

	push	OFFSET ??__Ftimers@@YAXXZ		; `dynamic atexit destructor for 'timers''
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 721  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A, eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 59   : static set<gxTimer*> timers;

	call	_atexit
	pop	ecx
	ret	0
??__Etimers@@YAXXZ ENDP					; `dynamic initializer for 'timers''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@QAE@XZ PROC ; std::set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >::~set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@QAE@XZ ENDP ; std::set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >::~set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\set
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\set
;	COMDAT ??0?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@QAE@XZ PROC ; std::set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >::set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >, COMDAT
; _this$ = ecx

; 69   : 		{	// construct empty set from defaults

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\set

; 70   : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@QAE@XZ ENDP ; std::set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >::set<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEABQAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEABQAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Key, COMDAT
; _this$ = ecx

; 2177 : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 2178 : 		return ((const key_type&)this->_Kfn(this->_Myval(_Pnode)));
; 2179 : 		}

	pop	ebp
	ret	4
?_Key@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEABQAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEABQAVgxTimer@@ABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEABQAVgxTimer@@ABQAV3@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2172 : 		{	// get key from value

	push	ebp
	mov	ebp, esp

; 2173 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 2174 : 		}

	pop	ebp
	ret	4
?_Kfn@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEABQAVgxTimer@@ABQAV3@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase

; 2169 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2111 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
$LN3@Rrotate:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Root, COMDAT
; _this$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2107 : 		return (this->_Parent(this->_Myhead()));
; 2108 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rmost, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2102 : 		return (this->_Right(this->_Myhead()));
; 2103 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2081 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
$LN3@Lrotate:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2078 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	edi, DWORD PTR __Rootnode$[ebp]
	mov	ebx, ecx
	mov	esi, edi

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN3@Erase
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, ebx
	call	?_Erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	edi
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	edi, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL4@Erase
$LN3@Erase:
	pop	edi
	pop	esi
	pop	ebx

; 2038 : 			this->_Getal().destroy(
; 2039 : 				_STD addressof(this->_Myval(_Rootnode)));
; 2040 : 
; 2041 : 			this->_Getal().deallocate(_Rootnode, 1);
; 2042 : 			}
; 2043 : 		}

	pop	ebp
	ret	4
?_Erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXU_Nil@2@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1649 : 		}

	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXU_Nil@2@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@2@ABQAVgxTimer@@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@2@ABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::equal_range, COMDAT
; _this$ = ecx

; 1594 : 		{	// find range equivalent to _Keyval in nonmutable tree

	push	ebp
	mov	ebp, esp

; 1595 : 		return (_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1596 : 		}

	pop	ebp
	ret	8
?equal_range@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@2@ABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?equal_range@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@2@ABQAVgxTimer@@@Z
_TEXT	SEGMENT
__Ans$1 = -8						; size = 8
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?equal_range@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@2@ABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::equal_range, COMDAT
; _this$ = ecx

; 1589 : 		{	// find range equivalent to _Keyval in mutable tree

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 2025 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$1[ebp]
	push	eax
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 170  : 		: first(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Ans$1[ebp]
	mov	DWORD PTR [eax], ecx

; 171  : 				second(_STD forward<_Other2>(_Val2))

	mov	ecx, DWORD PTR __Ans$1[ebp+4]
	mov	DWORD PTR [eax+4], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1591 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?equal_range@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@2@ABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::equal_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?count@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIABQAVgxTimer@@@Z
_TEXT	SEGMENT
__Ans$ = -8						; size = 8
$T1 = 8							; size = 1
__Keyval$ = 8						; size = 4
?count@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::count, COMDAT
; _this$ = ecx

; 1522 : 		{	// count all elements that match _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 8

; 1595 : 		return (_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]
	lea	eax, DWORD PTR __Ans$[ebp]
	push	eax
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 1126 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T1[ebp]
	push	DWORD PTR __Ans$[ebp+4]
	push	DWORD PTR __Ans$[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1525 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?count@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::count
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+4]

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	esi, ebx

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN23@clear
$LL24@clear:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [esi+8]
	mov	ecx, edi
	call	?_Erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Erase

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	esi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, esi
	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LL24@clear
$LN23@clear:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1473 : 		_Root() = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1474 : 		_Lmost() = this->_Myhead();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 1477 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEIABQAVgxTimer@@@Z
_TEXT	SEGMENT
__Ans$1 = -12						; size = 8
_this$1$ = -4						; size = 4
$T2 = 8							; size = 1
$T3 = 8							; size = 4
__Keyval$ = 8						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEIABQAVgxTimer@@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase, COMDAT
; _this$ = ecx

; 1459 : 		{	// erase and count all that match _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	ebx

; 2025 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	push	DWORD PTR __Keyval$[ebp]

; 1459 : 		{	// erase and count all that match _Keyval

	mov	eax, ecx

; 2025 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	lea	ecx, DWORD PTR __Ans$1[ebp]
	push	ecx
	mov	ecx, eax

; 1459 : 		{	// erase and count all that match _Keyval

	mov	DWORD PTR _this$1$[ebp], eax

; 2025 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 1126 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T2[ebp]
	push	DWORD PTR __Ans$1[ebp+4]
	push	DWORD PTR __Ans$1[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1462 : 		erase(_Where.first, _Where.second);

	push	DWORD PTR __Ans$1[ebp+4]
	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	ebx, eax
	push	DWORD PTR __Ans$1[ebp]
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase

; 1463 : 		return (_Num);

	mov	eax, ebx
	pop	ebx

; 1464 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEIABQAVgxTimer@@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	ecx

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]

; 1445 : 		if (_First == begin() && _Last == end())

	mov	edx, DWORD PTR __Last$[ebp]
	push	esi
	push	edi
	mov	edi, ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	esi, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR [esi]

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN168@erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	edx, esi

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN168@erase

; 1446 : 			{	// erase all
; 1447 : 			clear();

	call	?clear@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::clear

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]
	pop	edi
	pop	esi

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN168@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 279  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN127@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN170@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN180@erase
	npad	5
$LL138@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL138@erase

; 65   : 		else

	jmp	SHORT $LN180@erase
$LN170@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN180@erase
$LL122@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN180@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL122@erase
$LN180@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[ebp], edx
$LN127@erase:

; 1453 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T1[ebp]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]

; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx], eax

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

	mov	eax, ecx

; 1455 : 			}
; 1456 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@@Z
_TEXT	SEGMENT
tv1196 = -16						; size = 4
tv1197 = -12						; size = 4
tv1195 = -8						; size = 4
tv1191 = -8						; size = 4
tv1171 = -8						; size = 4
__Erasednode$1$ = -4					; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H

; 123  : 		return (_Ptr);

	mov	eax, DWORD PTR __Where$[ebp]
	push	ebx
	push	esi

; 1259 : 		{	// erase element at _Where

	mov	ebx, ecx

; 123  : 		return (_Ptr);

	mov	DWORD PTR __Erasednode$1$[ebp], eax
	push	edi

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[ebp]
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,std::_Iterator_base0>::operator++

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Erasednode$1$[ebp]
	mov	esi, DWORD PTR [ecx]

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1270 : 		++_Where;	// save successor iterator for return
; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [esi+13], 0
	je	SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ecx+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN689@erase
$LN5@erase:
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, esi

; 1281 : 		else

	jmp	SHORT $LN689@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[ebp]

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

	cmp	edx, ecx
	jne	$LN9@erase
$LN689@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ecx+4]
	jne	SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ecx
	jne	SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1297 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebx]

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	edx, esi
	jmp	SHORT $LN43@erase
$LN42@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	edx, edi

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
$LL165@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:
	mov	eax, DWORD PTR [ebx]
$LN43@erase:

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax], edx
$LN16@erase:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ebx]

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [eax+8], ecx
	jne	$LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	edx, esi
	mov	DWORD PTR [eax+8], edx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	$LN373@erase
$LN44@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	edx, edi

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
$LL217@erase:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:
	mov	eax, DWORD PTR [ebx]

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax+8], edx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [esi+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1320 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ebx]

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ecx
	jne	SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx+4]

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ecx
	jne	SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 50   : 	_Left = _STD move(_Right);

	mov	eax, DWORD PTR __Erasednode$1$[ebp]
	mov	cl, BYTE PTR [edx+12]
	mov	al, BYTE PTR [eax+12]
	mov	BYTE PTR [edx+12], al

; 51   : 	_Right = _STD move(_Tmp);

	mov	eax, DWORD PTR __Erasednode$1$[ebp]
	mov	BYTE PTR [eax+12], cl
	mov	ecx, eax
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ecx+12], 1
	jne	$LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	6
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	edx, esi
	mov	DWORD PTR tv1195[ebp], edx
	mov	DWORD PTR tv1197[ebp], esi
	mov	DWORD PTR tv1196[ebp], esi
	jne	$LN692@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, esi
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN693@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN692@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR tv1195[ebp]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN693@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [ebx]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1197[ebp]
	cmp	edx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1196[ebp]
$LN692@erase:
	mov	ecx, DWORD PTR __Erasednode$1$[ebp]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ebx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR __Where$[ebp]

; 1436 : 		if (0 < this->_Mysize())

	test	eax, eax
	je	SHORT $LN691@erase

; 1437 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ebx+4], eax
$LN691@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	DWORD PTR [eax], ecx

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,
; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, ebx
	call	?_Lrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, ebx
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Rrotate
	jmp	SHORT $LN692@erase
?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::max_size, COMDAT
; _this$ = ecx

; 1176 : 		return (this->_Getal().max_size());

	mov	eax, 214748364				; 0cccccccH

; 1177 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?size@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::size, COMDAT
; _this$ = ecx

; 1171 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+4]

; 1172 : 		}

	ret	0
?size@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::end, COMDAT
; _this$ = ecx

; 1120 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1122 : 		}

	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::begin, COMDAT
; _this$ = ecx

; 1110 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1112 : 		}

	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
??1?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::~_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1092 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::~_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVgxTimer@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVgxTimer@@@1@@Z PROC ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1005 : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVgxTimer@@@1@@Z ENDP ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PAVgxTimer@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PAVgxTimer@@@2@XZ PROC ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QBEABU?$less@PAVgxTimer@@@2@XZ ENDP ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@PAVgxTimer@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@PAVgxTimer@@@2@XZ PROC ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@PAVgxTimer@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@PAVgxTimer@@@2@XZ ENDP ; std::_Compressed_pair<std::less<gxTimer *>,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >,std::_Tree_val<std::_Tree_simple_types<gxTimer *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Min, COMDAT

; 614  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
	npad	2
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

	mov	eax, ecx

; 618  : 		}

	pop	ebp
	ret	4
?_Min@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Max, COMDAT

; 607  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
	npad	1
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	pop	ebp
	ret	4
?_Max@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Myval, COMDAT

; 602  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 604  : 		}

	pop	ebp
	ret	4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Right, COMDAT

; 597  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 599  : 		}

	pop	ebp
	ret	4
?_Right@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Parent, COMDAT

; 592  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 594  : 		}

	pop	ebp
	ret	4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Left, COMDAT

; 587  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 589  : 		}

	pop	ebp
	ret	4
?_Left@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Isnil, COMDAT

; 582  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 584  : 		}

	pop	ebp
	ret	4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Color, COMDAT

; 577  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 578  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 579  : 		}

	pop	ebp
	ret	4
?_Color@?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Tree_val<std::_Tree_simple_types<gxTimer *> >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 570  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<gxTimer *> >::_Tree_val<std::_Tree_simple_types<gxTimer *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??R?$less@PAVgxTimer@@@std@@QBE_NABQAVgxTimer@@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@PAVgxTimer@@@std@@QBE_NABQAVgxTimer@@0@Z PROC	; std::less<gxTimer *>::operator(), COMDAT
; _this$ = ecx

; 238  : 		{	// apply operator< to operands

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	ecx, DWORD PTR [eax]
	setb	al

; 239  : 		return (_Left < _Right);
; 240  : 		}

	pop	ebp
	ret	8
??R?$less@PAVgxTimer@@@std@@QBE_NABQAVgxTimer@@0@Z ENDP	; std::less<gxTimer *>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABIXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Mysize, COMDAT
; _this$ = ecx

; 945  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 946  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABIXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 941  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABQAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABQAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABQAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 911  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABU?$less@PAVgxTimer@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABU?$less@PAVgxTimer@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 906  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QBEABU?$less@PAVgxTimer@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAU?$less@PAVgxTimer@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAU?$less@PAVgxTimer@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 901  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEAAU?$less@PAVgxTimer@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Freenode0, COMDAT
; _this$ = ecx

; 868  : 		{	// free non-value node using current allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 876  : 		}

	pop	ebp
	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	20					; 00000014H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 849  : 		{	// allocate a non-value node

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edx, edx
	je	SHORT $LN189@Buynode0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], eax
	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN167@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN167@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 864  : 		return (_Pnode);

	mov	eax, edx
	pop	esi

; 865  : 		}

	ret	0
$LN189@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN191@Buynode0:
$LN188@Buynode0:
	int	3
?_Buynode0@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Freeheadnode, COMDAT
; _this$ = ecx

; 838  : 		{	// free head node using current allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 846  : 		}

	pop	ebp
	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	je	__invalid_parameter_noinfo_noreturn
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], eax
	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 832  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::~_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 727  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::~_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

	push	esi
	mov	esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 722  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVgxTimer@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
??0?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVgxTimer@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

	push	esi
	mov	esi, ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 705  : 		_Construct();
; 706  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE@ABU?$less@PAVgxTimer@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Min, COMDAT

; 697  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
	npad	2
$LL4@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 699  : 		}

	pop	ebp
	ret	4
?_Min@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Max, COMDAT

; 692  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
	npad	1
$LL4@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 694  : 		}

	pop	ebp
	ret	4
?_Max@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Myval, COMDAT

; 687  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 689  : 		}

	pop	ebp
	ret	4
?_Myval@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAVgxTimer@@PAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Right, COMDAT

; 682  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 684  : 		}

	pop	ebp
	ret	4
?_Right@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Parent, COMDAT

; 677  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 679  : 		}

	pop	ebp
	ret	4
?_Parent@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Left, COMDAT

; 672  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, DWORD PTR __Pnode$[ebp]

; 674  : 		}

	pop	ebp
	ret	4
?_Left@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAAPAU?$_Tree_node@PAVgxTimer@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Isnil, COMDAT

; 667  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 669  : 		}

	pop	ebp
	ret	4
?_Isnil@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Color, COMDAT

; 662  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 578  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 664  : 		}

	pop	ebp
	ret	4
?_Color@?$_Tree_comp_alloc@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@SGAADPAU?$_Tree_node@PAVgxTimer@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 214748364				; 0cccccccH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z ; std::allocator<std::_Tree_node<gxTimer *,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<gxTimer *,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 214748364				; 0cccccccH

; 870  : 		}

	ret	4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<gxTimer *,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 214748364				; 0cccccccH

; 750  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 214748364				; 0cccccccH
	ja	SHORT $LN14@allocate

; 57   : 	const size_t _User_size = _Count * _Sz;

	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	jbe	SHORT $LN16@allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	jmp	SHORT $LN18@allocate
$LN14@allocate:

; 56   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
	int	3
?allocate@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	20					; 00000014H
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAEXPAU?$_Tree_node@PAVgxTimer@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<gxTimer *,void *> >::allocator<std::_Tree_node<gxTimer *,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@PAVgxTimer@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<gxTimer *,void *> >::allocator<std::_Tree_node<gxTimer *,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\set
;	COMDAT ?_Kfn@?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@SGABQAVgxTimer@@ABQAV3@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@SGABQAVgxTimer@@ABQAV3@@Z PROC ; std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0>::_Kfn, COMDAT

; 33   : 		{	// extract key from element value

	push	ebp
	mov	ebp, esp

; 34   : 		return (_Val);

	mov	eax, DWORD PTR __Val$[ebp]

; 35   : 		}

	pop	ebp
	ret	4
?_Kfn@?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@SGABQAVgxTimer@@ABQAV3@@Z ENDP ; std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0>::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?windowProc@@YGJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_hwnd$ = 8						; size = 4
_msg$ = 12						; size = 4
_wparam$ = 16						; size = 4
_lparam$ = 20						; size = 4
?windowProc@@YGJPAUHWND__@@IIJ@Z PROC			; windowProc, COMDAT

; 468  : static LRESULT CALLBACK windowProc( HWND hwnd,UINT msg,WPARAM wparam,LPARAM lparam ){

	push	ebp
	mov	ebp, esp

; 469  : 	if( runtime ) return runtime->windowProc( hwnd,msg,wparam,lparam );

	mov	ecx, DWORD PTR ?runtime@@3PAVgxRuntime@@A
	test	ecx, ecx
	je	SHORT $LN2@windowProc

; 471  : }

	pop	ebp

; 469  : 	if( runtime ) return runtime->windowProc( hwnd,msg,wparam,lparam );

	jmp	?windowProc@gxRuntime@@QAEJPAUHWND__@@IIJ@Z ; gxRuntime::windowProc
$LN2@windowProc:

; 471  : }

	pop	ebp

; 470  : 	return DefWindowProc( hwnd,msg,wparam,lparam );

	jmp	DWORD PTR __imp__DefWindowProcA@16
?windowProc@@YGJPAUHWND__@@IIJ@Z ENDP			; windowProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??__Flibs@@YAXXZ
text$yd	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??__Flibs@@YAXXZ PROC					; `dynamic atexit destructor for 'libs'', COMDAT
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??__Flibs@@YAXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2168 : 		erase(begin(), end());

	mov	eax, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	push	eax

; 1090 : 		{	// destroy tree

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2168 : 		erase(begin(), end());

	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase

; 726  : 		_Freeheadnode(_Myhead());

	mov	esi, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A

; 839  : 		_Getal().destroy(

	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	push	esi
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	eax, DWORD PTR [esi+4]

; 841  : 		_Getal().destroy(

	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	push	eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	eax, DWORD PTR [esi+8]

; 843  : 		_Getal().destroy(

	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	push	eax
	call	??$destroy@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::destroy<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	esi
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
text$yd	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??__Flibs@@YAXXZ$1:
	call	___std_terminate
	ret	0
__ehhandler$??__Flibs@@YAXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??__Flibs@@YAXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??__Flibs@@YAXXZ ENDP					; `dynamic atexit destructor for 'libs''
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ??__Elibs@@YAXXZ
text$di	SEGMENT
??__Elibs@@YAXXZ PROC					; `dynamic initializer for 'libs'', COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	call	??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 721  : 		_Myhead() = _Buyheadnode();

	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A

; 567  : 		: _Myhead(),

	mov	DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A, 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A+4, 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 37   : static map<string,gxDll*> libs;

	push	OFFSET ??__Flibs@@YAXXZ			; `dynamic atexit destructor for 'libs''
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 721  : 		_Myhead() = _Buyheadnode();

	mov	DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A, eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 37   : static map<string,gxDll*> libs;

	call	_atexit
	pop	ecx
	ret	0
??__Elibs@@YAXXZ ENDP					; `dynamic initializer for 'libs''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax

; 1090 : 		{	// destroy tree

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2168 : 		erase(begin(), end());

	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >, COMDAT
; _this$ = ecx

; 100  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 101  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Key, COMDAT
; _this$ = ecx

; 2177 : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2179 : 		}

	pop	ebp
	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2172 : 		{	// get key from value

	push	ebp
	mov	ebp, esp

; 2173 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 2174 : 		}

	pop	ebp
	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase

; 2169 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2111 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
$LN3@Rrotate:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Root, COMDAT
; _this$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2107 : 		return (this->_Parent(this->_Myhead()));
; 2108 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2102 : 		return (this->_Right(this->_Myhead()));
; 2103 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2081 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
$LN3@Lrotate:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2078 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Compare, COMDAT
; _this$ = ecx

; 2046 : 		{	// compare key_type to key_type, with debug checks

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN36@Compare
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN36@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	edx, DWORD PTR __Left$[ebp]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	edi, DWORD PTR [edx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN59@Compare
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN59@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	esi, DWORD PTR [esi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, esi

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [edi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	ecx
	push	edx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN66@Compare

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN68@Compare

; 2102 : 			return (-1);

	or	eax, -1
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2048 : 		}

	pop	ebp
	ret	8
$LN68@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN66@Compare:
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2048 : 		}

	pop	ebp
	ret	8
?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR _this$1$[ebp], eax
	mov	edi, ebx

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN207@Erase
	push	esi
	npad	9
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [edi+8]
	mov	ecx, eax
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR [ebx+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [ebx+16]

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	edi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN133@Erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN128@Erase

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN210@Erase

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN210@Erase

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN210@Erase

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN210@Erase

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN128@Erase:

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN133@Erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN156@Erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN156@Erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, edi
	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN208@Erase
	mov	eax, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LL4@Erase
$LN208@Erase:
	pop	esi
$LN207@Erase:
	pop	edi
	pop	ebx

; 2043 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN210@Erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	__invalid_parameter_noinfo_noreturn
$LN211@Erase:
$LN209@Erase:
	int	3
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1640 : 		{	// node exists, destroy it

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	edi, DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN38@Destroy_if
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN38@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN130@Destroy_if
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN130@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1645 : 		}

	pop	ebp
	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1537 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebp
	mov	ebp, esp

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	DWORD PTR __Keyval$[ebp]
	call	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	eax, ecx

; 1539 : 		}

	pop	ebp
	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv532 = -8						; size = 4
__Where$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
tv531 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::find, COMDAT
; _this$ = ecx

; 1480 : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	esi
	push	edi
	push	ebx

; 1480 : 		{	// find an element in mutable sequence that matches _Keyval

	mov	edi, ecx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	call	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 43   : 		: _Ptr(_Pnode)

	mov	edi, DWORD PTR [edi]
	mov	esi, eax
	mov	DWORD PTR __Where$1$[ebp], esi

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi

; 1482 : 		return (_Where == end()

	je	SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+36], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	lea	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv532[ebp], edx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN103@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN103@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR tv531[ebp], eax

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN126@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN126@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	esi, DWORD PTR tv531[ebp]

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edx, DWORD PTR [edx]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, edx
	cmp	DWORD PTR [esi], edx
	mov	edx, esi
	cmovb	eax, DWORD PTR [edx]

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	ecx
	push	ebx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare

; 2097 : 
; 2098 : 		if (_Ans != 0)

	mov	esi, DWORD PTR __Where$1$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN168@find

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	mov	ecx, DWORD PTR tv531[ebp]
	mov	edx, DWORD PTR tv532[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LN167@find
$LN3@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1482 : 		return (_Where == end()

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebx

; 1483 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1484 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1485 : 					? end() : _Where);
; 1486 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN168@find:

; 1482 : 		return (_Where == end()

	js	SHORT $LN3@find
$LN167@find:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 1483 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1484 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1485 : 					? end() : _Where);
; 1486 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Erase

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi]

; 1473 : 		_Root() = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1474 : 		_Lmost() = this->_Myhead();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [esi]

; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [esi+4], 0

; 1477 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR [edx]

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN299@erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	DWORD PTR __Last$[ebp], edx

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN299@erase

; 1472 : 		_Erase(_Root());

	push	DWORD PTR [edx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Erase

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1473 : 		_Root() = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1474 : 		_Lmost() = this->_Myhead();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN299@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR __Last$[ebp]

; 1446 : 			{	// erase all
; 1447 : 			clear();
; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 279  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN256@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN301@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN252@erase
$LL267@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL267@erase

; 65   : 		else

	jmp	SHORT $LN252@erase
$LN301@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN252@erase
$LL251@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN252@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL251@erase
$LN252@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[ebp], edx
$LN256@erase:

; 1453 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]

; 1446 : 			{	// erase all
; 1447 : 			clear();
; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

	mov	eax, ecx

; 1455 : 			}
; 1456 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z$16:
	call	___std_terminate
	ret	0
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1412 = -16						; size = 4
tv1411 = -12						; size = 4
tv1413 = -8						; size = 4
tv1406 = -8						; size = 4
tv1383 = -8						; size = 4
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 123  : 		return (_Ptr);

	mov	ebx, DWORD PTR __Where$[ebp]
	push	esi

; 1259 : 		{	// erase element at _Where

	mov	DWORD PTR _this$1$[ebp], ecx

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[ebp]
	push	edi
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,std::_Iterator_base0>::operator++

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [ebx]

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1270 : 		++_Where;	// save successor iterator for return
; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN809@erase
$LN5@erase:
	mov	eax, DWORD PTR [ebx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, ecx

; 1281 : 		else

	jmp	SHORT $LN809@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[ebp]

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

	cmp	edx, ebx
	jne	$LN9@erase
$LN809@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [edx]

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1297 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx]

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	ecx, esi
	jmp	SHORT $LN43@erase
$LN42@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, edi

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
	npad	1
$LL165@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:
	mov	eax, DWORD PTR [edx]
$LN43@erase:

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax], ecx
$LN16@erase:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx]

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [eax+8], ebx
	jne	$LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	ecx, esi
	mov	DWORD PTR [eax+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	$LN373@erase
$LN44@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, edi

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
$LL217@erase:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:
	mov	eax, DWORD PTR [edx]

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [ecx+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ebx+8]
	jne	SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1320 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebx+4]

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 49   : 	_Ty _Tmp = _STD move(_Left);

	mov	cl, BYTE PTR [edx+12]

; 50   : 	_Left = _STD move(_Right);

	mov	al, BYTE PTR [ebx+12]
	mov	BYTE PTR [edx+12], al
	mov	edx, DWORD PTR _this$1$[ebp]

; 51   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ebx+12], cl
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ebx+12], 1
	jne	$LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [edx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	9
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	DWORD PTR tv1411[ebp], esi
	mov	DWORD PTR tv1413[ebp], esi
	mov	DWORD PTR tv1412[ebp], esi
	jne	$LN3@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, edx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _this$1$[ebp]
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN812@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, edx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN3@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, edx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _this$1$[ebp]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN812@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1411[ebp]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1413[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1412[ebp]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [ebx+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN633@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN633@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN725@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN725@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ecx+4]
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN811@erase

; 1437 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ecx+4], eax
$LN811@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,
; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, edx
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Rrotate
	jmp	$LN3@erase
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1176 : 		return (this->_Getal().max_size());

	mov	eax, 97612893				; 05d1745dH

; 1177 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::end, COMDAT
; _this$ = ecx

; 1120 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1122 : 		}

	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::begin, COMDAT
; _this$ = ecx

; 1110 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1112 : 		}

	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1092 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1005 : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Min, COMDAT

; 614  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
	npad	2
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

	mov	eax, ecx

; 618  : 		}

	pop	ebp
	ret	4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Max, COMDAT

; 607  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
	npad	1
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	pop	ebp
	ret	4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Myval, COMDAT

; 602  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 604  : 		}

	pop	ebp
	ret	4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Right, COMDAT

; 597  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 599  : 		}

	pop	ebp
	ret	4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Parent, COMDAT

; 592  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 594  : 		}

	pop	ebp
	ret	4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Left, COMDAT

; 587  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 589  : 		}

	pop	ebp
	ret	4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Isnil, COMDAT

; 582  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 584  : 		}

	pop	ebp
	ret	4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Color, COMDAT

; 577  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 578  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 579  : 		}

	pop	ebp
	ret	4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 570  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 941  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 911  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 906  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 901  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Freenode0, COMDAT
; _this$ = ecx

; 868  : 		{	// free non-value node using current allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 876  : 		}

	pop	ebp
	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	44					; 0000002cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 849  : 		{	// allocate a non-value node

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edx, edx
	je	SHORT $LN189@Buynode0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], eax
	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN167@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN167@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 864  : 		return (_Pnode);

	mov	eax, edx
	pop	esi

; 865  : 		}

	ret	0
$LN189@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN191@Buynode0:
$LN188@Buynode0:
	int	3
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Freeheadnode, COMDAT
; _this$ = ecx

; 838  : 		{	// free head node using current allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 846  : 		}

	pop	ebp
	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	je	__invalid_parameter_noinfo_noreturn
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], eax
	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 832  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 727  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

	push	esi
	mov	esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 722  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

	push	esi
	mov	esi, ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 705  : 		_Construct();
; 706  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Min, COMDAT

; 697  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
	npad	2
$LL4@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 699  : 		}

	pop	ebp
	ret	4
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Max, COMDAT

; 692  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
	npad	1
$LL4@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 694  : 		}

	pop	ebp
	ret	4
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Myval, COMDAT

; 687  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 689  : 		}

	pop	ebp
	ret	4
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Right, COMDAT

; 682  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 684  : 		}

	pop	ebp
	ret	4
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Parent, COMDAT

; 677  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 679  : 		}

	pop	ebp
	ret	4
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Left, COMDAT

; 672  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, DWORD PTR __Pnode$[ebp]

; 674  : 		}

	pop	ebp
	ret	4
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Isnil, COMDAT

; 667  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 669  : 		}

	pop	ebp
	ret	4
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Color, COMDAT

; 662  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 578  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 664  : 		}

	pop	ebp
	ret	4
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 97612893				; 05d1745dH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 97612893				; 05d1745dH

; 870  : 		}

	ret	4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 97612893				; 05d1745dH

; 750  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 97612893				; 05d1745dH
	ja	SHORT $LN14@allocate

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	eax, eax, 44

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	jbe	SHORT $LN16@allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	jmp	SHORT $LN18@allocate
$LN14@allocate:

; 56   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
	int	3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0gxDll@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
_this$ = -4						; size = 4
??0gxDll@@QAE@XZ PROC					; gxDll::gxDll, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	push	edi
	mov	edi, ecx
	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR _this$[ebp], edi

; 721  : 		_Myhead() = _Buyheadnode();

	mov	ecx, esi
	mov	DWORD PTR _this$[ebp], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	mov	eax, edi
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0gxDll@@QAE@XZ ENDP					; gxDll::gxDll
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax

; 1090 : 		{	// destroy tree

	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 2168 : 		erase(begin(), end());

	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::~map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
;	COMDAT ??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ PROC ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >, COMDAT
; _this$ = ecx

; 100  : 		{	// construct empty map from defaults

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 101  : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@@std@@QAE@XZ ENDP ; std::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::map<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Key, COMDAT
; _this$ = ecx

; 2177 : 		{	// return reference to key in node

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2179 : 		}

	pop	ebp
	ret	4
?_Key@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Key
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Kfn, COMDAT
; _this$ = ecx

; 2172 : 		{	// get key from value

	push	ebp
	mov	ebp, esp

; 2173 : 		return (_Traits::_Kfn(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 2174 : 		}

	pop	ebp
	ret	4
?_Kfn@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@ABU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Kfn
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Tidy, COMDAT
; _this$ = ecx

; 2167 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	push	ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [ecx]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase

; 2169 : 		}

	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rrotate, COMDAT
; _this$ = ecx

; 2111 : 		{	// promote left node to root of subtree

	push	ebp
	mov	ebp, esp

; 2112 : 		_Nodeptr _Pnode = this->_Left(_Wherenode);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi
	mov	esi, DWORD PTR [edx]

; 2113 : 		this->_Left(_Wherenode) = this->_Right(_Pnode);

	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [edx], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 2114 : 
; 2115 : 		if (!this->_Isnil(this->_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Rrotate

; 2116 : 			this->_Parent(this->_Right(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Rrotate:

; 2117 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2118 : 
; 2119 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Rrotate

; 2120 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
$LN3@Rrotate:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx+4]

; 2121 : 		else if (_Wherenode == this->_Right(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax+8]
	jne	SHORT $LN5@Rrotate

; 2122 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
$LN5@Rrotate:

; 2123 : 		else
; 2124 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2125 : 
; 2126 : 		this->_Right(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi+8], edx

; 2127 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2128 : 		}

	pop	ebp
	ret	4
?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Root, COMDAT
; _this$ = ecx

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]
	add	eax, 4

; 2107 : 		return (this->_Parent(this->_Myhead()));
; 2108 : 		}

	ret	0
?_Root@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Root
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rmost, COMDAT
; _this$ = ecx

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [ecx]
	add	eax, 8

; 2102 : 		return (this->_Right(this->_Myhead()));
; 2103 : 		}

	ret	0
?_Rmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Wherenode$ = 8					; size = 4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lrotate, COMDAT
; _this$ = ecx

; 2081 : 		{	// promote right node to root of subtree

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	edx, DWORD PTR __Wherenode$[ebp]
	push	esi

; 2082 : 		_Nodeptr _Pnode = this->_Right(_Wherenode);

	mov	esi, DWORD PTR [edx+8]

; 2083 : 		this->_Right(_Wherenode) = this->_Left(_Pnode);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edx+8], eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 2084 : 
; 2085 : 		if (!this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN2@Lrotate

; 2086 : 			this->_Parent(this->_Left(_Pnode)) = _Wherenode;

	mov	DWORD PTR [eax+4], edx
$LN2@Lrotate:

; 2087 : 		this->_Parent(_Pnode) = this->_Parent(_Wherenode);

	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [esi+4], eax

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [ecx]

; 2088 : 
; 2089 : 		if (_Wherenode == _Root())

	cmp	edx, DWORD PTR [eax+4]
	jne	SHORT $LN3@Lrotate

; 2090 : 			_Root() = _Pnode;

	mov	DWORD PTR [eax+4], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
$LN3@Lrotate:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx+4]

; 2091 : 		else if (_Wherenode == this->_Left(this->_Parent(_Wherenode)))

	cmp	edx, DWORD PTR [eax]
	jne	SHORT $LN5@Lrotate

; 2092 : 			this->_Left(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
$LN5@Lrotate:

; 2093 : 		else
; 2094 : 			this->_Right(this->_Parent(_Wherenode)) = _Pnode;

	mov	DWORD PTR [eax+8], esi

; 2095 : 
; 2096 : 		this->_Left(_Pnode) = _Wherenode;

	mov	DWORD PTR [esi], edx

; 2097 : 		this->_Parent(_Wherenode) = _Pnode;

	mov	DWORD PTR [edx+4], esi
	pop	esi

; 2098 : 		}

	pop	ebp
	ret	4
?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lrotate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lmost, COMDAT
; _this$ = ecx

; 2077 : 		return (this->_Left(this->_Myhead()));

	mov	eax, DWORD PTR [ecx]

; 2078 : 		}

	ret	0
?_Lmost@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lmost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Compare, COMDAT
; _this$ = ecx

; 2046 : 		{	// compare key_type to key_type, with debug checks

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN36@Compare
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN36@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	edx, DWORD PTR __Left$[ebp]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	edi, DWORD PTR [edx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN59@Compare
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN59@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	esi, DWORD PTR [esi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, esi

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [edi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	ecx
	push	edx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN66@Compare

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN68@Compare

; 2102 : 			return (-1);

	or	eax, -1
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2048 : 		}

	pop	ebp
	ret	8
$LN68@Compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN66@Compare:
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2048 : 		}

	pop	ebp
	ret	8
?_Compare@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Rootnode$ = 8						; size = 4
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Erase, COMDAT
; _this$ = ecx

; 2032 : 		{	// free entire subtree, recursively

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2033 : 		for (_Nodeptr _Pnode = _Rootnode;

	mov	ebx, DWORD PTR __Rootnode$[ebp]
	mov	eax, ecx
	push	edi
	mov	DWORD PTR _this$1$[ebp], eax
	mov	edi, ebx

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	cmp	BYTE PTR [ebx+13], 0
	jne	SHORT $LN207@Erase
	push	esi
	npad	9
$LL4@Erase:

; 2035 : 			{	// free subtrees, then node
; 2036 : 			_Erase(this->_Right(_Pnode));

	push	DWORD PTR [edi+8]
	mov	ecx, eax
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR [ebx+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [ebx+16]

; 2037 : 			_Pnode = this->_Left(_Pnode);

	mov	edi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN133@Erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN128@Erase

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	al, 31					; 0000001fH
	jne	SHORT $LN210@Erase

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN210@Erase

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN210@Erase

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	ja	SHORT $LN210@Erase

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, ecx
$LN128@Erase:

; 132  : 	::operator delete(_Ptr);

	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN133@Erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN156@Erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN156@Erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2034 : 			!this->_Isnil(_Pnode); _Rootnode = _Pnode)

	mov	ebx, edi
	cmp	BYTE PTR [edi+13], 0
	jne	SHORT $LN208@Erase
	mov	eax, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LL4@Erase
$LN208@Erase:
	pop	esi
$LN207@Erase:
	pop	edi
	pop	ebx

; 2043 : 		}

	mov	esp, ebp
	pop	ebp
	ret	4
$LN210@Erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	__invalid_parameter_noinfo_noreturn
$LN211@Erase:
$LN209@Erase:
	int	3
?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Newnode$ = 8						; size = 4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Destroy_if_not_nil, COMDAT
; _this$ = ecx

; 1640 : 		{	// node exists, destroy it

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	edi, DWORD PTR __Newnode$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [edi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN38@Destroy_if
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN38@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN130@Destroy_if
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN130@Destroy_if:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1645 : 		}

	pop	ebp
	ret	4
?_Destroy_if_not_nil@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Destroy_if_not_nil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Keyval$ = 12						; size = 4
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::lower_bound, COMDAT
; _this$ = ecx

; 1537 : 		{	// find leftmost node not less than _Keyval in mutable tree

	push	ebp
	mov	ebp, esp

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	push	DWORD PTR __Keyval$[ebp]
	call	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	eax, ecx

; 1539 : 		}

	pop	ebp
	ret	8
?lower_bound@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::lower_bound
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
tv532 = -8						; size = 4
__Where$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
tv531 = 12						; size = 4
__Keyval$ = 12						; size = 4
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::find, COMDAT
; _this$ = ecx

; 1480 : 		{	// find an element in mutable sequence that matches _Keyval

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	mov	ebx, DWORD PTR __Keyval$[ebp]
	push	esi
	push	edi
	push	ebx

; 1480 : 		{	// find an element in mutable sequence that matches _Keyval

	mov	edi, ecx

; 1538 : 		return (iterator(_Lbound(_Keyval), &this->_Get_data()));

	call	??$_Lbound@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IBEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lbound<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >

; 43   : 		: _Ptr(_Pnode)

	mov	edi, DWORD PTR [edi]
	mov	esi, eax
	mov	DWORD PTR __Where$1$[ebp], esi

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, edi

; 1482 : 		return (_Where == end()

	je	SHORT $LN3@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+36], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\map

; 62   : 		return (_Val.first);

	lea	ecx, DWORD PTR [esi+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	lea	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR tv532[ebp], edx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN103@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN103@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR tv531[ebp], eax

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN126@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN126@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	esi, DWORD PTR tv531[ebp]

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edx, DWORD PTR [edx]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, edx
	cmp	DWORD PTR [esi], edx
	mov	edx, esi
	cmovb	eax, DWORD PTR [edx]

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	ecx
	push	ebx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare

; 2097 : 
; 2098 : 		if (_Ans != 0)

	mov	esi, DWORD PTR __Where$1$[ebp]
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN168@find

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	mov	ecx, DWORD PTR tv531[ebp]
	mov	edx, DWORD PTR tv532[ebp]
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jae	SHORT $LN167@find
$LN3@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1482 : 		return (_Where == end()

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi
	pop	ebx

; 1483 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1484 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1485 : 					? end() : _Where);
; 1486 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN168@find:

; 1482 : 		return (_Where == end()

	js	SHORT $LN3@find
$LN167@find:
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi
	pop	ebx

; 1483 : 			|| _DEBUG_LT_PRED(this->_Getcomp(),
; 1484 : 				_Keyval, this->_Key(_Where._Mynode()))
; 1485 : 					? end() : _Where);
; 1486 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::clear, COMDAT
; _this$ = ecx

; 1467 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1468 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1469 : 		this->_Orphan_ptr(nullptr_t{});
; 1470 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1471 : 
; 1472 : 		_Erase(_Root());

	mov	eax, DWORD PTR [esi]
	push	DWORD PTR [eax+4]
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Erase

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [esi]

; 1473 : 		_Root() = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1474 : 		_Lmost() = this->_Myhead();

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [esi]

; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [esi+4], 0

; 1477 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::clear
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 4
__Last$ = 16						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1444 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	edx, DWORD PTR [edi]

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR [edx]

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN299@erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	DWORD PTR __Last$[ebp], edx

; 1445 : 		if (_First == begin() && _Last == end())

	jne	SHORT $LN299@erase

; 1472 : 		_Erase(_Root());

	push	DWORD PTR [edx+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Erase

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR [edi]

; 1473 : 		_Root() = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1474 : 		_Lmost() = this->_Myhead();

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax], eax

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edi]

; 1475 : 		_Rmost() = this->_Myhead();

	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR [edi+4], 0

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edi]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1455 : 			}
; 1456 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN299@erase:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	eax, DWORD PTR __Last$[ebp]

; 1446 : 			{	// erase all
; 1447 : 			clear();
; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	je	SHORT $LN3@erase
$LL2@erase:

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [eax+13], 0

; 279  : 		_Myiter _Tmp = *this;

	mov	ecx, eax

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	jne	SHORT $LN256@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	edx, DWORD PTR [eax+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN301@erase

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN252@erase
$LL267@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	edx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL267@erase

; 65   : 		else

	jmp	SHORT $LN252@erase
$LN301@erase:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	edx, DWORD PTR [eax+4]
	cmp	BYTE PTR [edx+13], 0
	jne	SHORT $LN252@erase
$LL251@erase:
	cmp	eax, DWORD PTR [edx+8]
	jne	SHORT $LN252@erase

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	eax, edx
	mov	DWORD PTR __First$[ebp], eax
	mov	edx, DWORD PTR [edx+4]
	cmp	BYTE PTR [edx+13], 0
	je	SHORT $LL251@erase
$LN252@erase:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	DWORD PTR __First$[ebp], edx
$LN256@erase:

; 1453 : 				erase(_First++);

	push	ecx
	lea	eax, DWORD PTR $T2[ebp]
	mov	ecx, edi
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]

; 1446 : 			{	// erase all
; 1447 : 			clear();
; 1448 : 			return (begin());
; 1449 : 			}
; 1450 : 		else
; 1451 : 			{	// partial erase, one at a time
; 1452 : 			while (_First != _Last)

	jne	SHORT $LL2@erase
$LN3@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax

; 1454 : 			return (iterator(_First._Ptr, &this->_Get_data()));

	mov	eax, ecx

; 1455 : 			}
; 1456 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z$16:
	call	___std_terminate
	ret	0
__ehhandler$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
tv1412 = -16						; size = 4
tv1411 = -12						; size = 4
tv1413 = -8						; size = 4
tv1406 = -8						; size = 4
tv1383 = -8						; size = 4
_this$1$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 4
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase, COMDAT
; _this$ = ecx

; 1259 : 		{	// erase element at _Where

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx

; 123  : 		return (_Ptr);

	mov	ebx, DWORD PTR __Where$[ebp]
	push	esi

; 1259 : 		{	// erase element at _Where

	mov	DWORD PTR _this$1$[ebp], ecx

; 273  : 		++static_cast<_Mybase&>(*this);

	lea	ecx, DWORD PTR __Where$[ebp]
	push	edi
	call	??E?$_Tree_unchecked_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@U_Iterator_base0@2@@std@@QAEAAV01@XZ ; std::_Tree_unchecked_const_iterator<std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,std::_Iterator_base0>::operator++

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR [ebx]

; 1260 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1261 : 		if (_Where._Getcont() != &this->_Get_data()
; 1262 : 			|| this->_Isnil(_Where._Mynode()))
; 1263 : 			_DEBUG_ERROR("map/set erase iterator outside range");
; 1264 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1265 : 		++_Where;	// save successor iterator for return
; 1266 : 		_Orphan_ptr(_Erasednode);
; 1267 : 
; 1268 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1269 : 		_Nodeptr _Erasednode = _Where._Mynode();	// node to erase
; 1270 : 		++_Where;	// save successor iterator for return
; 1271 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1272 : 
; 1273 : 		_Nodeptr _Fixnode;	// the node to recolor as needed
; 1274 : 		_Nodeptr _Fixnodeparent;	// parent of _Fixnode (which may be nil)
; 1275 : 		_Nodeptr _Pnode = _Erasednode;
; 1276 : 
; 1277 : 		if (this->_Isnil(this->_Left(_Pnode)))

	cmp	BYTE PTR [ecx+13], 0
	je	SHORT $LN5@erase

; 1278 : 			_Fixnode = this->_Right(_Pnode);	// stitch up right subtree

	mov	edi, DWORD PTR [ebx+8]

; 1279 : 		else if (this->_Isnil(this->_Right(_Pnode)))

	jmp	SHORT $LN809@erase
$LN5@erase:
	mov	eax, DWORD PTR [ebx+8]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LN7@erase

; 1280 : 			_Fixnode = this->_Left(_Pnode);	// stitch up left subtree

	mov	edi, ecx

; 1281 : 		else

	jmp	SHORT $LN809@erase
$LN7@erase:

; 123  : 		return (_Ptr);

	mov	edx, DWORD PTR __Where$[ebp]

; 1282 : 			{	// two subtrees, must lift successor node to replace erased
; 1283 : 			_Pnode = _Where._Mynode();	// _Pnode is successor node
; 1284 : 			_Fixnode = this->_Right(_Pnode);	// _Fixnode is only subtree

	mov	edi, DWORD PTR [edx+8]

; 1285 : 			}
; 1286 : 
; 1287 : 		if (_Pnode == _Erasednode)

	cmp	edx, ebx
	jne	$LN9@erase
$LN809@erase:

; 1288 : 			{	// at most one subtree, relink it
; 1289 : 			_Fixnodeparent = this->_Parent(_Erasednode);
; 1290 : 			if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [ebx+4]
	jne	SHORT $LN11@erase

; 1291 : 				this->_Parent(_Fixnode) = _Fixnodeparent;	// link up

	mov	DWORD PTR [edi+4], esi
$LN11@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [edx]

; 1292 : 
; 1293 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN12@erase

; 1294 : 				_Root() = _Fixnode;	// link down from root

	mov	DWORD PTR [eax+4], edi

; 1295 : 			else if (this->_Left(_Fixnodeparent) == _Erasednode)

	jmp	SHORT $LN15@erase
$LN12@erase:
	cmp	DWORD PTR [esi], ebx
	jne	SHORT $LN14@erase

; 1296 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link down to left

	mov	DWORD PTR [esi], edi

; 1297 : 			else

	jmp	SHORT $LN15@erase
$LN14@erase:

; 1298 : 				this->_Right(_Fixnodeparent) =

	mov	DWORD PTR [esi+8], edi
$LN15@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [edx]

; 1299 : 					_Fixnode;	// link down to right
; 1300 : 
; 1301 : 			if (_Lmost() == _Erasednode)

	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN16@erase

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN42@erase
	mov	ecx, esi
	jmp	SHORT $LN43@erase
$LN42@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi]

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, edi

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN166@erase
	npad	1
$LL165@erase:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL165@erase
$LN166@erase:
	mov	eax, DWORD PTR [edx]
$LN43@erase:

; 1302 : 				_Lmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax], ecx
$LN16@erase:

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR [edx]

; 1303 : 					? _Fixnodeparent	// smallest is parent of erased node
; 1304 : 					: this->_Min(_Fixnode);	// smallest in relinked subtree
; 1305 : 
; 1306 : 			if (_Rmost() == _Erasednode)

	cmp	DWORD PTR [eax+8], ebx
	jne	$LN373@erase

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	cmp	BYTE PTR [edi+13], 0
	je	SHORT $LN44@erase
	mov	ecx, esi
	mov	DWORD PTR [eax+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	$LN373@erase
$LN44@erase:

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [edi+8]

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, edi

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN218@erase
$LL217@erase:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL217@erase
$LN218@erase:
	mov	eax, DWORD PTR [edx]

; 1307 : 				_Rmost() = this->_Isnil(_Fixnode)

	mov	DWORD PTR [eax+8], ecx

; 1308 : 					? _Fixnodeparent	// largest is parent of erased node
; 1309 : 					: this->_Max(_Fixnode);	// largest in relinked subtree
; 1310 : 			}
; 1311 : 		else

	jmp	SHORT $LN373@erase
$LN9@erase:

; 1312 : 			{	// erased has two subtrees, _Pnode is successor to erased
; 1313 : 			this->_Parent(this->_Left(_Erasednode)) =

	mov	DWORD PTR [ecx+4], edx

; 1314 : 				_Pnode;	// link left up
; 1315 : 			this->_Left(_Pnode) =

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edx], eax

; 1316 : 				this->_Left(_Erasednode);	// link successor down
; 1317 : 
; 1318 : 			if (_Pnode == this->_Right(_Erasednode))

	cmp	edx, DWORD PTR [ebx+8]
	jne	SHORT $LN18@erase

; 1319 : 				_Fixnodeparent = _Pnode;	// successor is next to erased

	mov	esi, edx

; 1320 : 			else

	jmp	SHORT $LN19@erase
$LN18@erase:

; 1321 : 				{	// successor further down, link in place of erased
; 1322 : 				_Fixnodeparent =
; 1323 : 					this->_Parent(_Pnode);	// parent is successor's
; 1324 : 				if (!this->_Isnil(_Fixnode))

	cmp	BYTE PTR [edi+13], 0
	mov	esi, DWORD PTR [edx+4]
	jne	SHORT $LN20@erase

; 1325 : 					this->_Parent(_Fixnode) = _Fixnodeparent;	// link fix up

	mov	DWORD PTR [edi+4], esi
$LN20@erase:

; 1326 : 				this->_Left(_Fixnodeparent) = _Fixnode;	// link fix down

	mov	DWORD PTR [esi], edi

; 1327 : 				this->_Right(_Pnode) =

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [edx+8], eax

; 1328 : 					this->_Right(_Erasednode);	// link next down
; 1329 : 				this->_Parent(this->_Right(_Erasednode)) =

	mov	eax, DWORD PTR [ebx+8]
	mov	DWORD PTR [eax+4], edx
$LN19@erase:

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]

; 1330 : 					_Pnode;	// right up
; 1331 : 				}
; 1332 : 
; 1333 : 			if (_Root() == _Erasednode)

	cmp	DWORD PTR [eax+4], ebx
	jne	SHORT $LN21@erase

; 1334 : 				_Root() = _Pnode;	// link down from root

	mov	DWORD PTR [eax+4], edx

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	jmp	SHORT $LN24@erase
$LN21@erase:

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ebx+4]

; 1335 : 			else if (this->_Left(this->_Parent(_Erasednode)) == _Erasednode)

	cmp	DWORD PTR [eax], ebx
	jne	SHORT $LN23@erase

; 1336 : 				this->_Left(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax], edx

; 1337 : 					_Pnode;	// link down to left
; 1338 : 			else

	jmp	SHORT $LN24@erase
$LN23@erase:

; 1339 : 				this->_Right(this->_Parent(_Erasednode)) =

	mov	DWORD PTR [eax+8], edx
$LN24@erase:

; 1340 : 					_Pnode;	// link down to right
; 1341 : 
; 1342 : 			this->_Parent(_Pnode) =

	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [edx+4], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\utility

; 49   : 	_Ty _Tmp = _STD move(_Left);

	mov	cl, BYTE PTR [edx+12]

; 50   : 	_Left = _STD move(_Right);

	mov	al, BYTE PTR [ebx+12]
	mov	BYTE PTR [edx+12], al
	mov	edx, DWORD PTR _this$1$[ebp]

; 51   : 	_Right = _STD move(_Tmp);

	mov	BYTE PTR [ebx+12], cl
$LN373@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1348 : 		if (this->_Color(_Erasednode) == this->_Black)

	cmp	BYTE PTR [ebx+12], 1
	jne	$LN25@erase

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [edx]
	cmp	edi, DWORD PTR [eax+4]
	je	$LN3@erase
	npad	9
$LL4@erase:
	cmp	BYTE PTR [edi+12], 1
	mov	DWORD PTR tv1411[ebp], esi
	mov	DWORD PTR tv1413[ebp], esi
	mov	DWORD PTR tv1412[ebp], esi
	jne	$LN3@erase

; 1353 : 				if (_Fixnode == this->_Left(_Fixnodeparent))

	mov	ecx, DWORD PTR [esi]
	cmp	edi, ecx
	jne	SHORT $LN26@erase

; 1354 : 					{	// fixup left subtree
; 1355 : 					_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]

; 1356 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN28@erase

; 1357 : 						{	// rotate red up from right subtree
; 1358 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1359 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1360 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, edx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lrotate

; 1361 : 						_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
	mov	edx, DWORD PTR _this$1$[ebp]
$LN28@erase:

; 1362 : 						}
; 1363 : 
; 1364 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	$LN2@erase

; 1365 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1366 : 					else if (this->_Color(this->_Left(_Pnode)) == this->_Black
; 1367 : 						&& this->_Color(this->_Right(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN31@erase
	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	je	SHORT $LN812@erase
$LN31@erase:

; 1368 : 						{	// redden right subtree with black children
; 1369 : 						this->_Color(_Pnode) = this->_Red;
; 1370 : 						_Fixnode = _Fixnodeparent;
; 1371 : 						}
; 1372 : 					else
; 1373 : 						{	// must rearrange right subtree
; 1374 : 						if (this->_Color(this->_Right(_Pnode))
; 1375 : 							== this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN33@erase

; 1376 : 							{	// rotate red up from left sub-subtree
; 1377 : 							this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1378 : 							this->_Color(_Pnode) = this->_Red;
; 1379 : 							_Rrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, edx
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rrotate

; 1380 : 							_Pnode = this->_Right(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi+8]
$LN33@erase:

; 1381 : 							}
; 1382 : 
; 1383 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1384 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1385 : 						this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1386 : 						_Lrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lrotate

; 1387 : 						break;	// tree now recolored/rebalanced

	jmp	SHORT $LN3@erase
$LN26@erase:

; 1388 : 						}
; 1389 : 					}
; 1390 : 				else
; 1391 : 					{	// fixup right subtree
; 1392 : 					_Pnode = this->_Left(_Fixnodeparent);
; 1393 : 					if (this->_Color(_Pnode) == this->_Red)

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN34@erase

; 1394 : 						{	// rotate red up from left subtree
; 1395 : 						this->_Color(_Pnode) = this->_Black;

	mov	BYTE PTR [ecx+12], 1

; 1396 : 						this->_Color(_Fixnodeparent) = this->_Red;
; 1397 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, edx
	push	esi
	mov	BYTE PTR [esi+12], 0
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rrotate

; 1398 : 						_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _this$1$[ebp]
$LN34@erase:

; 1399 : 						}
; 1400 : 
; 1401 : 					if (this->_Isnil(_Pnode))

	cmp	BYTE PTR [ecx+13], 0
	jne	SHORT $LN2@erase

; 1402 : 						_Fixnode = _Fixnodeparent;	// shouldn't happen
; 1403 : 					else if (this->_Color(this->_Right(_Pnode)) ==
; 1404 : 						this->_Black
; 1405 : 						&& this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx+8]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN37@erase
$LN812@erase:

; 1406 : 						{	// redden left subtree with black children
; 1407 : 						this->_Color(_Pnode) = this->_Red;

	mov	BYTE PTR [ecx+12], 0
$LN2@erase:

; 1349 : 			{	// erasing black link, must recolor/rebalance tree
; 1350 : 			for (; _Fixnode != _Root()
; 1351 : 				&& this->_Color(_Fixnode) == this->_Black;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR tv1411[ebp]

; 1352 : 				_Fixnodeparent = this->_Parent(_Fixnode))

	mov	esi, DWORD PTR [esi+4]
	mov	edi, DWORD PTR tv1413[ebp]
	cmp	ecx, DWORD PTR [eax+4]
	jne	$LL4@erase
	mov	edi, DWORD PTR tv1412[ebp]
$LN3@erase:

; 1424 : 						break;	// tree now recolored/rebalanced
; 1425 : 						}
; 1426 : 					}
; 1427 : 
; 1428 : 			this->_Color(_Fixnode) = this->_Black;	// stopping node is black

	mov	BYTE PTR [edi+12], 1
$LN25@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [ebx+36]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 603  : 		return ((reference)_Pnode->_Myval);

	lea	esi, DWORD PTR [ebx+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN633@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN633@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN725@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN725@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	push	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	ecx, DWORD PTR _this$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1436 : 		if (0 < this->_Mysize())

	mov	eax, DWORD PTR [ecx+4]
	pop	edi
	pop	esi
	pop	ebx
	test	eax, eax
	je	SHORT $LN811@erase

; 1437 : 			--this->_Mysize();

	dec	eax
	mov	DWORD PTR [ecx+4], eax
$LN811@erase:

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR __Where$[ebp]
	mov	DWORD PTR [eax], ecx

; 1438 : 
; 1439 : 		return (iterator(_Where._Ptr,
; 1440 : 			&this->_Get_data()));	// return successor iterator
; 1441 : 		}

	mov	esp, ebp
	pop	ebp
	ret	8
$LN37@erase:

; 1408 : 						_Fixnode = _Fixnodeparent;
; 1409 : 						}
; 1410 : 					else
; 1411 : 						{	// must rearrange left subtree
; 1412 : 						if (this->_Color(this->_Left(_Pnode)) == this->_Black)

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+12], 1
	jne	SHORT $LN39@erase

; 1413 : 							{	// rotate red up from right sub-subtree
; 1414 : 							this->_Color(this->_Right(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx+8]

; 1415 : 							this->_Color(_Pnode) = this->_Red;
; 1416 : 							_Lrotate(_Pnode);

	push	ecx
	mov	BYTE PTR [eax+12], 1
	mov	BYTE PTR [ecx+12], 0
	mov	ecx, edx
	call	?_Lrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Lrotate

; 1417 : 							_Pnode = this->_Left(_Fixnodeparent);

	mov	ecx, DWORD PTR [esi]
$LN39@erase:

; 1418 : 							}
; 1419 : 
; 1420 : 						this->_Color(_Pnode) = this->_Color(_Fixnodeparent);

	mov	al, BYTE PTR [esi+12]
	mov	BYTE PTR [ecx+12], al

; 1421 : 						this->_Color(_Fixnodeparent) = this->_Black;

	mov	BYTE PTR [esi+12], 1

; 1422 : 						this->_Color(this->_Left(_Pnode)) = this->_Black;

	mov	eax, DWORD PTR [ecx]

; 1423 : 						_Rrotate(_Fixnodeparent);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	mov	BYTE PTR [eax+12], 1
	call	?_Rrotate@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Rrotate
	jmp	$LN3@erase
?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::max_size, COMDAT
; _this$ = ecx

; 1176 : 		return (this->_Getal().max_size());

	mov	eax, 97612893				; 05d1745dH

; 1177 : 		}

	ret	0
?max_size@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEIXZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::end, COMDAT
; _this$ = ecx

; 1120 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], ecx

; 1121 : 		return (iterator(this->_Myhead(), &this->_Get_data()));
; 1122 : 		}

	pop	ebp
	ret	4
?end@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::begin, COMDAT
; _this$ = ecx

; 1110 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR [ecx]

; 43   : 		: _Ptr(_Pnode)

	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1111 : 		return (iterator(_Lmost(), &this->_Get_data()));
; 1112 : 		}

	pop	ebp
	ret	4
?begin@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1090 : 		{	// destroy tree

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [esi]

; 2168 : 		erase(begin(), end());

	push	eax
	push	DWORD PTR [eax]
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@0@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1092 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::~_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
__Parg$ = 8						; size = 4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >, COMDAT
; _this$ = ecx

; 1004 : 		{	// construct empty tree from comparator

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 1005 : 		}

	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAV?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@V?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@2@$00@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >,std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Min, COMDAT

; 614  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Min
	npad	2
$LL2@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Min
$LN15@Min:

; 617  : 		return (_Pnode);

	mov	eax, ecx

; 618  : 		}

	pop	ebp
	ret	4
?_Min@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Max, COMDAT

; 607  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	ecx, DWORD PTR __Pnode$[ebp]
	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN15@Max
	npad	1
$LL2@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL2@Max
$LN15@Max:

; 610  : 		return (_Pnode);

	mov	eax, ecx

; 611  : 		}

	pop	ebp
	ret	4
?_Max@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Myval, COMDAT

; 602  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 604  : 		}

	pop	ebp
	ret	4
?_Myval@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Right, COMDAT

; 597  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 599  : 		}

	pop	ebp
	ret	4
?_Right@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Parent, COMDAT

; 592  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 594  : 		}

	pop	ebp
	ret	4
?_Parent@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Left, COMDAT

; 587  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 588  : 		return ((_Nodepref)_Pnode->_Left);

	mov	eax, DWORD PTR __Pnode$[ebp]

; 589  : 		}

	pop	ebp
	ret	4
?_Left@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Isnil, COMDAT

; 582  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 584  : 		}

	pop	ebp
	ret	4
?_Isnil@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Color, COMDAT

; 577  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 578  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 579  : 		}

	pop	ebp
	ret	4
?_Color@?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@QAE@XZ PROC ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >, COMDAT
; _this$ = ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [ecx], 0

; 570  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@QAE@XZ ENDP ; std::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >::_Tree_val<std::_Tree_simple_types<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Mysize, COMDAT
; _this$ = ecx

; 940  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+4]

; 941  : 		}

	ret	0
?_Mysize@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAIXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 935  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 936  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABQAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Myhead, COMDAT
; _this$ = ecx

; 930  : 		return (_Get_data()._Myhead);

	mov	eax, ecx

; 931  : 		}

	ret	0
?_Myhead@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Myhead
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 925  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 926  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Get_data, COMDAT
; _this$ = ecx

; 920  : 		return (_Mypair._Get_second()._Get_second());

	mov	eax, ecx

; 921  : 		}

	ret	0
?_Get_data@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAV?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 915  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 916  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getal, COMDAT
; _this$ = ecx

; 910  : 		return (_Mypair._Get_second()._Get_first());

	mov	eax, ecx

; 911  : 		}

	ret	0
?_Getal@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 905  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 906  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QBEABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ
_TEXT	SEGMENT
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getcomp, COMDAT
; _this$ = ecx

; 900  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 901  : 		}

	ret	0
?_Getcomp@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEAAU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Getcomp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Freenode0, COMDAT
; _this$ = ecx

; 868  : 		{	// free non-value node using current allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 876  : 		}

	pop	ebp
	ret	4
?_Freenode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Freenode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode0, COMDAT
; _this$ = ecx

; 849  : 		{	// allocate a non-value node

	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	44					; 0000002cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 849  : 		{	// allocate a non-value node

	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	call	??2@YAPAXI@Z				; operator new
	mov	edx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	edx, edx
	je	SHORT $LN189@Buynode0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [edx+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [edx], eax
	test	ecx, ecx
	je	SHORT $LN120@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN120@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [edx+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN167@Buynode0
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [ecx], eax
$LN167@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 864  : 		return (_Pnode);

	mov	eax, edx
	pop	esi

; 865  : 		}

	ret	0
$LN189@Buynode0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN191@Buynode0:
$LN188@Buynode0:
	int	3
?_Buynode0@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode0
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Freeheadnode, COMDAT
; _this$ = ecx

; 838  : 		{	// free head node using current allocator

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR __Pnode$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 846  : 		}

	pop	ebp
	ret	4
?_Freeheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Freeheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ
_TEXT	SEGMENT
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 83   : 		_Ptr = ::operator new(_User_size);

	push	44					; 0000002cH
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	je	__invalid_parameter_noinfo_noreturn
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	lea	ecx, DWORD PTR [eax+4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [eax], eax
	test	ecx, ecx
	je	SHORT $LN96@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN96@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	lea	ecx, DWORD PTR [eax+8]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	ecx, ecx
	je	SHORT $LN131@Buyheadnod
	mov	DWORD PTR [ecx], eax
$LN131@Buyheadnod:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 832  : 		_Color(_Pnode) = _Black;

	mov	WORD PTR [eax+12], 257			; 00000101H

; 833  : 		_Isnil(_Pnode) = true;
; 834  : 		return (_Pnode);
; 835  : 		}

	ret	0
?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	1
	push	DWORD PTR [ecx]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 727  : 		}

	ret	0
??1?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@XZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::~_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Construct, COMDAT
; _this$ = ecx

; 720  : 		{	// construct head node

	push	esi
	mov	esi, ecx

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
	pop	esi

; 722  : 		}

	ret	0
?_Construct@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEXXZ ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Construct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z
_TEXT	SEGMENT
__Parg$ = 8						; size = 4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >, COMDAT
; _this$ = ecx

; 704  : 		{	// construct from comparator

	push	esi
	mov	esi, ecx

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax

; 705  : 		_Construct();
; 706  : 		}

	mov	eax, esi
	pop	esi
	ret	4
??0?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE@ABU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@1@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Min, COMDAT

; 697  : 		{	// return leftmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Min
	npad	2
$LL4@Min:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Min
$LN17@Min:

; 698  : 		return (_Tree_val<_Val_types>::_Min(_Pnode));

	mov	eax, ecx

; 699  : 		}

	pop	ebp
	ret	4
?_Min@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Min
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Max, COMDAT

; 692  : 		{	// return rightmost node in subtree at _Pnode

	push	ebp
	mov	ebp, esp

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	ecx, DWORD PTR __Pnode$[ebp]

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN17@Max
	npad	1
$LL4@Max:

; 609  : 			_Pnode = _Right(_Pnode);

	mov	ecx, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [ecx+8]

; 608  : 		while (!_Isnil(_Right(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL4@Max
$LN17@Max:

; 693  : 		return (_Tree_val<_Val_types>::_Max(_Pnode));

	mov	eax, ecx

; 694  : 		}

	pop	ebp
	ret	4
?_Max@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Myval, COMDAT

; 687  : 		{	// return reference to value in node

	push	ebp
	mov	ebp, esp

; 603  : 		return ((reference)_Pnode->_Myval);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 16					; 00000010H

; 688  : 		return (_Tree_val<_Val_types>::_Myval(_Pnode));
; 689  : 		}

	pop	ebp
	ret	4
?_Myval@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@2@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Myval
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Right, COMDAT

; 682  : 		{	// return reference to right pointer in node

	push	ebp
	mov	ebp, esp

; 598  : 		return ((_Nodepref)_Pnode->_Right);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 8

; 683  : 		return (_Tree_val<_Val_types>::_Right(_Pnode));
; 684  : 		}

	pop	ebp
	ret	4
?_Right@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Right
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Parent, COMDAT

; 677  : 		{	// return reference to parent pointer in node

	push	ebp
	mov	ebp, esp

; 593  : 		return ((_Nodepref)_Pnode->_Parent);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 4

; 678  : 		return (_Tree_val<_Val_types>::_Parent(_Pnode));
; 679  : 		}

	pop	ebp
	ret	4
?_Parent@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Parent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Left, COMDAT

; 672  : 		{	// return reference to left pointer in node

	push	ebp
	mov	ebp, esp

; 673  : 		return (_Tree_val<_Val_types>::_Left(_Pnode));

	mov	eax, DWORD PTR __Pnode$[ebp]

; 674  : 		}

	pop	ebp
	ret	4
?_Left@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAAPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@PAU32@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Left
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Isnil, COMDAT

; 667  : 		{	// return reference to nil flag in node

	push	ebp
	mov	ebp, esp

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 13					; 0000000dH

; 668  : 		return (_Tree_val<_Val_types>::_Isnil(_Pnode));
; 669  : 		}

	pop	ebp
	ret	4
?_Isnil@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Isnil
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
;	COMDAT ?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z
_TEXT	SEGMENT
__Pnode$ = 8						; size = 4
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z PROC ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Color, COMDAT

; 662  : 		{	// return reference to color in node

	push	ebp
	mov	ebp, esp

; 578  : 		return ((char&)_Pnode->_Color);

	mov	eax, DWORD PTR __Pnode$[ebp]
	add	eax, 12					; 0000000cH

; 663  : 		return (_Tree_val<_Val_types>::_Color(_Pnode));
; 664  : 		}

	pop	ebp
	ret	4
?_Color@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@SGAADPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@Z ENDP ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Color
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 97612893				; 05d1745dH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::allocate
?allocate@?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::_Wrap_alloc<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@2@@Z PROC ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 97612893				; 05d1745dH

; 870  : 		}

	ret	4
?max_size@?$allocator_traits@V?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@@std@@SGIABV?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@2@@Z ENDP ; std::allocator_traits<std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> > >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QBEIXZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 97612893				; 05d1745dH

; 750  : 		}

	ret	0
?max_size@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QBEIXZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 97612893				; 05d1745dH
	ja	SHORT $LN14@allocate

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	eax, eax, 44

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	jbe	SHORT $LN16@allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	jmp	SHORT $LN18@allocate
$LN14@allocate:

; 56   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
	int	3
?allocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	44					; 0000002cH
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@I@Z ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAE@XZ PROC ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@U?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@std@@@std@@QAE@XZ ENDP ; std::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >::allocator<std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??__Fapp_close@@YAXXZ
text$yd	SEGMENT
??__Fapp_close@@YAXXZ PROC				; `dynamic atexit destructor for 'app_close'', COMDAT

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	DWORD PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN9@dynamic
	push	esi

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	mov	esi, DWORD PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));

	mov	ecx, OFFSET ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	OFFSET ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	esi
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	esi
$LN9@dynamic:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 1018 : 		}

	mov	ecx, OFFSET ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	jmp	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
??__Fapp_close@@YAXXZ ENDP				; `dynamic atexit destructor for 'app_close''
text$yd	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ??__Eapp_close@@YAXXZ
text$di	SEGMENT
??__Eapp_close@@YAXXZ PROC				; `dynamic initializer for 'app_close'', COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 24   : static string app_close;

	push	OFFSET ??__Fapp_close@@YAXXZ		; `dynamic atexit destructor for 'app_close''
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR ?app_close@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 24   : static string app_close;

	call	_atexit
	pop	ecx
	ret	0
??__Eapp_close@@YAXXZ ENDP				; `dynamic initializer for 'app_close''
text$di	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??__Fapp_title@@YAXXZ
text$yd	SEGMENT
??__Fapp_title@@YAXXZ PROC				; `dynamic atexit destructor for 'app_title'', COMDAT

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	DWORD PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 16 ; 00000010H
	jb	SHORT $LN9@dynamic
	push	esi

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	mov	esi, DWORD PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));

	mov	ecx, OFFSET ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	push	OFFSET ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??$destroy@PAD@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPAPAD@Z ; std::_Wrap_alloc<std::allocator<char> >::destroy<char *>

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	esi
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	esi
$LN9@dynamic:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 1018 : 		}

	mov	ecx, OFFSET ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	jmp	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
??__Fapp_title@@YAXXZ ENDP				; `dynamic atexit destructor for 'app_title''
text$yd	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ??__Eapp_title@@YAXXZ
text$di	SEGMENT
??__Eapp_title@@YAXXZ PROC				; `dynamic initializer for 'app_title'', COMDAT
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, OFFSET ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
	call	??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 23   : static string app_title;

	push	OFFSET ??__Fapp_title@@YAXXZ		; `dynamic atexit destructor for 'app_title''
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+20, 15 ; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR ?app_title@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 23   : static string app_title;

	call	_atexit
	pop	ecx
	ret	0
??__Eapp_title@@YAXXZ ENDP				; `dynamic initializer for 'app_title''
text$di	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GGfxDriver@gxRuntime@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GGfxDriver@gxRuntime@@QAEPAXI@Z PROC			; gxRuntime::GfxDriver::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1GfxDriver@gxRuntime@@QAE@XZ
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	276					; 00000114H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GGfxDriver@gxRuntime@@QAEPAXI@Z ENDP			; gxRuntime::GfxDriver::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ??1GfxDriver@gxRuntime@@QAE@XZ
_TEXT	SEGMENT
??1GfxDriver@gxRuntime@@QAE@XZ PROC			; gxRuntime::GfxDriver::~GfxDriver, COMDAT
; _this$ = ecx
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+28]
	test	ecx, ecx
	je	SHORT $LN7@GfxDriver

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [esi+36]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+28], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+32], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+36], 0
$LN7@GfxDriver:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+24]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN106@GfxDriver
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+4]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN106@GfxDriver:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+24], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+24], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+20], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN198@GfxDriver
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+4]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
	ret	0
$LN198@GfxDriver:
	mov	BYTE PTR [esi+4], 0
	pop	esi
	ret	0
??1GfxDriver@gxRuntime@@QAE@XZ ENDP			; gxRuntime::GfxDriver::~GfxDriver
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0GfxDriver@gxRuntime@@QAE@XZ
_TEXT	SEGMENT
??0GfxDriver@gxRuntime@@QAE@XZ PROC			; gxRuntime::GfxDriver::GfxDriver, COMDAT
; _this$ = ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+24], 15			; 0000000fH
	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+4], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx+28], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+32], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+36], 0
	ret	0
??0GfxDriver@gxRuntime@@QAE@XZ ENDP			; gxRuntime::GfxDriver::GfxDriver
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEXPAPAUGfxMode@gxRuntime@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEXPAPAUGfxMode@gxRuntime@@0@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

	ret	8
?_Orphan_range@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEXPAPAUGfxMode@gxRuntime@@0@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEXXZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEXXZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXXZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXXZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	push	edi

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, ecx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	edx, DWORD PTR [esi]
	push	ebx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ebx, 1073741823				; 3fffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, ebx
	sub	eax, edx
	cmp	eax, ecx
	jb	SHORT $LN134@Reserve

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, DWORD PTR [esi]

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edi, 2
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, edi
	shr	eax, 1
	sub	ebx, eax
	add	eax, edi
	cmp	ebx, edi
	cmovae	ecx, eax
	cmp	ecx, edx
	cmovae	edx, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, esi
	push	edx
	call	?_Reallocate@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reallocate
	pop	ebx
$LN2@Reserve:
	pop	edi
	pop	esi

; 1632 : 			}
; 1633 : 		}

	pop	ebp
	ret	4
$LN134@Reserve:

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
	int	3
?_Reserve@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z ; std::allocator<gxRuntime::GfxMode *>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR [edi+4]
	sub	edx, esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	esi
	push	ebx
	call	_memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, ecx
	sar	esi, 2

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [edi], ebx
	pop	edi
	pop	esi
	pop	ebx

; 1623 : 		}

	pop	ebp
	ret	4
?_Reallocate@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBE_NPBQAUGfxMode@gxRuntime@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBE_NPBQAUGfxMode@gxRuntime@@@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN3@Inside
	cmp	DWORD PTR [ecx], eax
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	pop	ebp
	ret	4
?_Inside@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBE_NPBQAUGfxMode@gxRuntime@@@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEII@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 1073741823				; 3fffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	esi, DWORD PTR [ecx]
	sar	esi, 2

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[ebp]
	cmovb	eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	pop	ebp
	ret	4
?_Grow_to@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IBEII@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXPAPAUGfxMode@gxRuntime@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXPAPAUGfxMode@gxRuntime@@0@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Destroy, COMDAT
; _this$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXPAPAUGfxMode@gxRuntime@@0@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXABQAUGfxMode@gxRuntime@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXABQAUGfxMode@gxRuntime@@@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	edi, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	edi, eax
	jae	SHORT $LN2@push_back
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, edi
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	edi, ecx
	sar	edi, 2

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN209@push_back
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 1295 : 			}
; 1296 : 		}

	pop	ebp
	ret	4
$LN2@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),
; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else
; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN209@push_back
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN209@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 1295 : 			}
; 1296 : 		}

	pop	ebp
	ret	4
?push_back@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXABQAUGfxMode@gxRuntime@@@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEAAPAUGfxMode@gxRuntime@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEAAPAUGfxMode@gxRuntime@@I@Z PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1243 : 		}

	pop	ebp
	ret	4
??A?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEAAPAUGfxMode@gxRuntime@@I@Z ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1181 : 		}

	ret	0
?size@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1044 : 		}

	ret	0
?capacity@?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::~vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::~vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >::vector<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >::_Vector_val<std::_Simple_types<gxRuntime::GfxMode *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxMode@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxMode@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@PAUGfxMode@gxRuntime@@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxMode *,std::allocator<gxRuntime::GfxMode *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@I@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEXPAPAUGfxMode@gxRuntime@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z ; std::allocator<gxRuntime::GfxMode *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >::_Wrap_alloc<std::allocator<gxRuntime::GfxMode *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGIABV?$allocator@PAUGfxMode@gxRuntime@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGIABV?$allocator@PAUGfxMode@gxRuntime@@@2@@Z PROC ; std::allocator_traits<std::allocator<gxRuntime::GfxMode *> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	4
?max_size@?$allocator_traits@V?$allocator@PAUGfxMode@gxRuntime@@@std@@@std@@SGIABV?$allocator@PAUGfxMode@gxRuntime@@@2@@Z ENDP ; std::allocator_traits<std::allocator<gxRuntime::GfxMode *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAUGfxMode@gxRuntime@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAUGfxMode@gxRuntime@@@std@@QBEIXZ PROC ; std::allocator<gxRuntime::GfxMode *>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@PAUGfxMode@gxRuntime@@@std@@QBEIXZ ENDP ; std::allocator<gxRuntime::GfxMode *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z PROC ; std::allocator<gxRuntime::GfxMode *>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN14@allocate

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	jbe	SHORT $LN16@allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	jmp	SHORT $LN18@allocate
$LN14@allocate:

; 56   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
	int	3
?allocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEPAPAUGfxMode@gxRuntime@@I@Z ENDP ; std::allocator<gxRuntime::GfxMode *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@I@Z PROC ; std::allocator<gxRuntime::GfxMode *>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAUGfxMode@gxRuntime@@@std@@QAEXPAPAUGfxMode@gxRuntime@@I@Z ENDP ; std::allocator<gxRuntime::GfxMode *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAUGfxMode@gxRuntime@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAUGfxMode@gxRuntime@@@std@@QAE@XZ PROC	; std::allocator<gxRuntime::GfxMode *>::allocator<gxRuntime::GfxMode *>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@PAUGfxMode@gxRuntime@@@std@@QAE@XZ ENDP	; std::allocator<gxRuntime::GfxMode *>::allocator<gxRuntime::GfxMode *>
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GgxRuntime@@AAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GgxRuntime@@AAEPAXI@Z PROC				; gxRuntime::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1gxRuntime@@AAE@XZ			; gxRuntime::~gxRuntime
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	292					; 00000124H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GgxRuntime@@AAEPAXI@Z ENDP				; gxRuntime::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z
_TEXT	SEGMENT
$T2 = -108						; size = 8
$T3 = -104						; size = 4
$T4 = -100						; size = 8
_this$ = -96						; size = 4
$T5 = -96						; size = 4
_in$GSCopy$1$ = -92					; size = 4
_out$GSCopy$1$ = -88					; size = 4
_h$1$ = -84						; size = 4
$T6 = -80						; size = 4
_t$7 = -80						; size = 4
_func$GSCopy$1$ = -76					; size = 4
_t$1$ = -76						; size = 4
_f$8 = -76						; size = 4
$T9 = -72						; size = 28
$T10 = -44						; size = 28
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_dll$ = 8						; size = 4
_func$ = 12						; size = 4
_in$ = 16						; size = 4
_in_sz$ = 20						; size = 4
_out$ = 24						; size = 4
_out_sz$ = 28						; size = 4
?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z PROC ; gxRuntime::callDll, COMDAT
; _this$ = ecx

; 1200 : int gxRuntime::callDll( const std::string &dll,const std::string &func,const void *in,int in_sz,void *out,int out_sz ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 96					; 00000060H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _in$[ebp]

; 1201 : 
; 1202 : 	map<string,gxDll*>::const_iterator lib_it=libs.find( dll );

	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	mov	ebx, DWORD PTR _dll$[ebp]
	mov	edi, DWORD PTR _func$[ebp]
	mov	DWORD PTR _in$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _out$GSCopy$1$[ebp], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	ebx
	push	eax
	mov	DWORD PTR _func$GSCopy$1$[ebp], edi
	call	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::find
	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1204 : 	if( lib_it==libs.end() ){

	jne	$LN118@callDll
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN59@callDll
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN60@callDll
$LN59@callDll:
	mov	eax, ebx
$LN60@callDll:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1205 : 		HINSTANCE h=LoadLibrary( dll.c_str() );

	push	eax
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	DWORD PTR _h$1$[ebp], eax

; 1206 : 		if( !h ) return 0;

	test	eax, eax
	jne	SHORT $LN3@callDll
$LN418@callDll:
	xor	eax, eax
	jmp	$LN1@callDll
$LN3@callDll:

; 1207 : 		gxDll *t=d_new gxDll;

	push	12					; 0000000cH
	call	??2@YAPAXI@Z				; operator new
	mov	edi, eax
	add	esp, 4
	mov	DWORD PTR $T6[ebp], edi
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	edi, edi
	je	SHORT $LN7@callDll
	lea	esi, DWORD PTR [edi+4]
	mov	DWORD PTR _this$[ebp], esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 721  : 		_Myhead() = _Buyheadnode();

	mov	ecx, esi

; 567  : 		: _Myhead(),

	mov	DWORD PTR [esi], 0

; 568  : 		_Mysize(0)

	mov	DWORD PTR [esi+4], 0

; 721  : 		_Myhead() = _Buyheadnode();

	call	?_Buyheadnode@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@XZ ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buyheadnode
	mov	DWORD PTR [esi], eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1207 : 		gxDll *t=d_new gxDll;

	jmp	SHORT $LN8@callDll
$LN7@callDll:
	xor	edi, edi
$LN8@callDll:

; 1208 : 		t->hinst=h;

	mov	eax, DWORD PTR _h$1$[ebp]
	mov	DWORD PTR [edi], eax

; 1209 : 		lib_it=libs.insert( make_pair( dll,t ) ).first;

	lea	eax, DWORD PTR _t$7[ebp]
	push	eax
	push	ebx
	lea	eax, DWORD PTR $T10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	push	eax
	mov	DWORD PTR _t$7[ebp], edi
	call	??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAPAUgxDll@@@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAPAUgxDll@@@Z ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,gxDll * &>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	eax
	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1209 : 		lib_it=libs.insert( make_pair( dll,t ) ).first;

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	call	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *> >

; 1077 : 		return (_Insert_nohint(false,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1077 : 		return (_Insert_nohint(false,

	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	push	eax
	push	0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T10[ebp+20]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1209 : 		lib_it=libs.insert( make_pair( dll,t ) ).first;

	mov	esi, DWORD PTR $T4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN123@callDll
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T10[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN123@callDll:
	mov	edi, DWORD PTR _func$GSCopy$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T10[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T10[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T10[ebp], 0
$LN118@callDll:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1212 : 	gxDll *t=lib_it->second;

	mov	eax, DWORD PTR [esi+40]
	mov	DWORD PTR _t$1$[ebp], eax

; 1213 : 	map<string,LibFunc>::const_iterator fun_it=t->funcs.find( func );

	push	edi
	lea	ebx, DWORD PTR [eax+4]
	lea	eax, DWORD PTR $T5[ebp]
	mov	ecx, ebx
	push	eax
	call	?find@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAE?AV?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@2@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::find
	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, DWORD PTR [ebx]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1215 : 	if( fun_it==t->funcs.end() ){

	jne	$LN302@callDll
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN280@callDll
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN281@callDll
$LN280@callDll:
	mov	eax, edi
$LN281@callDll:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1216 : 		LibFunc f=(LibFunc)GetProcAddress( t->hinst,func.c_str() );

	push	eax
	mov	eax, DWORD PTR _t$1$[ebp]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__GetProcAddress@8
	mov	DWORD PTR _f$8[ebp], eax

; 1217 : 		if( !f ) return 0;

	test	eax, eax
	je	$LN418@callDll

; 1218 : 		fun_it=t->funcs.insert( make_pair( func,f ) ).first;

	lea	eax, DWORD PTR _f$8[ebp]
	push	eax
	push	edi
	lea	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??$make_pair@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AAP6GHPBXHPAXH@Z@std@@YG?AU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@0@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AAP6GHPBXHPAXH@Z@Z ; std::make_pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const &,int (__stdcall*&)(void const *,int,void *,int)>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	push	eax
	mov	ecx, ebx
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1218 : 		fun_it=t->funcs.insert( make_pair( func,f ) ).first;

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1076 : 		_Nodeptr _Newnode = this->_Buynode(_STD forward<_Valty>(_Val)...);

	call	??$_Buynode@U?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@?$_Tree_comp_alloc@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@QAEPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@$$QAU?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@@Z ; std::_Tree_comp_alloc<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Buynode<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int)> >

; 1077 : 		return (_Insert_nohint(false,

	push	eax

; 603  : 		return ((reference)_Pnode->_Myval);

	add	eax, 16					; 00000010H

; 1077 : 		return (_Insert_nohint(false,

	mov	ecx, ebx
	push	eax
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$_Insert_nohint@AAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@2@@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@ZU?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@2@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_iterator@V?$_Tree_val@U?$_Tree_simple_types@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@@std@@@std@@@std@@_N@1@_NAAU?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@1@PAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@PAX@1@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,int (__stdcall*)(void const *,int,void *,int),std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> >,0> >::_Insert_nohint<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)> &,std::_Tree_node<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,int (__stdcall*)(void const *,int,void *,int)>,void *> *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T9[ebp+20]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1218 : 		fun_it=t->funcs.insert( make_pair( func,f ) ).first;

	mov	esi, DWORD PTR $T2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN307@callDll
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T9[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN307@callDll:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR $T9[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR $T9[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR $T9[ebp], 0
$LN302@callDll:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1224 : 		mov	[save_esp],esp

	mov	DWORD PTR ?save_esp@?1??callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z@4PAXA, esp

; 1225 : 	};
; 1226 : 
; 1227 : 	int n=fun_it->second( in,in_sz,out,out_sz );

	push	DWORD PTR _out_sz$[ebp]
	mov	eax, DWORD PTR [esi+40]
	push	DWORD PTR _out$GSCopy$1$[ebp]
	push	DWORD PTR _in_sz$[ebp]
	push	DWORD PTR _in$GSCopy$1$[ebp]
	call	eax

; 1230 : 		mov esp,[save_esp]

	mov	esp, DWORD PTR ?save_esp@?1??callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z@4PAXA

; 1228 : 
; 1229 : 	_asm{

$LN1@callDll:

; 1231 : 	};
; 1232 : 
; 1233 : 	return n;
; 1234 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z$0:
	push	12					; 0000000cH
	mov	eax, DWORD PTR $T6[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z$1:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@QAE@XZ
__unwindfunclet$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z$2:
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$pair@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@P6GHPBXHPAXH@Z@std@@QAE@XZ
__ehhandler$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-112]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?callDll@gxRuntime@@QAEHABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0PBXHPAXH@Z ENDP ; gxRuntime::callDll
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?enableDirectInput@gxRuntime@@QAEX_N@Z
_TEXT	SEGMENT
_enable$ = 8						; size = 1
?enableDirectInput@gxRuntime@@QAEX_N@Z PROC		; gxRuntime::enableDirectInput, COMDAT
; _this$ = ecx

; 1192 : void gxRuntime::enableDirectInput( bool enable ){

	push	ebp
	mov	ebp, esp

; 1193 : 	if( use_di=enable ){

	movzx	eax, BYTE PTR _enable$[ebp]
	push	esi
	mov	esi, ecx

; 183  : 	if( !input ) return;

	mov	ecx, DWORD PTR [esi+12]

; 1193 : 	if( use_di=enable ){

	mov	DWORD PTR [esi+140], eax
	test	eax, eax
	je	SHORT $LN2@enableDire

; 183  : 	if( !input ) return;

	test	ecx, ecx
	je	SHORT $LN11@enableDire

; 184  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN8@enableDire

; 185  : 		if( use_di ){
; 186  : 			use_di=input->acquire();

	call	?acquire@gxInput@@QAE_NXZ		; gxInput::acquire
	movzx	eax, al
	mov	DWORD PTR [esi+140], eax
$LN8@enableDire:

; 187  : 		}else{
; 188  : 		}
; 189  : 	}
; 190  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]

; 196  : 	input->reset();

	call	?reset@gxInput@@QAEXXZ			; gxInput::reset
	pop	esi

; 1194 : 		acquireInput();
; 1195 : 	}else{
; 1196 : 		unacquireInput();
; 1197 : 	}
; 1198 : }

	pop	ebp
	ret	4
$LN2@enableDire:

; 194  : 	if( !input ) return;

	test	ecx, ecx
	je	SHORT $LN11@enableDire

; 195  : 	if( gfx_mode==3 && use_di ) input->unacquire();
; 196  : 	input->reset();

	call	?reset@gxInput@@QAEXXZ			; gxInput::reset
$LN11@enableDire:
	pop	esi

; 1194 : 		acquireInput();
; 1195 : 	}else{
; 1196 : 		unacquireInput();
; 1197 : 	}
; 1198 : }

	pop	ebp
	ret	4
?enableDirectInput@gxRuntime@@QAEX_N@Z ENDP		; gxRuntime::enableDirectInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?freeTimer@gxRuntime@@QAEXPAVgxTimer@@@Z
_TEXT	SEGMENT
__Ans$1 = -8						; size = 8
__Ans$2 = -8						; size = 8
$T3 = -4						; size = 4
$T4 = 8							; size = 1
_t$ = 8							; size = 4
?freeTimer@gxRuntime@@QAEXPAVgxTimer@@@Z PROC		; gxRuntime::freeTimer, COMDAT
; _this$ = ecx

; 1119 : void gxRuntime::freeTimer( gxTimer *t ){

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1595 : 		return (_Eqrange(_Keyval));

	lea	eax, DWORD PTR _t$[ebp]
	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	eax
	lea	eax, DWORD PTR __Ans$2[ebp]
	push	eax
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 1126 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	DWORD PTR $T4[ebp]
	push	DWORD PTR __Ans$2[ebp+4]
	push	DWORD PTR __Ans$2[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1120 : 	if( !timers.count( t ) ) return;

	test	eax, eax
	je	SHORT $LN60@freeTimer
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2025 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	lea	eax, DWORD PTR _t$[ebp]
	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	eax
	lea	eax, DWORD PTR __Ans$1[ebp]
	push	eax
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>

; 1462 : 		erase(_Where.first, _Where.second);

	push	DWORD PTR __Ans$1[ebp+4]
	lea	eax, DWORD PTR $T3[ebp]
	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	DWORD PTR __Ans$1[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1122 : 	delete t;

	mov	esi, DWORD PTR _t$[ebp]
	test	esi, esi
	je	SHORT $LN63@freeTimer
	mov	ecx, esi
	call	??1gxTimer@@QAE@XZ			; gxTimer::~gxTimer
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN63@freeTimer:
	pop	esi
$LN60@freeTimer:

; 1123 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?freeTimer@gxRuntime@@QAEXPAVgxTimer@@@Z ENDP		; gxRuntime::freeTimer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z
_TEXT	SEGMENT
$T2 = -20						; size = 8
$T3 = -16						; size = 4
__$EHRec$ = -12						; size = 12
$T4 = 8							; size = 1
_t$ = 8							; size = 4
_hertz$ = 8						; size = 4
?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z PROC		; gxRuntime::createTimer, COMDAT
; _this$ = ecx

; 1113 : gxTimer *gxRuntime::createTimer( int hertz ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1114 : 	gxTimer *t=d_new gxTimer( this,hertz );

	push	20					; 00000014H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T3[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN3@createTime
	push	DWORD PTR _hertz$[ebp]
	mov	ecx, eax
	push	esi
	call	??0gxTimer@@QAE@PAVgxRuntime@@H@Z	; gxTimer::gxTimer
	jmp	SHORT $LN4@createTime
$LN3@createTime:
	xor	eax, eax
$LN4@createTime:
	mov	DWORD PTR _t$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1204 : 		return (_Insert_nohint(false,

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	DWORD PTR $T4[ebp]
	lea	eax, DWORD PTR _t$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1114 : 	gxTimer *t=d_new gxTimer( this,hertz );

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1204 : 		return (_Insert_nohint(false,

	push	eax
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??$_Insert_nohint@ABQAVgxTimer@@U_Nil@std@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IAE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@_N@1@_NABQAVgxTimer@@U_Nil@1@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Insert_nohint<gxTimer * const &,std::_Nil>
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1116 : 	return t;

	mov	eax, DWORD PTR _t$[ebp]

; 1117 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z$0:
	push	20					; 00000014H
	mov	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?createTimer@gxRuntime@@QAEPAVgxTimer@@H@Z ENDP		; gxRuntime::createTimer
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?closeFileSystem@gxRuntime@@QAEXPAVgxFileSystem@@@Z
_TEXT	SEGMENT
_f$ = 8							; size = 4
?closeFileSystem@gxRuntime@@QAEXPAVgxFileSystem@@@Z PROC ; gxRuntime::closeFileSystem, COMDAT
; _this$ = ecx

; 971  : void gxRuntime::closeFileSystem( gxFileSystem *f ){

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 972  : 	if( !fileSystem || fileSystem!=f ) return;

	mov	esi, DWORD PTR [edi+20]
	test	esi, esi
	je	SHORT $LN3@closeFileS
	cmp	esi, DWORD PTR _f$[ebp]
	jne	SHORT $LN3@closeFileS

; 973  : 
; 974  : 	delete fileSystem;
; 975  : 	fileSystem=0;

	mov	ecx, esi
	call	??1gxFileSystem@@QAE@XZ			; gxFileSystem::~gxFileSystem
	push	1
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	DWORD PTR [edi+20], 0
$LN3@closeFileS:
	pop	edi
	pop	esi

; 976  : }

	pop	ebp
	ret	4
?closeFileSystem@gxRuntime@@QAEXPAVgxFileSystem@@@Z ENDP ; gxRuntime::closeFileSystem
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flags$ = 8						; size = 4
?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z PROC	; gxRuntime::openFileSystem, COMDAT
; _this$ = ecx

; 964  : gxFileSystem *gxRuntime::openFileSystem( int flags ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 965  : 	if( fileSystem ) return 0;

	cmp	DWORD PTR [esi+20], 0
	je	SHORT $LN2@openFileSy
	xor	eax, eax

; 968  : 	return fileSystem;
; 969  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@openFileSy:

; 966  : 
; 967  : 	fileSystem=d_new gxFileSystem();

	push	1
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@openFileSy
	mov	ecx, eax
	call	??0gxFileSystem@@QAE@XZ			; gxFileSystem::gxFileSystem
	jmp	SHORT $LN5@openFileSy
$LN4@openFileSy:
	xor	eax, eax
$LN5@openFileSy:
	mov	DWORD PTR [esi+20], eax

; 968  : 	return fileSystem;
; 969  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z$0:
	push	1
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?openFileSystem@gxRuntime@@QAEPAVgxFileSystem@@H@Z ENDP	; gxRuntime::openFileSystem
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?graphicsLost@gxRuntime@@QAE_NXZ
_TEXT	SEGMENT
?graphicsLost@gxRuntime@@QAE_NXZ PROC			; gxRuntime::graphicsLost, COMDAT
; _this$ = ecx

; 961  : 	return gfx_lost;

	mov	al, BYTE PTR ?gfx_lost@@3_NA

; 962  : }

	ret	0
?graphicsLost@gxRuntime@@QAE_NXZ ENDP			; gxRuntime::graphicsLost
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?closeGraphics@gxRuntime@@QAEXPAVgxGraphics@@@Z
_TEXT	SEGMENT
_g$ = 8							; size = 4
?closeGraphics@gxRuntime@@QAEXPAVgxGraphics@@@Z PROC	; gxRuntime::closeGraphics, COMDAT
; _this$ = ecx

; 936  : void gxRuntime::closeGraphics( gxGraphics *g ){

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 937  : 	if( !graphics || graphics!=g ) return;

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	$LN3@closeGraph
	cmp	eax, DWORD PTR _g$[ebp]
	jne	$LN3@closeGraph

; 194  : 	if( !input ) return;

	mov	ecx, DWORD PTR [esi+12]

; 938  : 
; 939  : 	auto_suspend=false;

	mov	BYTE PTR ?auto_suspend@@3_NA, 0

; 940  : 
; 941  : 	busy=true;

	mov	BYTE PTR ?busy@@3_NA, 1

; 194  : 	if( !input ) return;

	test	ecx, ecx
	je	SHORT $LN11@closeGraph

; 195  : 	if( gfx_mode==3 && use_di ) input->unacquire();

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN13@closeGraph
	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN13@closeGraph
	call	?unacquire@gxInput@@QAEXXZ		; gxInput::unacquire
$LN13@closeGraph:

; 196  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]
	call	?reset@gxInput@@QAEXXZ			; gxInput::reset
$LN11@closeGraph:

; 942  : 
; 943  : 	unacquireInput();
; 944  : 	if( timerID ){ timeKillEvent( timerID );timerID=0; }

	mov	eax, DWORD PTR ?timerID@@3IA
	test	eax, eax
	je	SHORT $LN4@closeGraph
	push	eax
	call	DWORD PTR __imp__timeKillEvent@4
	mov	DWORD PTR ?timerID@@3IA, 0
$LN4@closeGraph:

; 945  : 	if( clipper ){ clipper->Release();clipper=0; }

	mov	ecx, DWORD PTR ?clipper@@3PAUIDirectDrawClipper@@A
	test	ecx, ecx
	je	SHORT $LN5@closeGraph
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?clipper@@3PAUIDirectDrawClipper@@A, 0
$LN5@closeGraph:

; 946  : 	if( primSurf ){ primSurf->Release();primSurf=0; }

	mov	ecx, DWORD PTR ?primSurf@@3PAUIDirectDrawSurface7@@A
	test	ecx, ecx
	je	SHORT $LN6@closeGraph
	mov	eax, DWORD PTR [ecx]
	push	ecx
	call	DWORD PTR [eax+8]
	mov	DWORD PTR ?primSurf@@3PAUIDirectDrawSurface7@@A, 0
$LN6@closeGraph:

; 947  : 	delete graphics;graphics=0;

	push	edi
	mov	edi, DWORD PTR [esi+16]
	test	edi, edi
	je	SHORT $LN16@closeGraph
	mov	ecx, edi
	call	??1gxGraphics@@QAE@XZ			; gxGraphics::~gxGraphics
	push	2184					; 00000888H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN16@closeGraph:

; 948  : 
; 949  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	mov	DWORD PTR [esi+16], 0
	pop	edi
	jne	SHORT $LN7@closeGraph

; 950  : 		ShowCursor( 1 );

	push	1
	call	DWORD PTR __imp__ShowCursor@4

; 951  : 		restoreWindowState();

	mov	ecx, esi
	call	?restoreWindowState@gxRuntime@@AAEXXZ	; gxRuntime::restoreWindowState
$LN7@closeGraph:

; 952  : 	}
; 953  : 	gfx_mode=0;

	mov	DWORD PTR ?gfx_mode@@3HA, 0

; 954  : 
; 955  : 	gfx_lost=false;

	mov	BYTE PTR ?gfx_lost@@3_NA, 0

; 956  : 
; 957  : 	busy=false;

	mov	BYTE PTR ?busy@@3_NA, 0
$LN3@closeGraph:
	pop	esi

; 958  : }

	pop	ebp
	ret	4
?closeGraphics@gxRuntime@@QAEXPAVgxGraphics@@@Z ENDP	; gxRuntime::closeGraphics
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?openGraphics@gxRuntime@@QAEPAVgxGraphics@@HHHHH@Z
_TEXT	SEGMENT
_tw$1$ = -76						; size = 4
_zz$1 = -72						; size = 8
_this$GSCopy$1$ = -64					; size = 4
_hh$1$ = -60						; size = 4
_ww$1$ = -56						; size = 4
_d3d$ = -56						; size = 1
_c_r$2 = -52						; size = 16
_c_r$3 = -36						; size = 16
_w_r$4 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_d$ = 16						; size = 4
_driver$ = 20						; size = 4
_flags$ = 24						; size = 4
?openGraphics@gxRuntime@@QAEPAVgxGraphics@@HHHHH@Z PROC	; gxRuntime::openGraphics, COMDAT
; _this$ = ecx

; 864  : gxGraphics *gxRuntime::openGraphics( int w,int h,int d,int driver,int flags ){

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 865  : 	if( graphics ) return 0;

	cmp	DWORD PTR [ebx+16], 0
	je	SHORT $LN2@openGraphi
	xor	eax, eax
	pop	ebx

; 928  : 
; 929  : 	gfx_lost=false;
; 930  : 
; 931  : 	busy=false;
; 932  : 
; 933  : 	return graphics;
; 934  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN2@openGraphi:

; 866  : 
; 867  : 	busy=true;
; 868  : 
; 869  : 	bool d3d=flags & gxGraphics::GRAPHICS_3D ? true : false;

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	eax, ecx
	shr	eax, 2

; 870  : 	bool windowed=flags & gxGraphics::GRAPHICS_WINDOWED ? true : false;

	mov	dl, cl
	and	al, 1
	mov	BYTE PTR ?busy@@3_NA, 1
	and	dl, 1
	mov	BYTE PTR _d3d$[ebp], al

; 871  : 
; 872  : 	if( windowed ) driver=0;
; 873  : 
; 874  : 	curr_driver=drivers[driver];

	mov	eax, DWORD PTR [ebx+124]
	mov	ecx, 0
	cmove	ecx, DWORD PTR _driver$[ebp]
	push	esi
	push	edi
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [ebx+136], eax

; 875  : 
; 876  : 	if( windowed ){

	test	dl, dl
	je	$LN4@openGraphi

; 877  : 		if( graphics=openWindowedGraphics( w,h,d,d3d ) ){

	push	DWORD PTR _d3d$[ebp]
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _d$[ebp]
	mov	edi, DWORD PTR _w$[ebp]
	push	eax
	push	edi
	mov	DWORD PTR _hh$1$[ebp], eax
	mov	DWORD PTR _ww$1$[ebp], edi
	call	?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z ; gxRuntime::openWindowedGraphics
	mov	DWORD PTR [ebx+16], eax
	test	eax, eax
	je	$LN11@openGraphi

; 878  : 			gfx_mode=(flags & gxGraphics::GRAPHICS_SCALED) ? 1 : 2;

	mov	ecx, DWORD PTR _flags$[ebp]
	mov	eax, ecx
	and	al, 2
	movzx	eax, al
	neg	eax
	sbb	eax, eax

; 879  : 			auto_suspend=(flags & gxGraphics::GRAPHICS_AUTOSUSPEND) ? true : false;

	shr	ecx, 3
	add	eax, 2
	and	cl, 1
	mov	DWORD PTR ?gfx_mode@@3HA, eax
	mov	BYTE PTR ?auto_suspend@@3_NA, cl

; 880  : 			int ws,ww,hh;
; 881  : 			if( gfx_mode==1 ){

	cmp	eax, 1
	jne	SHORT $LN7@openGraphi

; 882  : 				ws=scaled_ws;
; 883  : 				RECT c_r;
; 884  : 				GetClientRect( hwnd,&c_r );

	lea	eax, DWORD PTR _c_r$3[ebp]
	mov	esi, 282001408				; 10cf0000H
	push	eax
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__GetClientRect@8

; 885  : 				ww=c_r.right-c_r.left;

	mov	edi, DWORD PTR _c_r$3[ebp+8]
	sub	edi, DWORD PTR _c_r$3[ebp]

; 886  : 				hh=c_r.bottom-c_r.top;

	mov	eax, DWORD PTR _c_r$3[ebp+12]
	sub	eax, DWORD PTR _c_r$3[ebp+4]
	mov	DWORD PTR _ww$1$[ebp], edi
	mov	DWORD PTR _hh$1$[ebp], eax

; 887  : 			}else{

	jmp	SHORT $LN8@openGraphi
$LN7@openGraphi:

; 888  : 				ws=static_ws;

	mov	esi, 281673728				; 10ca0000H
$LN8@openGraphi:

; 889  : 				ww=w;
; 890  : 				hh=h;
; 891  : 			}
; 892  : 
; 893  : 			SetWindowLong( hwnd,GWL_STYLE,ws );

	push	esi
	push	-16					; fffffff0H
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__SetWindowLongA@12

; 894  : 			SetWindowPos( hwnd,0,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_FRAMECHANGED );

	push	39					; 00000027H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__SetWindowPos@28

; 895  : 
; 896  : 			RECT w_r,c_r;
; 897  : 			GetWindowRect( hwnd,&w_r );

	lea	eax, DWORD PTR _w_r$4[ebp]
	push	eax
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__GetWindowRect@8

; 898  : 			GetClientRect( hwnd,&c_r );

	lea	eax, DWORD PTR _c_r$2[ebp]
	push	eax
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__GetClientRect@8

; 899  : 			int tw=(w_r.right-w_r.left)-(c_r.right-c_r.left);

	mov	eax, DWORD PTR _c_r$2[ebp]
	sub	eax, DWORD PTR _c_r$2[ebp+8]

; 900  : 			int th=(w_r.bottom-w_r.top)-(c_r.bottom-c_r.top );

	mov	ebx, DWORD PTR _c_r$2[ebp+4]
	sub	ebx, DWORD PTR _c_r$2[ebp+12]
	sub	eax, DWORD PTR _w_r$4[ebp]
	add	eax, DWORD PTR _w_r$4[ebp+8]
	sub	ebx, DWORD PTR _w_r$4[ebp+4]
	add	ebx, DWORD PTR _w_r$4[ebp+12]

; 901  : 			int cx=( GetSystemMetrics( SM_CXSCREEN )-ww )/2;

	mov	esi, DWORD PTR __imp__GetSystemMetrics@4
	push	0
	mov	DWORD PTR _tw$1$[ebp], eax
	call	esi
	sub	eax, edi
	cdq
	sub	eax, edx
	mov	edi, eax

; 902  : 			int cy=( GetSystemMetrics( SM_CYSCREEN )-hh )/2;

	push	1
	sar	edi, 1
	call	esi
	sub	eax, DWORD PTR _hh$1$[ebp]
	cdq
	sub	eax, edx

; 903  : 			POINT zz={0,0};

	mov	DWORD PTR _zz$1[ebp], 0
	mov	esi, eax
	mov	DWORD PTR _zz$1[ebp+4], 0

; 904  : 			ClientToScreen( hwnd,&zz );

	lea	eax, DWORD PTR _zz$1[ebp]
	sar	esi, 1
	push	eax
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	push	DWORD PTR [eax]
	call	DWORD PTR __imp__ClientToScreen@8

; 905  : 			int bw=zz.x-w_r.left,bh=zz.y-w_r.top;
; 906  : 			int wx=cx-bw,wy=cy-bh;if( wy<0 ) wy=0;		//not above top!

	sub	edi, DWORD PTR _zz$1[ebp]
	mov	eax, 0
	sub	esi, DWORD PTR _zz$1[ebp+4]
	add	edi, DWORD PTR _w_r$4[ebp]
	add	esi, DWORD PTR _w_r$4[ebp+4]

; 907  : 			MoveWindow( hwnd,wx,wy,ww+tw,hh+th,true );

	push	1
	cmovs	esi, eax
	mov	eax, DWORD PTR _hh$1$[ebp]
	add	eax, ebx
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	push	eax
	mov	eax, DWORD PTR _tw$1$[ebp]
	add	eax, DWORD PTR _ww$1$[ebp]
	push	eax
	push	esi
	push	edi
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__MoveWindow@24

; 908  : 		}
; 909  : 	}else{

	jmp	$LN11@openGraphi
$LN4@openGraphi:

; 731  : 	GetWindowRect( hwnd,&t_rect );

	lea	eax, DWORD PTR [ebx+24]
	push	eax
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__GetWindowRect@8

; 732  : 	t_style=GetWindowLong( hwnd,GWL_STYLE );

	push	-16					; fffffff0H
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__GetWindowLongA@8

; 910  : 		backupWindowState();
; 911  : 
; 912  : 		SetWindowLong( hwnd,GWL_STYLE,WS_VISIBLE|WS_POPUP );

	push	-1879048192				; 90000000H
	push	-16					; fffffff0H
	push	DWORD PTR [ebx]

; 732  : 	t_style=GetWindowLong( hwnd,GWL_STYLE );

	mov	DWORD PTR [ebx+40], eax

; 910  : 		backupWindowState();
; 911  : 
; 912  : 		SetWindowLong( hwnd,GWL_STYLE,WS_VISIBLE|WS_POPUP );

	call	DWORD PTR __imp__SetWindowLongA@12

; 913  : 		SetWindowPos( hwnd,0,0,0,0,0,SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_FRAMECHANGED );

	push	39					; 00000027H
	push	0
	push	0
	push	0
	push	0
	push	0
	push	DWORD PTR [ebx]
	call	DWORD PTR __imp__SetWindowPos@28

; 914  : 
; 915  : 		ShowCursor( 0 );

	mov	esi, DWORD PTR __imp__ShowCursor@4
	push	0
	call	esi

; 916  : 		if( graphics=openExclusiveGraphics( w,h,d,d3d ) ){

	push	DWORD PTR _d3d$[ebp]
	mov	ecx, ebx
	push	DWORD PTR _d$[ebp]
	push	DWORD PTR _h$[ebp]
	push	DWORD PTR _w$[ebp]
	call	?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z ; gxRuntime::openExclusiveGraphics
	mov	DWORD PTR [ebx+16], eax
	test	eax, eax
	je	SHORT $LN10@openGraphi

; 917  : 			gfx_mode=3;
; 918  : 			auto_suspend=true;
; 919  : 			SetCursorPos(0,0);

	push	0
	push	0
	mov	DWORD PTR ?gfx_mode@@3HA, 3
	mov	BYTE PTR ?auto_suspend@@3_NA, 1
	call	DWORD PTR __imp__SetCursorPos@8

; 920  : 			acquireInput();

	mov	ecx, ebx
	call	?acquireInput@gxRuntime@@AAEXXZ		; gxRuntime::acquireInput

; 921  : 		}else{

	jmp	SHORT $LN11@openGraphi
$LN10@openGraphi:

; 922  : 			ShowCursor( 1 );

	push	1
	call	esi

; 923  : 			restoreWindowState();

	mov	ecx, ebx
	call	?restoreWindowState@gxRuntime@@AAEXXZ	; gxRuntime::restoreWindowState
$LN11@openGraphi:

; 924  : 		}
; 925  : 	}
; 926  : 
; 927  : 	if( !graphics ) curr_driver=0;

	mov	eax, DWORD PTR [ebx+16]
	pop	edi
	pop	esi
	test	eax, eax
	jne	SHORT $LN12@openGraphi
	mov	DWORD PTR [ebx+136], eax
$LN12@openGraphi:

; 928  : 
; 929  : 	gfx_lost=false;
; 930  : 
; 931  : 	busy=false;
; 932  : 
; 933  : 	return graphics;
; 934  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	mov	BYTE PTR ?gfx_lost@@3_NA, 0
	mov	BYTE PTR ?busy@@3_NA, 0
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?openGraphics@gxRuntime@@QAEPAVgxGraphics@@HHHHH@Z ENDP	; gxRuntime::openGraphics
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?closeInput@gxRuntime@@QAEXPAVgxInput@@@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?closeInput@gxRuntime@@QAEXPAVgxInput@@@Z PROC		; gxRuntime::closeInput, COMDAT
; _this$ = ecx

; 707  : void gxRuntime::closeInput( gxInput *i ){

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 708  : 	if( !input || input!=i ) return;

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN3@closeInput
	cmp	ecx, DWORD PTR _i$[ebp]
	jne	SHORT $LN3@closeInput

; 195  : 	if( gfx_mode==3 && use_di ) input->unacquire();

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN9@closeInput
	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN9@closeInput
	call	?unacquire@gxInput@@QAEXXZ		; gxInput::unacquire
$LN9@closeInput:

; 196  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]
	push	edi
	call	?reset@gxInput@@QAEXXZ			; gxInput::reset

; 709  : 	unacquireInput();
; 710  : 	delete input;

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN12@closeInput
	mov	ecx, edi
	call	??1gxInput@@QAE@XZ			; gxInput::~gxInput
	push	8
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@closeInput:

; 711  : 	input=0;

	mov	DWORD PTR [esi+12], 0
	pop	edi
$LN3@closeInput:
	pop	esi

; 712  : }

	pop	ebp
	ret	4
?closeInput@gxRuntime@@QAEXPAVgxInput@@@Z ENDP		; gxRuntime::closeInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?openInput@gxRuntime@@QAEPAVgxInput@@H@Z
_TEXT	SEGMENT
$T2 = -20						; size = 4
_di$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flags$ = 8						; size = 4
?openInput@gxRuntime@@QAEPAVgxInput@@H@Z PROC		; gxRuntime::openInput, COMDAT
; _this$ = ecx

; 695  : gxInput *gxRuntime::openInput( int flags ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 8
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 696  : 	if( input ) return 0;

	cmp	DWORD PTR [esi+12], 0
	je	SHORT $LN2@openInput
	xor	eax, eax

; 705  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@openInput:

; 697  : 	IDirectInput7 *di;
; 698  : 	if( DirectInputCreateEx( hinst,DIRECTINPUT_VERSION,IID_IDirectInput7,(void**)&di,0 )>=0 ){

	push	0
	lea	eax, DWORD PTR _di$[ebp]
	push	eax
	push	OFFSET _IID_IDirectInput7A
	push	1792					; 00000700H
	push	DWORD PTR [esi+4]
	call	_DirectInputCreateEx@20
	test	eax, eax
	js	SHORT $LN3@openInput

; 699  : 		input=d_new gxInput( this,di );

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN6@openInput
	push	DWORD PTR _di$[ebp]
	mov	ecx, eax
	push	esi
	call	??0gxInput@@QAE@PAVgxRuntime@@PAUIDirectInput7A@@@Z ; gxInput::gxInput
	jmp	SHORT $LN7@openInput
$LN6@openInput:
	xor	eax, eax
$LN7@openInput:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [esi+12], eax

; 183  : 	if( !input ) return;

	test	eax, eax
	je	SHORT $LN4@openInput

; 184  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN12@openInput

; 185  : 		if( use_di ){

	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN12@openInput

; 186  : 			use_di=input->acquire();

	mov	ecx, eax
	call	?acquire@gxInput@@QAE_NXZ		; gxInput::acquire
	movzx	eax, al
	mov	DWORD PTR [esi+140], eax
$LN12@openInput:

; 187  : 		}else{
; 188  : 		}
; 189  : 	}
; 190  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]
	call	?reset@gxInput@@QAEXXZ			; gxInput::reset

; 700  : 		acquireInput();
; 701  : 	}else{

	jmp	SHORT $LN4@openInput
$LN3@openInput:

; 702  : 		debugInfo( "Create DirectInput failed" );

	push	OFFSET ??_C@_0BK@GCMBHDCF@Create?5DirectInput?5failed?$AA@
	mov	ecx, esi
	call	?debugInfo@gxRuntime@@QAEXPBD@Z		; gxRuntime::debugInfo
$LN4@openInput:

; 703  : 	}
; 704  : 	return input;

	mov	eax, DWORD PTR [esi+12]

; 705  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z$0:
	push	8
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?openInput@gxRuntime@@QAEPAVgxInput@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?openInput@gxRuntime@@QAEPAVgxInput@@H@Z ENDP		; gxRuntime::openInput
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?closeAudio@gxRuntime@@QAEXPAVgxAudio@@@Z
_TEXT	SEGMENT
_a$ = 8							; size = 4
?closeAudio@gxRuntime@@QAEXPAVgxAudio@@@Z PROC		; gxRuntime::closeAudio, COMDAT
; _this$ = ecx

; 686  : void gxRuntime::closeAudio( gxAudio *a ){

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi
	mov	edi, ecx

; 687  : 	if( !audio || audio!=a ) return;

	mov	esi, DWORD PTR [edi+8]
	test	esi, esi
	je	SHORT $LN3@closeAudio
	cmp	esi, DWORD PTR _a$[ebp]
	jne	SHORT $LN3@closeAudio

; 688  : 	delete audio;
; 689  : 	audio=0;

	mov	ecx, esi
	call	??1gxAudio@@QAE@XZ			; gxAudio::~gxAudio
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	DWORD PTR [edi+8], 0
$LN3@closeAudio:
	pop	edi
	pop	esi

; 690  : }

	pop	ebp
	ret	4
?closeAudio@gxRuntime@@QAEXPAVgxAudio@@@Z ENDP		; gxRuntime::closeAudio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z
_TEXT	SEGMENT
$T2 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_flags$ = 8						; size = 4
?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z PROC		; gxRuntime::openAudio, COMDAT
; _this$ = ecx

; 670  : gxAudio *gxRuntime::openAudio( int flags ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 671  : 	if( audio ) return 0;

	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN2@openAudio
$LN9@openAudio:
	xor	eax, eax

; 683  : 	return audio;
; 684  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@openAudio:

; 672  : 
; 673  : 	int f_flags=
; 674  : 		FSOUND_INIT_GLOBALFOCUS|
; 675  : 		FSOUND_INIT_USEDEFAULTMIDISYNTH;
; 676  : 
; 677  : 	FSOUND_SetHWND( hwnd );

	push	DWORD PTR [esi]
	call	_FSOUND_SetHWND@4

; 678  : 	if( !FSOUND_Init( 44100,1024,f_flags ) ){

	push	3
	push	1024					; 00000400H
	push	44100					; 0000ac44H
	call	_FSOUND_Init@12
	test	al, al
	je	SHORT $LN9@openAudio

; 679  : 		return 0;
; 680  : 	}
; 681  : 
; 682  : 	audio=d_new gxAudio( this );

	push	4
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN5@openAudio
	push	esi
	mov	ecx, eax
	call	??0gxAudio@@QAE@PAVgxRuntime@@@Z	; gxAudio::gxAudio
	jmp	SHORT $LN6@openAudio
$LN5@openAudio:
	xor	eax, eax
$LN6@openAudio:
	mov	DWORD PTR [esi+8], eax

; 683  : 	return audio;
; 684  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z$0:
	push	4
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?openAudio@gxRuntime@@QAEPAVgxAudio@@H@Z ENDP		; gxRuntime::openAudio
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?windowedModeInfo@gxRuntime@@QAEXPAH@Z
_TEXT	SEGMENT
_c$ = 8							; size = 4
?windowedModeInfo@gxRuntime@@QAEXPAH@Z PROC		; gxRuntime::windowedModeInfo, COMDAT
; _this$ = ecx

; 1099 : void gxRuntime::windowedModeInfo( int *c ){

	push	ebp
	mov	ebp, esp

; 1100 : 	int caps=0;
; 1101 : #ifdef PRO
; 1102 : 	int bd=0;
; 1103 : 	switch( desktop_desc.ddpfPixelFormat.dwRGBBitCount ){

	mov	eax, DWORD PTR ?desktop_desc@@3U_DDSURFACEDESC2@@A+84
	xor	edx, edx
	cmp	eax, 16					; 00000010H
	je	SHORT $LN4@windowedMo
	cmp	eax, 24					; 00000018H
	je	SHORT $LN5@windowedMo
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN2@windowedMo

; 1106 : 	case 32:bd=DDBD_32;break;

	mov	edx, 256				; 00000100H
	jmp	SHORT $LN2@windowedMo
$LN5@windowedMo:

; 1105 : 	case 24:bd=DDBD_24;break;

	mov	edx, 512				; 00000200H
	jmp	SHORT $LN2@windowedMo
$LN4@windowedMo:

; 1104 : 	case 16:bd=DDBD_16;break;

	mov	edx, 1024				; 00000400H
$LN2@windowedMo:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	eax, DWORD PTR [ecx+124]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1108 : 	if( drivers[0]->d3d_desc.dwDeviceRenderBitDepth & bd ) caps|=GFXMODECAPS_3D;

	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+156]

; 1109 : #endif
; 1110 : 	*c=caps;

	mov	eax, DWORD PTR _c$[ebp]
	and	ecx, edx
	neg	ecx
	sbb	ecx, ecx
	neg	ecx
	mov	DWORD PTR [eax], ecx

; 1111 : }

	pop	ebp
	ret	4
?windowedModeInfo@gxRuntime@@QAEXPAH@Z ENDP		; gxRuntime::windowedModeInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?graphicsModeInfo@gxRuntime@@QAEXHHPAH000@Z
_TEXT	SEGMENT
_driver$ = 8						; size = 4
_mode$ = 12						; size = 4
_w$ = 16						; size = 4
_h$ = 20						; size = 4
_d$ = 24						; size = 4
_c$ = 28						; size = 4
?graphicsModeInfo@gxRuntime@@QAEXHHPAH000@Z PROC	; gxRuntime::graphicsModeInfo, COMDAT
; _this$ = ecx

; 1080 : void gxRuntime::graphicsModeInfo( int driver,int mode,int *w,int *h,int *d,int *c ){

	push	ebp
	mov	ebp, esp

; 1081 : 	GfxDriver *g=drivers[driver];

	mov	ecx, DWORD PTR [ecx+124]
	mov	eax, DWORD PTR _driver$[ebp]
	push	esi
	push	edi

; 1082 : 	GfxMode *m=g->modes[mode];
; 1083 : 	int caps=0;
; 1084 : #ifdef PRO
; 1085 : 	int bd=0;

	xor	esi, esi
	mov	edx, DWORD PTR [ecx+eax*4]
	mov	eax, DWORD PTR _mode$[ebp]
	mov	ecx, DWORD PTR [edx+28]
	mov	edi, DWORD PTR [ecx+eax*4]

; 1086 : 	switch( m->desc.ddpfPixelFormat.dwRGBBitCount ){

	mov	eax, DWORD PTR [edi+84]
	cmp	eax, 16					; 00000010H
	je	SHORT $LN4@graphicsMo
	cmp	eax, 24					; 00000018H
	je	SHORT $LN5@graphicsMo
	cmp	eax, 32					; 00000020H
	jne	SHORT $LN2@graphicsMo

; 1089 : 	case 32:bd=DDBD_32;break;

	mov	esi, 256				; 00000100H
	jmp	SHORT $LN2@graphicsMo
$LN5@graphicsMo:

; 1088 : 	case 24:bd=DDBD_24;break;

	mov	esi, 512				; 00000200H
	jmp	SHORT $LN2@graphicsMo
$LN4@graphicsMo:

; 1087 : 	case 16:bd=DDBD_16;break;

	mov	esi, 1024				; 00000400H
$LN2@graphicsMo:

; 1090 : 	}
; 1091 : 	if( g->d3d_desc.dwDeviceRenderBitDepth & bd ) caps|=GFXMODECAPS_3D;

	mov	edx, DWORD PTR [edx+156]

; 1092 : #endif
; 1093 : 	*w=m->desc.dwWidth;

	mov	ecx, DWORD PTR [edi+12]
	and	edx, esi
	mov	eax, DWORD PTR _w$[ebp]
	neg	edx
	sbb	edx, edx
	neg	edx
	mov	DWORD PTR [eax], ecx

; 1094 : 	*h=m->desc.dwHeight;

	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, DWORD PTR [edi+8]
	mov	DWORD PTR [eax], ecx

; 1095 : 	*d=m->desc.ddpfPixelFormat.dwRGBBitCount;

	mov	eax, DWORD PTR _d$[ebp]
	mov	ecx, DWORD PTR [edi+84]
	pop	edi
	pop	esi
	mov	DWORD PTR [eax], ecx

; 1096 : 	*c=caps;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], edx

; 1097 : }

	pop	ebp
	ret	24					; 00000018H
?graphicsModeInfo@gxRuntime@@QAEXHHPAH000@Z ENDP	; gxRuntime::graphicsModeInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?numGraphicsModes@gxRuntime@@QAEHH@Z
_TEXT	SEGMENT
_driver$ = 8						; size = 4
?numGraphicsModes@gxRuntime@@QAEHH@Z PROC		; gxRuntime::numGraphicsModes, COMDAT
; _this$ = ecx

; 1076 : int gxRuntime::numGraphicsModes( int driver ){

	push	ebp
	mov	ebp, esp

; 1077 : 	return drivers[driver]->modes.size();

	mov	eax, DWORD PTR _driver$[ebp]
	mov	ecx, DWORD PTR [ecx+124]
	mov	ecx, DWORD PTR [ecx+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+32]
	sub	eax, DWORD PTR [ecx+28]
	sar	eax, 2
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1078 : }

	pop	ebp
	ret	4
?numGraphicsModes@gxRuntime@@QAEHH@Z ENDP		; gxRuntime::numGraphicsModes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?graphicsDriverInfo@gxRuntime@@QAEXHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z
_TEXT	SEGMENT
_driver$ = 8						; size = 4
_name$ = 12						; size = 4
_c$ = 16						; size = 4
?graphicsDriverInfo@gxRuntime@@QAEXHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z PROC ; gxRuntime::graphicsDriverInfo, COMDAT
; _this$ = ecx

; 1066 : void gxRuntime::graphicsDriverInfo( int driver,string *name,int *c ){

	push	ebp
	mov	ebp, esp

; 1067 : 	GfxDriver *g=drivers[driver];

	mov	ecx, DWORD PTR [ecx+124]
	mov	eax, DWORD PTR _driver$[ebp]
	push	ebx
	xor	ebx, ebx
	mov	eax, DWORD PTR [ecx+eax*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	mov	ecx, DWORD PTR _name$[ebp]
	cmp	DWORD PTR [eax+156], ebx
	setne	bl
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1072 : 	*name=g->name;

	add	eax, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	ecx, eax
	je	SHORT $LN150@graphicsDr

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN150@graphicsDr:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1073 : 	*c=caps;

	mov	eax, DWORD PTR _c$[ebp]
	mov	DWORD PTR [eax], ebx
	pop	ebx

; 1074 : }

	pop	ebp
	ret	12					; 0000000cH
?graphicsDriverInfo@gxRuntime@@QAEXHPAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAH@Z ENDP ; gxRuntime::graphicsDriverInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?numGraphicsDrivers@gxRuntime@@QAEHXZ
_TEXT	SEGMENT
?numGraphicsDrivers@gxRuntime@@QAEHXZ PROC		; gxRuntime::numGraphicsDrivers, COMDAT
; _this$ = ecx

; 1058 : int gxRuntime::numGraphicsDrivers(){

	push	esi
	mov	esi, ecx

; 1059 : 	if( !enum_all ){

	cmp	BYTE PTR [esi+120], 0
	jne	SHORT $LN6@numGraphic

; 1060 : 		enum_all=true;

	mov	BYTE PTR [esi+120], 1

; 1040 : 	denumGfx();

	call	?denumGfx@gxRuntime@@AAEXXZ		; gxRuntime::denumGfx

; 1041 : 	if( enum_all ){

	cmp	BYTE PTR [esi+120], 0

; 1042 : 		DirectDrawEnumerateEx( enumDriver,&drivers,DDENUM_ATTACHEDSECONDARYDEVICES|DDENUM_NONDISPLAYDEVICES );

	lea	eax, DWORD PTR [esi+124]
	je	SHORT $LN5@numGraphic
	push	5

; 1043 : 	}else{

	jmp	SHORT $LN29@numGraphic
$LN5@numGraphic:

; 1044 : 		DirectDrawEnumerateEx( enumDriver,&drivers,0 );

	push	0
$LN29@numGraphic:
	push	eax
	push	OFFSET ?enumDriver@@YGHPAU_GUID@@PAD1PAXPAUHMONITOR__@@@Z ; enumDriver
	call	_DirectDrawEnumerateExA@12
$LN6@numGraphic:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+128]
	sub	eax, DWORD PTR [esi+124]
	sar	eax, 2
	pop	esi
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1064 : }

	ret	0
?numGraphicsDrivers@gxRuntime@@QAEHXZ ENDP		; gxRuntime::numGraphicsDrivers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?debugLog@gxRuntime@@QAEXPBD@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?debugLog@gxRuntime@@QAEXPBD@Z PROC			; gxRuntime::debugLog, COMDAT
; _this$ = ecx

; 594  : void gxRuntime::debugLog( const char *t ){

	push	ebp
	mov	ebp, esp

; 595  : 	if( debugger ) debugger->debugLog( t );

	mov	ecx, DWORD PTR ?debugger@@3PAVDebugger@@A
	test	ecx, ecx
	je	SHORT $LN2@debugLog
	mov	eax, DWORD PTR [ecx]

; 596  : }

	pop	ebp

; 595  : 	if( debugger ) debugger->debugLog( t );

	jmp	DWORD PTR [eax+20]
$LN2@debugLog:

; 596  : }

	pop	ebp
	ret	4
?debugLog@gxRuntime@@QAEXPBD@Z ENDP			; gxRuntime::debugLog
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?debugError@gxRuntime@@QAEXPBD@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?debugError@gxRuntime@@QAEXPBD@Z PROC			; gxRuntime::debugError, COMDAT
; _this$ = ecx

; 568  : void gxRuntime::debugError( const char *t ){

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 569  : 	if( !debugger ) return;

	mov	edi, DWORD PTR ?debugger@@3PAVDebugger@@A
	mov	esi, ecx
	test	edi, edi
	je	SHORT $LN1@debugError

; 491  : 	PostMessage( hwnd,WM_END,0,0 );

	push	0
	push	0
	push	1027					; 00000403H
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__PostMessageA@16

; 570  : 	Debugger *d=debugger;
; 571  : 	asyncEnd();
; 572  : 	if( !suspended ){

	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	SHORT $LN9@debugError

; 234  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN8@debugError

; 235  : 		SetForegroundWindow( GetDesktopWindow() );

	mov	esi, DWORD PTR __imp__GetDesktopWindow@0
	call	esi
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 236  : 		ShowWindow( GetDesktopWindow(),SW_SHOW );

	push	5
	call	esi
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 573  : 		forceSuspend();
; 574  : 	}
; 575  : 	d->debugMsg( t,true );

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	1
	push	DWORD PTR _t$[ebp]
	call	DWORD PTR [eax+24]
	pop	edi
	pop	esi

; 576  : }

	pop	ebp
	ret	4
$LN8@debugError:

; 238  : 		suspend();

	mov	ecx, esi
	call	?suspend@gxRuntime@@AAEXXZ		; gxRuntime::suspend
$LN9@debugError:

; 573  : 		forceSuspend();
; 574  : 	}
; 575  : 	d->debugMsg( t,true );

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	1
	push	DWORD PTR _t$[ebp]
	call	DWORD PTR [eax+24]
$LN1@debugError:
	pop	edi
	pop	esi

; 576  : }

	pop	ebp
	ret	4
?debugError@gxRuntime@@QAEXPBD@Z ENDP			; gxRuntime::debugError
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?debugInfo@gxRuntime@@QAEXPBD@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?debugInfo@gxRuntime@@QAEXPBD@Z PROC			; gxRuntime::debugInfo, COMDAT
; _this$ = ecx

; 581  : void gxRuntime::debugInfo( const char *t ){

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 582  : 	if( !debugger ) return;

	mov	edi, DWORD PTR ?debugger@@3PAVDebugger@@A
	mov	esi, ecx
	test	edi, edi
	je	SHORT $LN1@debugInfo

; 491  : 	PostMessage( hwnd,WM_END,0,0 );

	push	0
	push	0
	push	1027					; 00000403H
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__PostMessageA@16

; 583  : 	Debugger *d=debugger;
; 584  : 	asyncEnd();
; 585  : 	if( !suspended ){

	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	SHORT $LN9@debugInfo

; 234  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN8@debugInfo

; 235  : 		SetForegroundWindow( GetDesktopWindow() );

	mov	esi, DWORD PTR __imp__GetDesktopWindow@0
	call	esi
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 236  : 		ShowWindow( GetDesktopWindow(),SW_SHOW );

	push	5
	call	esi
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 586  : 		forceSuspend();
; 587  : 	}
; 588  : 	d->debugMsg( t,false );

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	0
	push	DWORD PTR _t$[ebp]
	call	DWORD PTR [eax+24]
	pop	edi
	pop	esi

; 589  : }

	pop	ebp
	ret	4
$LN8@debugInfo:

; 238  : 		suspend();

	mov	ecx, esi
	call	?suspend@gxRuntime@@AAEXXZ		; gxRuntime::suspend
$LN9@debugInfo:

; 586  : 		forceSuspend();
; 587  : 	}
; 588  : 	d->debugMsg( t,false );

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	0
	push	DWORD PTR _t$[ebp]
	call	DWORD PTR [eax+24]
$LN1@debugInfo:
	pop	edi
	pop	esi

; 589  : }

	pop	ebp
	ret	4
?debugInfo@gxRuntime@@QAEXPBD@Z ENDP			; gxRuntime::debugInfo
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?debugLeave@gxRuntime@@QAEXXZ
_TEXT	SEGMENT
?debugLeave@gxRuntime@@QAEXXZ PROC			; gxRuntime::debugLeave, COMDAT
; _this$ = ecx

; 562  : 	if( debugger ) debugger->debugLeave();

	mov	ecx, DWORD PTR ?debugger@@3PAVDebugger@@A
	test	ecx, ecx
	je	SHORT $LN2@debugLeave
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+16]
$LN2@debugLeave:

; 563  : }

	ret	0
?debugLeave@gxRuntime@@QAEXXZ ENDP			; gxRuntime::debugLeave
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?debugEnter@gxRuntime@@QAEXPAX0PBD@Z
_TEXT	SEGMENT
_frame$ = 8						; size = 4
_env$ = 12						; size = 4
_func$ = 16						; size = 4
?debugEnter@gxRuntime@@QAEXPAX0PBD@Z PROC		; gxRuntime::debugEnter, COMDAT
; _this$ = ecx

; 554  : void gxRuntime::debugEnter( void *frame,void *env,const char *func ){

	push	ebp
	mov	ebp, esp

; 555  : 	if( debugger ) debugger->debugEnter( frame,env,func );

	mov	ecx, DWORD PTR ?debugger@@3PAVDebugger@@A
	test	ecx, ecx
	je	SHORT $LN2@debugEnter
	mov	eax, DWORD PTR [ecx]

; 556  : }

	pop	ebp

; 555  : 	if( debugger ) debugger->debugEnter( frame,env,func );

	jmp	DWORD PTR [eax+12]
$LN2@debugEnter:

; 556  : }

	pop	ebp
	ret	12					; 0000000cH
?debugEnter@gxRuntime@@QAEXPAX0PBD@Z ENDP		; gxRuntime::debugEnter
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?debugStmt@gxRuntime@@QAEXHPBD@Z
_TEXT	SEGMENT
_pos$ = 8						; size = 4
_file$ = 12						; size = 4
?debugStmt@gxRuntime@@QAEXHPBD@Z PROC			; gxRuntime::debugStmt, COMDAT
; _this$ = ecx

; 540  : void gxRuntime::debugStmt( int pos,const char *file ){

	push	ebp
	mov	ebp, esp

; 541  : 	if( debugger ) debugger->debugStmt( pos,file );

	mov	ecx, DWORD PTR ?debugger@@3PAVDebugger@@A
	test	ecx, ecx
	je	SHORT $LN2@debugStmt
	mov	eax, DWORD PTR [ecx]

; 542  : }

	pop	ebp

; 541  : 	if( debugger ) debugger->debugStmt( pos,file );

	jmp	DWORD PTR [eax+8]
$LN2@debugStmt:

; 542  : }

	pop	ebp
	ret	8
?debugStmt@gxRuntime@@QAEXHPBD@Z ENDP			; gxRuntime::debugStmt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?debugStop@gxRuntime@@QAEXXZ
_TEXT	SEGMENT
?debugStop@gxRuntime@@QAEXXZ PROC			; gxRuntime::debugStop, COMDAT
; _this$ = ecx

; 548  : 	if( !suspended ) forceSuspend();

	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	SHORT $LN6@debugStop

; 234  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN5@debugStop

; 235  : 		SetForegroundWindow( GetDesktopWindow() );

	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 236  : 		ShowWindow( GetDesktopWindow(),SW_SHOW );

	push	5
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__ShowWindow@8
$LN6@debugStop:

; 549  : }

	ret	0
$LN5@debugStop:

; 238  : 		suspend();

	jmp	?suspend@gxRuntime@@AAEXXZ		; gxRuntime::suspend
?debugStop@gxRuntime@@QAEXXZ ENDP			; gxRuntime::debugStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z
_TEXT	SEGMENT
$T2 = -364						; size = 4
__Ch$ = -356						; size = 1
$T3 = -352						; size = 24
_t$4 = -328						; size = 24
_t$ = -304						; size = 24
_buff$ = -280						; size = 261
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_p$ = 12						; size = 4
?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z PROC ; gxRuntime::systemProperty, COMDAT
; _this$ = ecx

; 1130 : string gxRuntime::systemProperty( const std::string &p ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 352				; 00000160H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	eax, DWORD PTR _p$[ebp]
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 1132 : 	string t=tolower(p);

	push	eax
	lea	eax, DWORD PTR _t$[ebp]
	mov	DWORD PTR $T2[ebp], 0
	push	eax
	call	?tolower@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV12@@Z ; tolower
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _t$[ebp+20], 16		; 00000010H
	lea	ecx, DWORD PTR _t$[ebp]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	ebx, DWORD PTR _t$[ebp+16]
	mov	eax, 3

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmovae	ecx, DWORD PTR _t$[ebp]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	ebx, eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1132 : 	string t=tolower(p);

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmovb	eax, ebx

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	OFFSET ??_C@_03PBJBJNON@cpu?$AA@
	push	ecx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN12@systemProp

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	ebx, 3
	jb	SHORT $LN12@systemProp

; 2102 : 			return (-1);
; 2103 : 
; 2104 : 		if (_Left_size > _Right_size)

	ja	SHORT $LN12@systemProp

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	5

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	mov	ecx, esi

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	OFFSET ??_C@_05CDGBNGHP@Intel?$AA@
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], al
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	ecx, DWORD PTR _t$[ebp+20]
	cmp	ecx, 16					; 00000010H
	jb	$LN461@systemProp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	ecx
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1134 : 		return "Intel";

	jmp	$LN562@systemProp
$LN12@systemProp:

; 1135 : 	}else if( t=="os" ){

	push	OFFSET ??_C@_02EHCHIAMF@os?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	$LN14@systemProp

; 1136 : 		switch( osinfo.dwMajorVersion ){

	mov	eax, DWORD PTR [edi+148]
	add	eax, -3					; fffffffdH
	cmp	eax, 3
	ja	$LN56@systemProp
	jmp	DWORD PTR $LN565@systemProp[eax*4]
$LN16@systemProp:

; 1137 : 		case 3:
; 1138 : 			switch( osinfo.dwMinorVersion ){

	cmp	DWORD PTR [edi+152], 51			; 00000033H
	jne	$LN56@systemProp

; 1139 : 			case 51:return "Windows NT 3.1";

	push	OFFSET ??_C@_0P@HDGFNHEP@Windows?5NT?53?41?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN18@systemProp:

; 1140 : 			}
; 1141 : 			break;
; 1142 : 		case 4:
; 1143 : 			switch( osinfo.dwMinorVersion ){

	mov	eax, DWORD PTR [edi+152]
	test	eax, eax
	je	SHORT $LN19@systemProp
	cmp	eax, 10					; 0000000aH
	je	SHORT $LN20@systemProp
	cmp	eax, 90					; 0000005aH
	jne	$LN56@systemProp

; 1146 : 			case 90:return "Windows ME";

	push	OFFSET ??_C@_0L@KINKMMPO@Windows?5ME?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN20@systemProp:

; 1145 : 			case 10:return "Windows 98";

	push	OFFSET ??_C@_0L@GBLDALMJ@Windows?598?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN19@systemProp:

; 1144 : 			case 0:return "Windows 95";

	push	OFFSET ??_C@_0L@NEBNHFIE@Windows?595?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN22@systemProp:

; 1147 : 			}
; 1148 : 			break;
; 1149 : 		case 5:
; 1150 : 			switch( osinfo.dwMinorVersion ){

	mov	eax, DWORD PTR [edi+152]
	sub	eax, 0
	je	SHORT $LN23@systemProp
	sub	eax, 1
	je	SHORT $LN24@systemProp
	sub	eax, 1
	jne	$LN56@systemProp

; 1153 : 			case 2:return "Windows Server 2003";

	push	OFFSET ??_C@_0BE@IEOLCCDL@Windows?5Server?52003?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN24@systemProp:

; 1152 : 			case 1:return "Windows XP";

	push	OFFSET ??_C@_0L@IFICELHB@Windows?5XP?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN23@systemProp:

; 1151 : 			case 0:return "Windows 2000";

	push	OFFSET ??_C@_0N@MEKDBOKB@Windows?52000?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN26@systemProp:

; 1154 : 			}
; 1155 : 			break;
; 1156 : 		case 6:
; 1157 : 			switch( osinfo.dwMinorVersion ){

	mov	eax, DWORD PTR [edi+152]
	sub	eax, 0
	je	SHORT $LN27@systemProp
	sub	eax, 1
	jne	$LN56@systemProp

; 1159 : 			case 1:return "Windows 7";

	push	OFFSET ??_C@_09GOHFIPMO@Windows?57?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN27@systemProp:

; 1158 : 			case 0:return "Windows Vista";

	push	OFFSET ??_C@_0O@IFKHFILP@Windows?5Vista?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN14@systemProp:

; 1160 : 			}
; 1161 : 			break;
; 1162 : 		}
; 1163 : 	}else if( t=="appdir" ){

	push	OFFSET ??_C@_06FDOJABFB@appdir?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	$LN29@systemProp

; 1164 : 		if( GetModuleFileName( 0,buff,MAX_PATH ) ){

	push	260					; 00000104H
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	push	0
	call	DWORD PTR __imp__GetModuleFileNameA@12
	test	eax, eax
	je	$LN56@systemProp

; 1165 : 			string t=buff;

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$4[ebp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2013 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));

	push	1
	push	-1
	lea	eax, DWORD PTR __Ch$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1165 : 			string t=buff;

	mov	BYTE PTR __$EHRec$[ebp+8], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2013 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));

	push	eax
	lea	ecx, DWORD PTR _t$4[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1166 : 			int n=t.find_last_of( '\\' );

	mov	BYTE PTR __Ch$[ebp], 92			; 0000005cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2013 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));

	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1167 : 			if( n!=string::npos ) t=t.substr( 0,n );

	cmp	eax, -1
	je	SHORT $LN32@systemProp
	push	eax
	push	0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _t$4[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	push	eax
	lea	ecx, DWORD PTR _t$4[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN32@systemProp:

; 1168 : 			return toDir( t );

	sub	esp, 24					; 00000018H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	lea	eax, DWORD PTR _t$4[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1168 : 			return toDir( t );

	mov	ecx, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 782  : 		assign(_Right, 0, npos);

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1168 : 			return toDir( t );

	push	esi
	call	?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ; toDir
	lea	ecx, DWORD PTR _t$4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN29@systemProp:

; 1169 : 		}
; 1170 : 	}else if( t=="apphwnd" ){

	push	OFFSET ??_C@_07HNKELBHJ@apphwnd?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN33@systemProp

; 1171 : 		return itoa( (int)hwnd );

	push	DWORD PTR [edi]
	push	esi
	call	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; itoa
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN33@systemProp:

; 1172 : 	}else if( t=="apphinstance" ){

	push	OFFSET ??_C@_0N@GOJEBJGE@apphinstance?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN35@systemProp

; 1173 : 		return itoa( (int)hinst );

	push	DWORD PTR [edi+4]
	push	esi
	call	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; itoa
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN35@systemProp:

; 1174 : 	}else if( t=="windowsdir" ){

	push	OFFSET ??_C@_0L@JFHDMCEL@windowsdir?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN37@systemProp

; 1175 : 		if( GetWindowsDirectory( buff,MAX_PATH ) ) return toDir( buff );

	push	260					; 00000104H
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	DWORD PTR __imp__GetWindowsDirectoryA@8
$LN563@systemProp:
	test	eax, eax
	je	$LN56@systemProp
	sub	esp, 24					; 00000018H
	lea	eax, DWORD PTR _buff$[ebp]
	mov	ecx, esp
	push	eax
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	push	esi
	call	?toDir@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@V12@@Z ; toDir
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN37@systemProp:

; 1176 : 	}else if( t=="systemdir" ){

	push	OFFSET ??_C@_09LACDBIEN@systemdir?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN40@systemProp

; 1177 : 		if( GetSystemDirectory( buff,MAX_PATH ) ) return toDir( buff );

	push	260					; 00000104H
	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	call	DWORD PTR __imp__GetSystemDirectoryA@8
	jmp	SHORT $LN563@systemProp
$LN40@systemProp:

; 1178 : 	}else if( t=="tempdir" ){

	push	OFFSET ??_C@_07MILKKLHK@tempdir?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN43@systemProp

; 1179 : 		if( GetTempPath( MAX_PATH,buff ) ) return toDir( buff );

	lea	eax, DWORD PTR _buff$[ebp]
	push	eax
	push	260					; 00000104H
	call	DWORD PTR __imp__GetTempPathA@8
	jmp	$LN563@systemProp
$LN43@systemProp:

; 1180 : 	}else if( t=="direct3d7" ){

	push	OFFSET ??_C@_09LMDHFOKP@direct3d7?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN46@systemProp

; 1181 : 		if( graphics ) return itoa( (int)graphics->dir3d );

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	$LN56@systemProp
	push	DWORD PTR [eax+8]
	push	esi
	call	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; itoa
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN46@systemProp:

; 1182 : 	}else if( t=="direct3ddevice7" ){

	push	OFFSET ??_C@_0BA@HCCHIIGI@direct3ddevice7?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN49@systemProp

; 1183 : 		if( graphics ) return itoa( (int)graphics->dir3dDev );

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN56@systemProp
	push	DWORD PTR [eax+12]
	push	esi
	call	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; itoa
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	$LN461@systemProp
$LN49@systemProp:

; 1184 : 	}else if( t=="directdraw7" ){

	push	OFFSET ??_C@_0M@HELILEBA@directdraw7?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN52@systemProp

; 1185 : 		if( graphics ) return itoa( (int)graphics->dirDraw );

	mov	eax, DWORD PTR [edi+16]
	test	eax, eax
	je	SHORT $LN56@systemProp
	push	DWORD PTR [eax]
	push	esi
	call	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; itoa
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN461@systemProp
$LN52@systemProp:

; 1186 : 	}else if( t=="directinput7" ){

	push	OFFSET ??_C@_0N@BNFCOOOE@directinput7?$AA@
	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	call	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
	test	al, al
	je	SHORT $LN56@systemProp

; 1187 : 		if( input ) return itoa( (int)input->dirInput );

	mov	eax, DWORD PTR [edi+12]
	test	eax, eax
	je	SHORT $LN56@systemProp
	push	DWORD PTR [eax+4]
	push	esi
	call	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; itoa
	lea	ecx, DWORD PTR _t$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN461@systemProp
$LN56@systemProp:

; 1189 : 	return "";

	push	OFFSET ??_C@_00CNPNBAHC@?$AA@
	mov	ecx, esi
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _t$[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN461@systemProp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
$LN562@systemProp:
	push	DWORD PTR _t$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN461@systemProp:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1189 : 	return "";

	mov	eax, esi

; 1190 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
	npad	3
$LN565@systemProp:
	DD	$LN16@systemProp
	DD	$LN18@systemProp
	DD	$LN22@systemProp
	DD	$LN26@systemProp
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z$0:
	lea	ecx, DWORD PTR _t$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z$2:
	lea	ecx, DWORD PTR _t$4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-368]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?systemProperty@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@ABV23@@Z ENDP ; gxRuntime::systemProperty
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?commandLine@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
?commandLine@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; gxRuntime::commandLine, COMDAT
; _this$ = ecx

; 601  : string gxRuntime::commandLine(){

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 602  : 	return cmd_line;

	add	ecx, 44					; 0000002cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 782  : 		assign(_Right, 0, npos);

	mov	ecx, esi

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR $T1[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 602  : 	return cmd_line;

	mov	eax, esi
	pop	esi

; 603  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?commandLine@gxRuntime@@QAE?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; gxRuntime::commandLine
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?setPointerVisible@gxRuntime@@QAEX_N@Z
_TEXT	SEGMENT
_pt$ = -8						; size = 8
_vis$ = 8						; size = 1
?setPointerVisible@gxRuntime@@QAEX_N@Z PROC		; gxRuntime::setPointerVisible, COMDAT
; _this$ = ecx

; 655  : void gxRuntime::setPointerVisible( bool vis ){

	push	ebp
	mov	ebp, esp

; 656  : 	if( pointer_visible==vis ) return;

	mov	al, BYTE PTR _vis$[ebp]
	sub	esp, 8
	cmp	BYTE PTR [ecx+68], al
	je	SHORT $LN1@setPointer

; 657  : 
; 658  : 	pointer_visible=vis;
; 659  : 	if( gfx_mode==3 ) return;

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	mov	BYTE PTR [ecx+68], al
	je	SHORT $LN1@setPointer

; 660  : 
; 661  : 	//force a WM_SETCURSOR
; 662  : 	POINT pt;
; 663  : 	GetCursorPos( &pt );

	lea	eax, DWORD PTR _pt$[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 664  : 	SetCursorPos( pt.x,pt.y );

	push	DWORD PTR _pt$[ebp+4]
	push	DWORD PTR _pt$[ebp]
	call	DWORD PTR __imp__SetCursorPos@8
$LN1@setPointer:

; 665  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?setPointerVisible@gxRuntime@@QAEX_N@Z ENDP		; gxRuntime::setPointerVisible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?getMilliSecs@gxRuntime@@QAEHXZ
_TEXT	SEGMENT
?getMilliSecs@gxRuntime@@QAEHXZ PROC			; gxRuntime::getMilliSecs, COMDAT
; _this$ = ecx

; 649  : 	return timeGetTime();

	jmp	DWORD PTR __imp__timeGetTime@0
?getMilliSecs@gxRuntime@@QAEHXZ ENDP			; gxRuntime::getMilliSecs
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?setTitle@gxRuntime@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
_e$ = 12						; size = 4
?setTitle@gxRuntime@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; gxRuntime::setTitle, COMDAT
; _this$ = ecx

; 639  : void gxRuntime::setTitle( const string &t,const string &e ){

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	mov	eax, DWORD PTR _t$[ebp]
	push	esi
	push	edi
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 639  : void gxRuntime::setTitle( const string &t,const string &e ){

	mov	edi, ecx

; 640  : 	app_title=t;

	lea	esi, DWORD PTR [edi+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	esi, eax
	je	SHORT $LN4@setTitle

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN4@setTitle:

; 1024 : 		if (this != &_Right)

	mov	eax, DWORD PTR _e$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 641  : 	app_close=e;

	lea	ecx, DWORD PTR [edi+96]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1024 : 		if (this != &_Right)

	cmp	ecx, eax
	je	SHORT $LN139@setTitle

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN139@setTitle:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN286@setTitle
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN286@setTitle:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 642  : 	SetWindowText( hwnd,app_title.c_str() );

	push	esi
	push	DWORD PTR [edi]
	call	DWORD PTR __imp__SetWindowTextA@8
	pop	edi
	pop	esi

; 643  : }

	pop	ebp
	ret	8
?setTitle@gxRuntime@@QAEXABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; gxRuntime::setTitle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
__Ch$ = -92						; size = 1
__Ch$ = -92						; size = 1
__Ch$ = -92						; size = 1
$T2 = -88						; size = 24
$T3 = -88						; size = 24
$T4 = -88						; size = 24
$T5 = -88						; size = 24
$T6 = -88						; size = 24
$T7 = -88						; size = 24
_cmd$ = -64						; size = 24
_params$ = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_cmd_line$ = 8						; size = 4
?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; gxRuntime::execute, COMDAT
; _this$ = ecx

; 608  : bool gxRuntime::execute( const string &cmd_line ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, DWORD PTR _cmd_line$[ebp]

; 609  : 
; 610  : 	if( !cmd_line.size() ) return false;

	cmp	DWORD PTR [eax+16], 0
	jne	SHORT $LN8@execute
	xor	al, al
	jmp	$LN1@execute
$LN8@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _cmd$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _cmd$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _cmd$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 613  : 	string cmd=cmd_line,params;

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _params$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _params$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _params$[ebp], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 614  : 	while( cmd.size() && cmd[0]==' ' ) cmd=cmd.substr( 1 );

	cmp	DWORD PTR _cmd$[ebp+16], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	je	$LN3@execute
$LL2@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _cmd$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR _cmd$[ebp]
	cmovae	eax, DWORD PTR _cmd$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 614  : 	while( cmd.size() && cmd[0]==' ' ) cmd=cmd.substr( 1 );

	cmp	BYTE PTR [eax], 32			; 00000020H
	jne	$LN3@execute
	push	-1
	push	1
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 929  : 		if (this != &_Right)

	lea	eax, DWORD PTR _cmd$[ebp]
	cmp	eax, esi
	je	SHORT $LN838@execute

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _cmd$[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN315@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _cmd$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN315@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _cmd$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _cmd$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _cmd$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN604@execute

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN605@execute
	push	eax
	lea	eax, DWORD PTR _cmd$[ebp]
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN605@execute
$LN604@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _cmd$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN605@execute:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _cmd$[ebp+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _cmd$[ebp+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN834@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN834@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LN838@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T7[ebp+20]

; 943  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN846@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T7[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN846@execute:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 614  : 	while( cmd.size() && cmd[0]==' ' ) cmd=cmd.substr( 1 );

	cmp	DWORD PTR _cmd$[ebp+16], 0
	jne	$LL2@execute
$LN3@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	push	1
	push	0
	lea	eax, DWORD PTR __Ch$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 615  : 	if( cmd.find( '\"' )==0 ){

	mov	BYTE PTR __Ch$[ebp], 34			; 00000022H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 615  : 	if( cmd.find( '\"' )==0 ){

	test	eax, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	lea	ecx, DWORD PTR _cmd$[ebp]
	push	1
	lea	eax, DWORD PTR __Ch$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 615  : 	if( cmd.find( '\"' )==0 ){

	jne	SHORT $LN9@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	push	1
	push	eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 616  : 		int n=cmd.find( '\"',1 );

	mov	BYTE PTR __Ch$[ebp], 34			; 00000022H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 616  : 		int n=cmd.find( '\"',1 );

	mov	esi, eax

; 617  : 		if( n!=string::npos ){

	cmp	esi, -1
	je	$LN2121@execute

; 618  : 			params=cmd.substr( n+1 );

	push	-1
	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	lea	eax, DWORD PTR $T6[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	push	eax
	lea	ecx, DWORD PTR _params$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 619  : 			cmd=cmd.substr( 1,n-1 );

	lea	eax, DWORD PTR [esi-1]
	push	eax
	push	1

; 620  : 		}
; 621  : 	}else{

	jmp	SHORT $LN2138@execute
$LN9@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	push	0
	push	eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 622  : 		int n=cmd.find( ' ' );

	mov	BYTE PTR __Ch$[ebp], 32			; 00000020H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 622  : 		int n=cmd.find( ' ' );

	mov	esi, eax

; 623  : 		if( n!=string::npos ){

	cmp	esi, -1
	je	SHORT $LN2121@execute

; 624  : 			params=cmd.substr( n+1 );

	push	-1
	lea	ecx, DWORD PTR [esi+1]
	push	ecx
	lea	eax, DWORD PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	push	eax
	lea	ecx, DWORD PTR _params$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T5[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 625  : 			cmd=cmd.substr( 0,n );

	push	esi
	push	0
$LN2138@execute:
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	push	eax
	lea	ecx, DWORD PTR _cmd$[ebp]
	call	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2121@execute:

; 628  : 	while( params.size() && params[0]==' ' ) params=params.substr( 1 );

	mov	ecx, DWORD PTR _params$[ebp+16]
	test	ecx, ecx
	je	$LN2134@execute
$LL4@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, DWORD PTR _params$[ebp+20]
	lea	eax, DWORD PTR _params$[ebp]
	mov	esi, DWORD PTR _params$[ebp]
	cmp	edx, 16					; 00000010H
	cmovae	eax, esi
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 628  : 	while( params.size() && params[0]==' ' ) params=params.substr( 1 );

	cmp	BYTE PTR [eax], 32			; 00000020H
	jne	$LN2122@execute
	push	-1
	push	1
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	lea	ecx, DWORD PTR _params$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 929  : 		if (this != &_Right)

	lea	eax, DWORD PTR _params$[ebp]
	cmp	eax, esi
	je	SHORT $LN1512@execute

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _params$[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN989@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _params$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN989@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _params$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _params$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _params$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN1278@execute

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN1279@execute
	push	eax
	lea	eax, DWORD PTR _params$[ebp]
	push	esi
	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN1279@execute
$LN1278@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _params$[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN1279@execute:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR _params$[ebp+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR _params$[ebp+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN1508@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN1508@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
$LN1512@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T3[ebp+20]

; 943  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN1520@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T3[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN1520@execute:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 628  : 	while( params.size() && params[0]==' ' ) params=params.substr( 1 );

	mov	ecx, DWORD PTR _params$[ebp+16]
	test	ecx, ecx
	jne	$LL4@execute
$LN2134@execute:

; 630  : 
; 631  : 	SetForegroundWindow( GetDesktopWindow() );

	mov	esi, DWORD PTR __imp__GetDesktopWindow@0
	call	esi
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 633  : 	return (int)ShellExecute( GetDesktopWindow(),0,cmd.c_str(),params.size() ? params.c_str() : 0,0,SW_SHOW )>32;

	cmp	DWORD PTR _params$[ebp+16], 0
	je	$LN14@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _params$[ebp+20], 16		; 00000010H
	lea	ecx, DWORD PTR _params$[ebp]
	cmovae	ecx, DWORD PTR _params$[ebp]

; 1744 : 		}

	jmp	$LN15@execute
$LN2122@execute:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 629  : 	while( params.size() && params[params.size()-1]==' ' ) params=params.substr( 0,params.size()-1 );

	test	ecx, ecx
	je	SHORT $LN2134@execute
	npad	5
$LL6@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	edx, 16					; 00000010H
	lea	eax, DWORD PTR _params$[ebp]
	cmovae	eax, esi
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 629  : 	while( params.size() && params[params.size()-1]==' ' ) params=params.substr( 0,params.size()-1 );

	cmp	BYTE PTR [eax+ecx-1], 32		; 00000020H
	jne	SHORT $LN2134@execute
	lea	eax, DWORD PTR [ecx-1]
	push	eax
	push	0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	lea	ecx, DWORD PTR _params$[ebp]
	call	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
	mov	esi, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 929  : 		if (this != &_Right)

	lea	eax, DWORD PTR _params$[ebp]
	cmp	eax, esi
	je	SHORT $LN1675@execute

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR _params$[ebp+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN1681@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR _params$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN1681@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	esi
	lea	ecx, DWORD PTR _params$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR _params$[ebp+20], 15		; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR _params$[ebp+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR _params$[ebp], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN1675@execute:

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR $T2[ebp+20]

; 943  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN1975@execute
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR $T2[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN1975@execute:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 629  : 	while( params.size() && params[params.size()-1]==' ' ) params=params.substr( 0,params.size()-1 );

	mov	ecx, DWORD PTR _params$[ebp+16]
	test	ecx, ecx
	je	$LN2134@execute
	mov	edx, DWORD PTR _params$[ebp+20]
	mov	esi, DWORD PTR _params$[ebp]
	jmp	$LL6@execute
$LN14@execute:

; 633  : 	return (int)ShellExecute( GetDesktopWindow(),0,cmd.c_str(),params.size() ? params.c_str() : 0,0,SW_SHOW )>32;

	xor	ecx, ecx
$LN15@execute:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _cmd$[ebp+20], 16		; 00000010H
	lea	eax, DWORD PTR _cmd$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 633  : 	return (int)ShellExecute( GetDesktopWindow(),0,cmd.c_str(),params.size() ? params.c_str() : 0,0,SW_SHOW )>32;

	push	5
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmovae	eax, DWORD PTR _cmd$[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 633  : 	return (int)ShellExecute( GetDesktopWindow(),0,cmd.c_str(),params.size() ? params.c_str() : 0,0,SW_SHOW )>32;

	push	0
	push	ecx
	push	eax
	push	0
	call	esi
	push	eax
	call	DWORD PTR __imp__ShellExecuteA@24
	cmp	eax, 32					; 00000020H
	lea	ecx, DWORD PTR _params$[ebp]
	setg	bl
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR _cmd$[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	al, bl
$LN1@execute:

; 634  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$0:
	lea	ecx, DWORD PTR _cmd$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$1:
	lea	ecx, DWORD PTR _params$[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$77:
	call	___std_terminate
	ret	0
__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$243:
	call	___std_terminate
	ret	0
__unwindfunclet$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z$417:
	call	___std_terminate
	ret	0
__ehhandler$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-92]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?execute@gxRuntime@@QAE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; gxRuntime::execute
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?delay@gxRuntime@@QAE_NH@Z
_TEXT	SEGMENT
_msg$1 = -28						; size = 28
_t$1$ = 8						; size = 4
_ms$ = 8						; size = 4
?delay@gxRuntime@@QAE_NH@Z PROC				; gxRuntime::delay, COMDAT
; _this$ = ecx

; 526  : bool gxRuntime::delay( int ms ){

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	push	esi
	push	edi
	mov	esi, ecx

; 527  : 	int t=timeGetTime()+ms;

	call	DWORD PTR __imp__timeGetTime@0
	add	DWORD PTR _ms$[ebp], eax
	mov	edi, DWORD PTR __imp__SetForegroundWindow@4
	mov	ebx, DWORD PTR __imp__ShowWindow@8
$LL10@delay:

; 500  : 		if( suspended && run_flag ){

	cmp	BYTE PTR ?suspended@@3_NA, 0
	je	SHORT $LN15@delay
$LN45@delay:
	cmp	BYTE PTR ?run_flag@@3_NC, 0
	je	SHORT $LN15@delay

; 501  : 			GetMessage( &msg,0,0,0 );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	DWORD PTR __imp__GetMessageA@16

; 502  : 		}else{

	jmp	SHORT $LN17@delay
$LN15@delay:

; 503  : 			if( !PeekMessage( &msg,0,0,0,PM_REMOVE ) ) return run_flag;

	push	1
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	test	eax, eax
	je	$LN37@delay
$LN17@delay:

; 504  : 		}
; 505  : 		switch( msg.message ){

	mov	eax, DWORD PTR _msg$1[ebp+4]
	sub	eax, 1025				; 00000401H
	je	SHORT $LN18@delay
	sub	eax, 1
	je	SHORT $LN20@delay
	sub	eax, 1
	je	SHORT $LN22@delay

; 516  : 		default:
; 517  : 			DispatchMessage( &msg );

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
	jmp	SHORT $LL10@delay
$LN22@delay:

; 512  : 		case WM_END:
; 513  : 			debugger=0;

	mov	DWORD PTR ?debugger@@3PAVDebugger@@A, 0

; 514  : 			run_flag=false;

	mov	BYTE PTR ?run_flag@@3_NC, 0

; 515  : 			break;

	jmp	SHORT $LL10@delay
$LN20@delay:

; 508  : 			break;
; 509  : 		case WM_RUN:
; 510  : 			if( suspended ) forceResume();

	cmp	BYTE PTR ?suspended@@3_NA, 0
	je	SHORT $LN15@delay

; 246  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN30@delay

; 247  : 		SetForegroundWindow( hwnd );

	push	DWORD PTR [esi]
	call	edi

; 248  : 		ShowWindow( hwnd,SW_SHOWMAXIMIZED );

	push	3
	push	DWORD PTR [esi]
	call	ebx

; 249  : 	}else{

	jmp	$LL10@delay
$LN30@delay:

; 250  : 		resume();

	mov	ecx, esi
	call	?resume@gxRuntime@@AAEXXZ		; gxRuntime::resume

; 511  : 			break;

	jmp	$LL10@delay
$LN18@delay:

; 506  : 		case WM_STOP:
; 507  : 			if( !suspended ) forceSuspend();

	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	$LN45@delay

; 234  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN26@delay

; 235  : 		SetForegroundWindow( GetDesktopWindow() );

	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	edi

; 236  : 		ShowWindow( GetDesktopWindow(),SW_SHOW );

	push	5
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	ebx

; 237  : 	}else{

	jmp	$LL10@delay
$LN26@delay:

; 238  : 		suspend();

	mov	ecx, esi
	call	?suspend@gxRuntime@@AAEXXZ		; gxRuntime::suspend

; 519  : 	}

	jmp	$LL10@delay
$LN37@delay:

; 503  : 			if( !PeekMessage( &msg,0,0,0,PM_REMOVE ) ) return run_flag;

	mov	al, BYTE PTR ?run_flag@@3_NC

; 528  : 	for(;;){
; 529  : 		if( !idle() ) return false;

	test	al, al
	je	SHORT $LN38@delay

; 530  : 		int d=t-timeGetTime();	//how long left to wait

	call	DWORD PTR __imp__timeGetTime@0
	mov	ecx, DWORD PTR _t$1$[ebp]
	sub	ecx, eax

; 531  : 		if( d<=0 ) return true;

	test	ecx, ecx
	jle	SHORT $LN39@delay

; 532  : 		if( d>100 ) d=100;

	cmp	ecx, 100				; 00000064H
	mov	eax, 100				; 00000064H
	cmovg	ecx, eax

; 533  : 		Sleep( d );

	push	ecx
	call	DWORD PTR __imp__Sleep@4
	jmp	$LL10@delay
$LN39@delay:
	pop	edi
	pop	esi

; 531  : 		if( d<=0 ) return true;

	mov	al, 1
	pop	ebx

; 534  : 	}
; 535  : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN38@delay:
	pop	edi
	pop	esi

; 528  : 	for(;;){
; 529  : 		if( !idle() ) return false;

	xor	al, al
	pop	ebx

; 534  : 	}
; 535  : }

	mov	esp, ebp
	pop	ebp
	ret	4
?delay@gxRuntime@@QAE_NH@Z ENDP				; gxRuntime::delay
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?idle@gxRuntime@@QAE_NXZ
_TEXT	SEGMENT
_msg$1 = -28						; size = 28
?idle@gxRuntime@@QAE_NXZ PROC				; gxRuntime::idle, COMDAT
; _this$ = ecx

; 497  : bool gxRuntime::idle(){

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx
	mov	ebx, DWORD PTR __imp__ShowWindow@8
	push	esi
	push	edi
	mov	edi, DWORD PTR __imp__SetForegroundWindow@4
	mov	esi, ecx
$LL2@idle:

; 498  : 	for(;;){
; 499  : 		MSG msg;
; 500  : 		if( suspended && run_flag ){

	cmp	BYTE PTR ?suspended@@3_NA, 0
	je	SHORT $LN7@idle
$LN32@idle:
	cmp	BYTE PTR ?run_flag@@3_NC, 0
	je	SHORT $LN7@idle

; 501  : 			GetMessage( &msg,0,0,0 );

	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	DWORD PTR __imp__GetMessageA@16

; 502  : 		}else{

	jmp	SHORT $LN9@idle
$LN7@idle:

; 503  : 			if( !PeekMessage( &msg,0,0,0,PM_REMOVE ) ) return run_flag;

	push	1
	push	0
	push	0
	push	0
	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	DWORD PTR __imp__PeekMessageA@20
	test	eax, eax
	je	$LN30@idle
$LN9@idle:

; 504  : 		}
; 505  : 		switch( msg.message ){

	mov	eax, DWORD PTR _msg$1[ebp+4]
	sub	eax, 1025				; 00000401H
	je	SHORT $LN10@idle
	sub	eax, 1
	je	SHORT $LN12@idle
	sub	eax, 1
	je	SHORT $LN14@idle

; 516  : 		default:
; 517  : 			DispatchMessage( &msg );

	lea	eax, DWORD PTR _msg$1[ebp]
	push	eax
	call	DWORD PTR __imp__DispatchMessageA@4
	jmp	SHORT $LL2@idle
$LN14@idle:

; 512  : 		case WM_END:
; 513  : 			debugger=0;

	mov	DWORD PTR ?debugger@@3PAVDebugger@@A, 0

; 514  : 			run_flag=false;

	mov	BYTE PTR ?run_flag@@3_NC, 0

; 515  : 			break;

	jmp	SHORT $LL2@idle
$LN12@idle:

; 508  : 			break;
; 509  : 		case WM_RUN:
; 510  : 			if( suspended ) forceResume();

	cmp	BYTE PTR ?suspended@@3_NA, 0
	je	SHORT $LN7@idle

; 246  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN22@idle

; 247  : 		SetForegroundWindow( hwnd );

	push	DWORD PTR [esi]
	call	edi

; 248  : 		ShowWindow( hwnd,SW_SHOWMAXIMIZED );

	push	3
	push	DWORD PTR [esi]
	call	ebx

; 249  : 	}else{

	jmp	$LL2@idle
$LN22@idle:

; 250  : 		resume();

	mov	ecx, esi
	call	?resume@gxRuntime@@AAEXXZ		; gxRuntime::resume

; 511  : 			break;

	jmp	$LL2@idle
$LN10@idle:

; 506  : 		case WM_STOP:
; 507  : 			if( !suspended ) forceSuspend();

	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	$LN32@idle

; 234  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN18@idle

; 235  : 		SetForegroundWindow( GetDesktopWindow() );

	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	edi

; 236  : 		ShowWindow( GetDesktopWindow(),SW_SHOW );

	push	5
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	ebx

; 237  : 	}else{

	jmp	$LL2@idle
$LN18@idle:

; 238  : 		suspend();

	mov	ecx, esi
	call	?suspend@gxRuntime@@AAEXXZ		; gxRuntime::suspend

; 518  : 		}
; 519  : 	}

	jmp	$LL2@idle
$LN30@idle:

; 503  : 			if( !PeekMessage( &msg,0,0,0,PM_REMOVE ) ) return run_flag;

	mov	al, BYTE PTR ?run_flag@@3_NC
	pop	edi
	pop	esi
	pop	ebx

; 520  : 	return run_flag;
; 521  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?idle@gxRuntime@@QAE_NXZ ENDP				; gxRuntime::idle
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?asyncEnd@gxRuntime@@QAEXXZ
_TEXT	SEGMENT
?asyncEnd@gxRuntime@@QAEXXZ PROC			; gxRuntime::asyncEnd, COMDAT
; _this$ = ecx

; 491  : 	PostMessage( hwnd,WM_END,0,0 );

	push	0
	push	0
	push	1027					; 00000403H
	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__PostMessageA@16

; 492  : }

	ret	0
?asyncEnd@gxRuntime@@QAEXXZ ENDP			; gxRuntime::asyncEnd
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?asyncRun@gxRuntime@@QAEXXZ
_TEXT	SEGMENT
?asyncRun@gxRuntime@@QAEXXZ PROC			; gxRuntime::asyncRun, COMDAT
; _this$ = ecx

; 484  : 	PostMessage( hwnd,WM_RUN,0,0 );

	push	0
	push	0
	push	1026					; 00000402H
	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__PostMessageA@16

; 485  : }

	ret	0
?asyncRun@gxRuntime@@QAEXXZ ENDP			; gxRuntime::asyncRun
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?asyncStop@gxRuntime@@QAEXXZ
_TEXT	SEGMENT
?asyncStop@gxRuntime@@QAEXXZ PROC			; gxRuntime::asyncStop, COMDAT
; _this$ = ecx

; 477  : 	PostMessage( hwnd,WM_STOP,0,0 );

	push	0
	push	0
	push	1025					; 00000401H
	push	DWORD PTR [ecx]
	call	DWORD PTR __imp__PostMessageA@16

; 478  : }

	ret	0
?asyncStop@gxRuntime@@QAEXXZ ENDP			; gxRuntime::asyncStop
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?closeRuntime@gxRuntime@@SGXPAV1@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
_r$ = 8							; size = 4
?closeRuntime@gxRuntime@@SGXPAV1@@Z PROC		; gxRuntime::closeRuntime, COMDAT

; 101  : void gxRuntime::closeRuntime( gxRuntime *r ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?closeRuntime@gxRuntime@@SGXPAV1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 102  : 	if( !runtime || runtime!=r ) return;

	mov	eax, DWORD PTR ?runtime@@3PAVgxRuntime@@A
	test	eax, eax
	je	$LN6@closeRunti
	cmp	eax, DWORD PTR _r$[ebp]
	jne	$LN6@closeRunti

; 105  : 	for( it=libs.begin();it!=libs.end();++it ){

	mov	eax, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	mov	esi, DWORD PTR [eax]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 336  : 		return (this->_Ptr == _Right._Ptr);

	cmp	esi, eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 105  : 	for( it=libs.begin();it!=libs.end();++it ){

	je	SHORT $LN3@closeRunti
	mov	edi, DWORD PTR __imp__FreeLibrary@4
	npad	5
$LL60@closeRunti:

; 106  : 		FreeLibrary( it->second->hinst );

	mov	eax, DWORD PTR [esi+40]
	push	DWORD PTR [eax]
	call	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 60   : 		if (_Mytree::_Isnil(_Ptr))

	cmp	BYTE PTR [esi+13], 0
	jne	SHORT $LN265@closeRunti

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi+8]

; 62   : 		else if (!_Mytree::_Isnil(_Mytree::_Right(_Ptr)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN262@closeRunti

; 63   : 			_Ptr = _Mytree::_Min(

	mov	esi, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN265@closeRunti
$LL71@closeRunti:

; 616  : 			_Pnode = _Left(_Pnode);

	mov	esi, eax

; 583  : 		return ((char&)_Pnode->_Isnil);

	mov	eax, DWORD PTR [esi]

; 615  : 		while (!_Isnil(_Left(_Pnode)))

	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL71@closeRunti

; 65   : 		else

	jmp	SHORT $LN265@closeRunti
$LN262@closeRunti:

; 66   : 			{	// climb looking for right subtree
; 67   : 			_Nodeptr _Pnode;
; 68   : 			while (!_Mytree::_Isnil(_Pnode = _Mytree::_Parent(_Ptr))
; 69   : 				&& _Ptr == _Mytree::_Right(_Pnode))

	mov	eax, DWORD PTR [esi+4]
	cmp	BYTE PTR [eax+13], 0
	jne	SHORT $LN56@closeRunti
$LL55@closeRunti:
	cmp	esi, DWORD PTR [eax+8]
	jne	SHORT $LN56@closeRunti

; 70   : 				_Ptr = _Pnode;	// ==> parent while right subtree

	mov	esi, eax
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+13], 0
	je	SHORT $LL55@closeRunti
$LN56@closeRunti:

; 71   : 			_Ptr = _Pnode;	// ==> parent (head if end())

	mov	esi, eax
$LN265@closeRunti:

; 336  : 		return (this->_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	cmp	esi, eax
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 105  : 	for( it=libs.begin();it!=libs.end();++it ){

	jne	SHORT $LL60@closeRunti
$LN3@closeRunti:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1472 : 		_Erase(_Root());

	push	DWORD PTR [eax+4]
	mov	ecx, OFFSET ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	call	?_Erase@?$_Tree@V?$_Tmap_traits@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@$0A@@std@@@std@@IAEXPAU?$_Tree_node@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@PAX@2@@Z ; std::_Tree<std::_Tmap_traits<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,gxDll *,std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >,std::allocator<std::pair<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const ,gxDll *> >,0> >::_Erase

; 1473 : 		_Root() = this->_Myhead();

	mov	eax, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 110  : 	delete runtime;

	mov	esi, DWORD PTR ?runtime@@3PAVgxRuntime@@A
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1473 : 		_Root() = this->_Myhead();

	mov	DWORD PTR [eax+4], eax

; 1474 : 		_Lmost() = this->_Myhead();

	mov	eax, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	mov	DWORD PTR [eax], eax

; 1475 : 		_Rmost() = this->_Myhead();

	mov	eax, DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A
	mov	DWORD PTR [eax+8], eax

; 1476 : 		this->_Mysize() = 0;

	mov	DWORD PTR ?libs@@3V?$map@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@U?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@2@V?$allocator@U?$pair@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUgxDll@@@std@@@2@@std@@A+4, 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 110  : 	delete runtime;

	test	esi, esi
	je	SHORT $LN257@closeRunti
	mov	ecx, esi
	call	??1gxRuntime@@AAE@XZ			; gxRuntime::~gxRuntime
	push	292					; 00000124H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN257@closeRunti:

; 111  : 	runtime=0;

	mov	DWORD PTR ?runtime@@3PAVgxRuntime@@A, 0
$LN6@closeRunti:

; 112  : 
; 113  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?closeRuntime@gxRuntime@@SGXPAV1@@Z$17:
	call	___std_terminate
	ret	0
__ehhandler$?closeRuntime@gxRuntime@@SGXPAV1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?closeRuntime@gxRuntime@@SGXPAV1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?closeRuntime@gxRuntime@@SGXPAV1@@Z ENDP		; gxRuntime::closeRuntime
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z
_TEXT	SEGMENT
_wndclass$ = -52					; size = 40
__$EHRec$ = -12						; size = 12
_hinst$ = 8						; size = 4
_cmd_line$ = 12						; size = 4
$T2 = 16						; size = 4
_d$ = 16						; size = 4
?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z PROC ; gxRuntime::openRuntime, COMDAT

; 68   : gxRuntime *gxRuntime::openRuntime( HINSTANCE hinst,const string &cmd_line,Debugger *d ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 69   : 	if( runtime ) return 0;

	cmp	DWORD PTR ?runtime@@3PAVgxRuntime@@A, 0
	je	SHORT $LN2@openRuntim
	xor	eax, eax

; 98   : 	return runtime;
; 99   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@openRuntim:

; 70   : 
; 71   : 	//create debugger
; 72   : 	debugger=d;

	mov	eax, DWORD PTR _d$[ebp]
	xorps	xmm0, xmm0

; 73   : 
; 74   : 	//create WNDCLASS
; 75   : 	WNDCLASS wndclass;
; 76   : 	memset(&wndclass,0,sizeof(wndclass));
; 77   : 	wndclass.style=CS_HREDRAW|CS_VREDRAW|CS_OWNDC;
; 78   : 	wndclass.lpfnWndProc=::windowProc;
; 79   : 	wndclass.hInstance=hinst;

	mov	esi, DWORD PTR _hinst$[ebp]

; 80   : 	wndclass.lpszClassName="Blitz Runtime Class";
; 81   : 	wndclass.hCursor=(HCURSOR)LoadCursor( 0,IDC_ARROW );

	push	32512					; 00007f00H
	movups	XMMWORD PTR _wndclass$[ebp], xmm0
	push	0
	movups	XMMWORD PTR _wndclass$[ebp+16], xmm0
	mov	DWORD PTR ?debugger@@3PAVDebugger@@A, eax
	movq	QWORD PTR _wndclass$[ebp+32], xmm0
	mov	DWORD PTR _wndclass$[ebp], 35		; 00000023H
	mov	DWORD PTR _wndclass$[ebp+4], OFFSET ?windowProc@@YGJPAUHWND__@@IIJ@Z ; windowProc
	mov	DWORD PTR _wndclass$[ebp+16], esi
	mov	DWORD PTR _wndclass$[ebp+36], OFFSET ??_C@_0BE@BCECDIAH@Blitz?5Runtime?5Class?$AA@
	call	DWORD PTR __imp__LoadCursorA@8

; 82   : 	wndclass.hbrBackground=(HBRUSH)GetStockObject( BLACK_BRUSH );

	push	4
	mov	DWORD PTR _wndclass$[ebp+24], eax
	call	DWORD PTR __imp__GetStockObject@4
	mov	DWORD PTR _wndclass$[ebp+28], eax

; 83   : 	RegisterClass( &wndclass );

	lea	eax, DWORD PTR _wndclass$[ebp]
	push	eax
	call	DWORD PTR __imp__RegisterClassA@4

; 84   : 
; 85   : 	gfx_mode=0;
; 86   : 	clipper=0;primSurf=0;
; 87   : 	busy=suspended=false;
; 88   : 	run_flag=true;
; 89   : 
; 90   : 	const char *app_t=" ";
; 91   : 	int ws=WS_CAPTION,ws_ex=0;
; 92   : 
; 93   : 	HWND hwnd=CreateWindowEx( ws_ex,"Blitz Runtime Class",app_t,ws,0,0,0,0,0,0,0,0 );

	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	0
	push	12582912				; 00c00000H
	push	OFFSET ??_C@_01CLKCMJKC@?5?$AA@
	push	OFFSET ??_C@_0BE@BCECDIAH@Blitz?5Runtime?5Class?$AA@
	mov	DWORD PTR ?gfx_mode@@3HA, 0
	mov	DWORD PTR ?clipper@@3PAUIDirectDrawClipper@@A, 0
	mov	DWORD PTR ?primSurf@@3PAUIDirectDrawSurface7@@A, 0
	mov	BYTE PTR ?suspended@@3_NA, 0
	mov	BYTE PTR ?busy@@3_NA, 0
	push	0
	mov	BYTE PTR ?run_flag@@3_NC, 1
	call	DWORD PTR __imp__CreateWindowExA@48
	mov	edi, eax

; 94   : 
; 95   : 	UpdateWindow( hwnd );

	push	edi
	call	DWORD PTR __imp__UpdateWindow@4

; 96   : 
; 97   : 	runtime=d_new gxRuntime( hinst,cmd_line,hwnd );

	push	292					; 00000124H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN4@openRuntim
	push	edi
	push	DWORD PTR _cmd_line$[ebp]
	mov	ecx, eax
	push	esi
	call	??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z ; gxRuntime::gxRuntime
	jmp	SHORT $LN5@openRuntim
$LN4@openRuntim:
	xor	eax, eax
$LN5@openRuntim:
	mov	DWORD PTR ?runtime@@3PAVgxRuntime@@A, eax

; 98   : 	return runtime;
; 99   : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z$0:
	push	292					; 00000124H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?openRuntime@gxRuntime@@SGPAV1@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAVDebugger@@@Z ENDP ; gxRuntime::openRuntime
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?unacquireInput@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?unacquireInput@gxRuntime@@AAEXXZ PROC			; gxRuntime::unacquireInput, COMDAT
; _this$ = ecx

; 193  : void gxRuntime::unacquireInput(){

	push	esi
	mov	esi, ecx

; 194  : 	if( !input ) return;

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN1@unacquireI

; 195  : 	if( gfx_mode==3 && use_di ) input->unacquire();

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN3@unacquireI
	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN3@unacquireI
	call	?unacquire@gxInput@@QAEXXZ		; gxInput::unacquire
$LN3@unacquireI:

; 196  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]
	pop	esi
	jmp	?reset@gxInput@@QAEXXZ			; gxInput::reset
$LN1@unacquireI:
	pop	esi

; 197  : }

	ret	0
?unacquireInput@gxRuntime@@AAEXXZ ENDP			; gxRuntime::unacquireInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?acquireInput@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?acquireInput@gxRuntime@@AAEXXZ PROC			; gxRuntime::acquireInput, COMDAT
; _this$ = ecx

; 182  : void gxRuntime::acquireInput(){

	push	esi
	mov	esi, ecx

; 183  : 	if( !input ) return;

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN1@acquireInp

; 184  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN4@acquireInp

; 185  : 		if( use_di ){

	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN4@acquireInp

; 186  : 			use_di=input->acquire();

	call	?acquire@gxInput@@QAE_NXZ		; gxInput::acquire
	movzx	eax, al
	mov	DWORD PTR [esi+140], eax
$LN4@acquireInp:

; 187  : 		}else{
; 188  : 		}
; 189  : 	}
; 190  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]
	pop	esi
	jmp	?reset@gxInput@@QAEXXZ			; gxInput::reset
$LN1@acquireInp:
	pop	esi

; 191  : }

	ret	0
?acquireInput@gxRuntime@@AAEXXZ ENDP			; gxRuntime::acquireInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?restoreGraphics@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?restoreGraphics@gxRuntime@@AAEXXZ PROC			; gxRuntime::restoreGraphics, COMDAT
; _this$ = ecx

; 173  : 	if( auto_suspend ){

	cmp	BYTE PTR ?auto_suspend@@3_NA, 0
	je	SHORT $LN3@restoreGra

; 174  : 		if( !graphics->restore() ) gfx_lost=true;

	mov	ecx, DWORD PTR [ecx+16]
	call	?restore@gxGraphics@@QAE_NXZ		; gxGraphics::restore
	movzx	ecx, BYTE PTR ?gfx_lost@@3_NA
	test	al, al
	mov	edx, 1
	cmove	ecx, edx
	mov	BYTE PTR ?gfx_lost@@3_NA, cl
$LN3@restoreGra:

; 175  : 	}
; 176  : }

	ret	0
?restoreGraphics@gxRuntime@@AAEXXZ ENDP			; gxRuntime::restoreGraphics
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?backupGraphics@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?backupGraphics@gxRuntime@@AAEXXZ PROC			; gxRuntime::backupGraphics, COMDAT
; _this$ = ecx

; 167  : 	if( auto_suspend ){

	cmp	BYTE PTR ?auto_suspend@@3_NA, 0
	je	SHORT $LN2@backupGrap

; 168  : 		graphics->backup();

	mov	ecx, DWORD PTR [ecx+16]
	jmp	?backup@gxGraphics@@QAEXXZ		; gxGraphics::backup
$LN2@backupGrap:

; 169  : 	}
; 170  : }

	ret	0
?backupGraphics@gxRuntime@@AAEXXZ ENDP			; gxRuntime::backupGraphics
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?resumeAudio@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?resumeAudio@gxRuntime@@AAEXXZ PROC			; gxRuntime::resumeAudio, COMDAT
; _this$ = ecx

; 163  : 	if( audio ) audio->resume();

	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	jne	?resume@gxAudio@@QAEXXZ			; gxAudio::resume

; 164  : }

	ret	0
?resumeAudio@gxRuntime@@AAEXXZ ENDP			; gxRuntime::resumeAudio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?pauseAudio@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?pauseAudio@gxRuntime@@AAEXXZ PROC			; gxRuntime::pauseAudio, COMDAT
; _this$ = ecx

; 159  : 	if( audio ) audio->pause();

	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	jne	?pause@gxAudio@@QAEXXZ			; gxAudio::pause

; 160  : }

	ret	0
?pauseAudio@gxRuntime@@AAEXXZ ENDP			; gxRuntime::pauseAudio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?resetInput@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?resetInput@gxRuntime@@AAEXXZ PROC			; gxRuntime::resetInput, COMDAT
; _this$ = ecx

; 179  : 	if( input ) input->reset();

	mov	ecx, DWORD PTR [ecx+12]
	test	ecx, ecx
	jne	?reset@gxInput@@QAEXXZ			; gxInput::reset

; 180  : }

	ret	0
?resetInput@gxRuntime@@AAEXXZ ENDP			; gxRuntime::resetInput
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?denumGfx@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
_k$1$ = -4						; size = 4
?denumGfx@gxRuntime@@AAEXXZ PROC			; gxRuntime::denumGfx, COMDAT
; _this$ = ecx

; 1048 : void gxRuntime::denumGfx(){

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx

; 1049 : 	for( int k=0;k<(int)drivers.size();++k ){

	xor	ecx, ecx
	mov	DWORD PTR _k$1$[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+128]
	sub	eax, DWORD PTR [ebx+124]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1049 : 	for( int k=0;k<(int)drivers.size();++k ){

	test	eax, -4					; fffffffcH
	jle	$LN368@denumGfx
	push	esi
	push	edi
$LL4@denumGfx:

; 1050 : 		gxRuntime::GfxDriver *d=drivers[k];

	mov	esi, DWORD PTR [ebx+124]

; 1051 : 		for( int j=0;j<(int)d->modes.size();++j ) delete d->modes[j];

	xor	edi, edi
	mov	esi, DWORD PTR [esi+ecx*4]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+32]
	sub	eax, DWORD PTR [esi+28]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1051 : 		for( int j=0;j<(int)d->modes.size();++j ) delete d->modes[j];

	test	eax, -4					; fffffffcH
	jle	SHORT $LN6@denumGfx
$LL7@denumGfx:
	mov	eax, DWORD PTR [esi+28]
	push	124					; 0000007cH
	push	DWORD PTR [eax+edi*4]
	call	??3@YAXPAXI@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [esi+32]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1051 : 		for( int j=0;j<(int)d->modes.size();++j ) delete d->modes[j];

	inc	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, DWORD PTR [esi+28]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1051 : 		for( int j=0;j<(int)d->modes.size();++j ) delete d->modes[j];

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	eax, 2
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1051 : 		for( int j=0;j<(int)d->modes.size();++j ) delete d->modes[j];

	cmp	edi, eax
	jl	SHORT $LL7@denumGfx
$LN6@denumGfx:

; 1052 : 		delete d->guid;

	push	16					; 00000010H
	push	DWORD PTR [esi]
	call	??3@YAXPAXI@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+28]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1052 : 		delete d->guid;

	add	esp, 8
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN86@denumGfx

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();
; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());
; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [esi+36]
	sub	eax, ecx
	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	cmp	eax, 1073741823				; 3fffffffH
	ja	$LN372@denumGfx

; 95   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN154@denumGfx

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	$LN372@denumGfx

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	$LN372@denumGfx

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	$LN372@denumGfx

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	$LN372@denumGfx

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN154@denumGfx:

; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+28], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 132  : 	::operator delete(_Ptr);

	add	esp, 4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+32], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+36], 0
$LN86@denumGfx:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+24]
	lea	edi, DWORD PTR [esi+4]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN278@denumGfx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN273@denumGfx

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	test	cl, 31					; 0000001fH
	jne	SHORT $LN372@denumGfx

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR [ecx-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	eax, ecx
	jae	SHORT $LN372@denumGfx

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	ecx, eax
	cmp	ecx, 4
	jb	SHORT $LN372@denumGfx

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	ecx, 35					; 00000023H
	ja	SHORT $LN372@denumGfx

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, eax
$LN273@denumGfx:

; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4
$LN278@denumGfx:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN301@denumGfx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN301@denumGfx:
	push	276					; 00000114H
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
	call	??3@YAXPAXI@Z				; operator delete
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ebx+128]
	add	esp, 8
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1049 : 	for( int k=0;k<(int)drivers.size();++k ){

	mov	ecx, DWORD PTR _k$1$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	eax, DWORD PTR [ebx+124]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1049 : 	for( int k=0;k<(int)drivers.size();++k ){

	inc	ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	eax, 2
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1049 : 	for( int k=0;k<(int)drivers.size();++k ){

	mov	DWORD PTR _k$1$[ebp], ecx
	cmp	ecx, eax
	jl	$LL4@denumGfx
	pop	edi
	pop	esi
$LN368@denumGfx:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [ebx+124]
	mov	DWORD PTR [ebx+128], eax
	pop	ebx
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1056 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN372@denumGfx:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	__invalid_parameter_noinfo_noreturn
$LN373@denumGfx:
$LN371@denumGfx:
	int	3
?denumGfx@gxRuntime@@AAEXXZ ENDP			; gxRuntime::denumGfx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?enumGfx@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?enumGfx@gxRuntime@@AAEXXZ PROC				; gxRuntime::enumGfx, COMDAT
; _this$ = ecx

; 1039 : void gxRuntime::enumGfx(){

	push	esi
	mov	esi, ecx

; 1040 : 	denumGfx();

	call	?denumGfx@gxRuntime@@AAEXXZ		; gxRuntime::denumGfx

; 1041 : 	if( enum_all ){

	cmp	BYTE PTR [esi+120], 0

; 1042 : 		DirectDrawEnumerateEx( enumDriver,&drivers,DDENUM_ATTACHEDSECONDARYDEVICES|DDENUM_NONDISPLAYDEVICES );

	lea	eax, DWORD PTR [esi+124]
	je	SHORT $LN2@enumGfx
	push	5

; 1043 : 	}else{
; 1044 : 		DirectDrawEnumerateEx( enumDriver,&drivers,0 );

	push	eax
	push	OFFSET ?enumDriver@@YGHPAU_GUID@@PAD1PAXPAUHMONITOR__@@@Z ; enumDriver
	call	_DirectDrawEnumerateExA@12
	pop	esi

; 1045 : 	}
; 1046 : }

	ret	0
$LN2@enumGfx:

; 1043 : 	}else{
; 1044 : 		DirectDrawEnumerateEx( enumDriver,&drivers,0 );

	push	0
	push	eax
	push	OFFSET ?enumDriver@@YGHPAU_GUID@@PAD1PAXPAUHMONITOR__@@@Z ; enumDriver
	call	_DirectDrawEnumerateExA@12
	pop	esi

; 1045 : 	}
; 1046 : }

	ret	0
?enumGfx@gxRuntime@@AAEXXZ ENDP				; gxRuntime::enumGfx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEXPAPAUGfxDriver@gxRuntime@@0@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?_Orphan_range@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEXPAPAUGfxDriver@gxRuntime@@0@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1794 : 		}

	ret	8
?_Orphan_range@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEXPAPAUGfxDriver@gxRuntime@@0@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
?_Xlen@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEXXZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Xlen, COMDAT
; _this$ = ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEXXZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
?_Tidy@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXXZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN2@Tidy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN2@Tidy:
	pop	esi

; 1646 : 			}
; 1647 : 		}

	ret	0
?_Tidy@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXXZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reserve@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR __Count$[ebp]
	push	edi

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	edi, DWORD PTR [esi+8]
	mov	eax, edi
	mov	edx, DWORD PTR [esi+4]
	sub	eax, edx
	sar	eax, 2

; 1627 : 		if (_Unused_capacity() < _Count)

	cmp	eax, ecx
	jae	SHORT $LN2@Reserve

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sub	edx, DWORD PTR [esi]
	push	ebx

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ebx, 1073741823				; 3fffffffH

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	sar	edx, 2

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	eax, ebx
	sub	eax, edx
	cmp	eax, ecx
	jb	SHORT $LN134@Reserve

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	edi, DWORD PTR [esi]

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	add	edx, ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sar	edi, 2
	xor	ecx, ecx

; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, edi
	shr	eax, 1
	sub	ebx, eax
	add	eax, edi
	cmp	ebx, edi
	cmovae	ecx, eax
	cmp	ecx, edx
	cmovae	edx, ecx

; 1630 : 				_Xlen();
; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, esi
	push	edx
	call	?_Reallocate@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reallocate
	pop	ebx
$LN2@Reserve:
	pop	edi
	pop	esi

; 1632 : 			}
; 1633 : 		}

	pop	ebp
	ret	4
$LN134@Reserve:

; 1765 : 		_Xlength_error("vector<T> too long");

	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN136@Reserve:
$LN133@Reserve:
	int	3
?_Reserve@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Reallocate@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1601 : 		{	// move to array of exactly _Count elements

	mov	edi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 976  : 		return (_Mybase::allocate(_Count));

	call	?allocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z ; std::allocator<gxRuntime::GfxDriver *>::allocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	esi, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	ebx, eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	edx, DWORD PTR [edi+4]
	sub	edx, esi

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	push	edx
	push	esi
	push	ebx
	call	_memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	esi, DWORD PTR [edi+4]
	sub	esi, ecx
	sar	esi, 2

; 1603 : 
; 1604 : 		_TRY_BEGIN
; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);
; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);
; 1608 : 		_RERAISE;
; 1609 : 		_CATCH_END
; 1610 : 
; 1611 : 		size_type _Size = size();
; 1612 : 		if (this->_Myfirst() != pointer())

	test	ecx, ecx
	je	SHORT $LN3@Reallocate

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [edi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN3@Reallocate:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1620 : 		this->_Myend() = _Ptr + _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	lea	eax, DWORD PTR [ebx+eax*4]
	mov	DWORD PTR [edi+8], eax

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	lea	eax, DWORD PTR [ebx+esi*4]
	mov	DWORD PTR [edi+4], eax

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	DWORD PTR [edi], ebx
	pop	edi
	pop	esi
	pop	ebx

; 1623 : 		}

	pop	ebp
	ret	4
?_Reallocate@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBE_NPBQAUGfxDriver@gxRuntime@@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBE_NPBQAUGfxDriver@gxRuntime@@@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	cmp	eax, DWORD PTR [ecx+4]
	jae	SHORT $LN3@Inside
	cmp	DWORD PTR [ecx], eax
	ja	SHORT $LN3@Inside
	mov	al, 1

; 1598 : 		}

	pop	ebp
	ret	4
$LN3@Inside:

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	xor	al, al

; 1598 : 		}

	pop	ebp
	ret	4
?_Inside@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBE_NPBQAUGfxDriver@gxRuntime@@@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?_Grow_to@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEII@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	push	esi

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	esi, DWORD PTR [ecx+8]

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	edx, 1073741823				; 3fffffffH

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	sub	esi, DWORD PTR [ecx]
	sar	esi, 2

; 1586 : 		size_type _Capacity = capacity();
; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	eax, esi
	shr	eax, 1
	sub	edx, eax
	lea	ecx, DWORD PTR [eax+esi]
	xor	eax, eax
	cmp	edx, esi
	pop	esi
	cmovae	eax, ecx

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	cmp	eax, DWORD PTR __Count$[ebp]
	cmovb	eax, DWORD PTR __Count$[ebp]

; 1591 : 			_Capacity = _Count;
; 1592 : 		return (_Capacity);
; 1593 : 		}

	pop	ebp
	ret	4
?_Grow_to@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IBEII@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXPAPAUGfxDriver@gxRuntime@@0@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXPAPAUGfxDriver@gxRuntime@@0@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Destroy, COMDAT
; _this$ = ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());
; 1582 : 		}

	ret	8
?_Destroy@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXPAPAUGfxDriver@gxRuntime@@0@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?clear@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXXZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::clear, COMDAT
; _this$ = ecx

; 1540 : 		this->_Orphan_all();
; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());
; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax

; 1543 : 		}

	ret	0
?clear@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXXZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXABQAUGfxDriver@gxRuntime@@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?push_back@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXABQAUGfxDriver@gxRuntime@@@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	edi, DWORD PTR __Val$[ebp]
	mov	eax, DWORD PTR [esi+4]
	cmp	edi, eax
	jae	SHORT $LN2@push_back
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, edi
	ja	SHORT $LN2@push_back

; 1277 : 		if (_Inside(_STD addressof(_Val)))
; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	sub	edi, ecx
	sar	edi, 2

; 1280 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reserve
$LN4@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN209@push_back
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+edi*4]
	mov	DWORD PTR [ecx], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 1295 : 			}
; 1296 : 		}

	pop	ebp
	ret	4
$LN2@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());
; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),
; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();
; 1286 : 			}
; 1287 : 		else
; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	cmp	eax, DWORD PTR [esi+8]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	push	1
	mov	ecx, esi
	call	?_Reserve@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@IAEXI@Z ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Reserve
$LN5@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	ecx, DWORD PTR [esi+4]
	test	ecx, ecx
	je	SHORT $LN209@push_back
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [ecx], eax
$LN209@push_back:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1294 : 			++this->_Mylast();

	add	DWORD PTR [esi+4], 4
	pop	edi
	pop	esi

; 1295 : 			}
; 1296 : 		}

	pop	ebp
	ret	4
?push_back@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXABQAUGfxDriver@gxRuntime@@@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??A?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEAAPAUGfxDriver@gxRuntime@@I@Z
_TEXT	SEGMENT
__Pos$ = 8						; size = 4
??A?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEAAPAUGfxDriver@gxRuntime@@I@Z PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::operator[], COMDAT
; _this$ = ecx

; 1230 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 1231 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1232 : 		if (size() <= _Pos)
; 1233 : 			{	// report error
; 1234 : 			_DEBUG_ERROR("vector subscript out of range");
; 1235 : 			_SCL_SECURE_OUT_OF_RANGE;
; 1236 : 			}
; 1237 : 
; 1238 :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 1239 : 		_SCL_SECURE_VALIDATE_RANGE(_Pos < size());
; 1240 :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 1241 : 
; 1242 : 		return (*(this->_Myfirst() + _Pos));

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR __Pos$[ebp]
	lea	eax, DWORD PTR [ecx+eax*4]

; 1243 : 		}

	pop	ebp
	ret	4
??A?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEAAPAUGfxDriver@gxRuntime@@I@Z ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::max_size, COMDAT
; _this$ = ecx

; 1185 : 		return (this->_Getal().max_size());

	mov	eax, 1073741823				; 3fffffffH

; 1186 : 		}

	ret	0
?max_size@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::size, COMDAT
; _this$ = ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+4]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1181 : 		}

	ret	0
?size@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?_Unused_capacity@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx+4]
	sar	eax, 2

; 1049 : 		}

	ret	0
?_Unused_capacity@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
?capacity@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::capacity, COMDAT
; _this$ = ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	eax, DWORD PTR [ecx+8]
	sub	eax, DWORD PTR [ecx]
	sar	eax, 2

; 1044 : 		}

	ret	0
?capacity@?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIXZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::~vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	esi
	mov	esi, ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi]
	test	ecx, ecx
	je	SHORT $LN4@vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [esi+8]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+4], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+8], 0
$LN4@vector:
	pop	esi

; 976  : 		_Tidy();
; 977  : 		}

	ret	0
??1?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::~vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 708  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 708  : 		}

	ret	0
??0?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >,std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 489  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >::_Vector_val<std::_Simple_types<gxRuntime::GfxDriver *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myend, COMDAT
; _this$ = ecx

; 668  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 669  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myend, COMDAT
; _this$ = ecx

; 663  : 		return (_Get_data()._Myend);

	lea	eax, DWORD PTR [ecx+8]

; 664  : 		}

	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Mylast, COMDAT
; _this$ = ecx

; 658  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 659  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ
_TEXT	SEGMENT
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Mylast, COMDAT
; _this$ = ecx

; 653  : 		return (_Get_data()._Mylast);

	lea	eax, DWORD PTR [ecx+4]

; 654  : 		}

	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 649  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABQAPAUGfxDriver@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ
_TEXT	SEGMENT
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myfirst, COMDAT
; _this$ = ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	eax, ecx

; 644  : 		}

	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAPAPAUGfxDriver@gxRuntime@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Get_data, COMDAT
; _this$ = ecx

; 638  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 639  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Get_data, COMDAT
; _this$ = ecx

; 633  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 634  : 		}

	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Getal, COMDAT
; _this$ = ecx

; 628  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 629  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Getal, COMDAT
; _this$ = ecx

; 623  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 624  : 		}

	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 613  : 		_Get_data()._Orphan_all();
; 614  : 		}

	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >, COMDAT
; _this$ = ecx

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [ecx], 0

; 521  : 		}

	mov	eax, ecx

; 486  : 		_Mylast(),

	mov	DWORD PTR [ecx+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [ecx+8], 0

; 521  : 		}

	ret	0
??0?$_Vector_alloc@U?$_Vec_base_types@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >::_Vector_alloc<std::_Vec_base_types<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, 1073741823				; 3fffffffH

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@I@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 977  : 		}

	pop	ebp

; 976  : 		return (_Mybase::allocate(_Count));

	jmp	?allocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z ; std::allocator<gxRuntime::GfxDriver *>::allocate
?allocate@?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >::_Wrap_alloc<std::allocator<gxRuntime::GfxDriver *> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGIABV?$allocator@PAUGfxDriver@gxRuntime@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGIABV?$allocator@PAUGfxDriver@gxRuntime@@@2@@Z PROC ; std::allocator_traits<std::allocator<gxRuntime::GfxDriver *> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	mov	eax, 1073741823				; 3fffffffH

; 870  : 		}

	ret	4
?max_size@?$allocator_traits@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@SGIABV?$allocator@PAUGfxDriver@gxRuntime@@@2@@Z ENDP ; std::allocator_traits<std::allocator<gxRuntime::GfxDriver *> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QBEIXZ PROC ; std::allocator<gxRuntime::GfxDriver *>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 1073741823				; 3fffffffH

; 750  : 		}

	ret	0
?max_size@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QBEIXZ ENDP ; std::allocator<gxRuntime::GfxDriver *>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z PROC ; std::allocator<gxRuntime::GfxDriver *>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	cmp	eax, 1073741823				; 3fffffffH
	ja	SHORT $LN14@allocate

; 57   : 	const size_t _User_size = _Count * _Sz;

	shl	eax, 2

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	jbe	SHORT $LN16@allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN17@allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	jmp	SHORT $LN18@allocate
$LN14@allocate:

; 56   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN19@allocate:
$LN16@allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN20@allocate:
$LN17@allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN21@allocate:
$LN18@allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN13@allocate:
	int	3
?allocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEPAPAUGfxDriver@gxRuntime@@I@Z ENDP ; std::allocator<gxRuntime::GfxDriver *>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@I@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@I@Z PROC ; std::allocator<gxRuntime::GfxDriver *>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAEXPAPAUGfxDriver@gxRuntime@@I@Z ENDP ; std::allocator<gxRuntime::GfxDriver *>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAE@XZ PROC ; std::allocator<gxRuntime::GfxDriver *>::allocator<gxRuntime::GfxDriver *>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@PAUGfxDriver@gxRuntime@@@std@@QAE@XZ ENDP ; std::allocator<gxRuntime::GfxDriver *>::allocator<gxRuntime::GfxDriver *>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
_TEXT	SEGMENT
$T2 = -176						; size = 4
_bs$3 = -172						; size = 4
_d3d$GSCopy$ = -168					; size = 1
_ps$4 = -164						; size = 4
_dd$ = -160						; size = 4
_desc$5 = -156						; size = 124
_caps$6 = -32						; size = 16
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_d$ = 16						; size = 4
_d3d$ = 20						; size = 1
?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z PROC ; gxRuntime::openExclusiveGraphics, COMDAT
; _this$ = ecx

; 829  : gxGraphics *gxRuntime::openExclusiveGraphics( int w,int h,int d,bool d3d ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 164				; 000000a4H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	bl, BYTE PTR _d3d$[ebp]

; 830  : 
; 831  : 	IDirectDraw7 *dd;
; 832  : 	if( DirectDrawCreateEx( curr_driver->guid,(void**)&dd,IID_IDirectDraw7,0 )<0 ) return 0;

	lea	eax, DWORD PTR _dd$[ebp]
	push	0
	push	OFFSET _IID_IDirectDraw7
	push	eax
	mov	eax, DWORD PTR [esi+136]
	mov	BYTE PTR _d3d$GSCopy$[ebp], bl
	push	DWORD PTR [eax]
	call	_DirectDrawCreateEx@16
	test	eax, eax
	js	$LN13@openExclus

; 833  : 
; 834  : 	//Set coop level
; 835  : 	if( dd->SetCooperativeLevel( hwnd,DDSCL_EXCLUSIVE|DDSCL_FULLSCREEN|DDSCL_ALLOWREBOOT )>=0 ){

	mov	eax, DWORD PTR _dd$[ebp]
	push	19					; 00000013H
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+80]
	test	eax, eax
	js	$LN4@openExclus

; 836  : 		//Set display mode
; 837  : 		if( setDisplayMode( w,h,d,d3d,dd ) ){

	push	DWORD PTR _dd$[ebp]
	mov	ecx, esi
	push	DWORD PTR _d3d$GSCopy$[ebp]
	push	DWORD PTR _d$[ebp]
	push	DWORD PTR _h$[ebp]
	push	DWORD PTR _w$[ebp]
	call	?setDisplayMode@gxRuntime@@AAE_NHHH_NPAUIDirectDraw7@@@Z ; gxRuntime::setDisplayMode
	test	al, al
	je	$LN4@openExclus

; 838  : 			//create primary surface
; 839  : 			IDirectDrawSurface7 *ps;
; 840  : 			DDSURFACEDESC2 desc={sizeof(desc)};

	push	120					; 00000078H
	lea	eax, DWORD PTR _desc$5[ebp+4]
	mov	DWORD PTR _desc$5[ebp], 124		; 0000007cH
	push	0
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 841  : 			desc.dwFlags=DDSD_CAPS|DDSD_BACKBUFFERCOUNT;

	mov	DWORD PTR _desc$5[ebp+4], 33		; 00000021H

; 842  : 			desc.ddsCaps.dwCaps=DDSCAPS_PRIMARYSURFACE|DDSCAPS_COMPLEX|DDSCAPS_FLIP;
; 843  : 
; 844  : 			desc.dwBackBufferCount=1;
; 845  : 			if( d3d ) desc.ddsCaps.dwCaps|=DDSCAPS_3DDEVICE;

	mov	ecx, 8728				; 00002218H
	mov	DWORD PTR _desc$5[ebp+20], 1
	test	bl, bl

; 846  : 
; 847  : 			if( dd->CreateSurface( &desc,&ps,0 )>=0 ){

	lea	edx, DWORD PTR _ps$4[ebp]
	mov	eax, 536				; 00000218H
	cmovne	eax, ecx
	mov	DWORD PTR _desc$5[ebp+104], eax
	mov	eax, DWORD PTR _dd$[ebp]
	push	0
	push	edx
	lea	edx, DWORD PTR _desc$5[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+24]
	test	eax, eax
	js	SHORT $LN6@openExclus

; 848  : 				//find back surface
; 849  : 				IDirectDrawSurface7 *bs;
; 850  : 				DDSCAPS2 caps={sizeof caps};
; 851  : 				caps.dwCaps=DDSCAPS_BACKBUFFER;
; 852  : 				if( ps->GetAttachedSurface( &caps,&bs )>=0 ){

	mov	eax, DWORD PTR _ps$4[ebp]
	lea	edx, DWORD PTR _bs$3[ebp]
	push	edx
	xorps	xmm0, xmm0
	mov	DWORD PTR _caps$6[ebp+12], 0
	movq	QWORD PTR _caps$6[ebp+4], xmm0
	lea	edx, DWORD PTR _caps$6[ebp]
	mov	DWORD PTR _caps$6[ebp], 4
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+48]
	test	eax, eax
	js	SHORT $LN7@openExclus

; 853  : 					return d_new gxGraphics( this,dd,ps,bs,d3d );

	push	2184					; 00000888H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN13@openExclus
	push	DWORD PTR _d3d$GSCopy$[ebp]
	mov	ecx, eax
	push	DWORD PTR _bs$3[ebp]
	push	DWORD PTR _ps$4[ebp]
	push	DWORD PTR _dd$[ebp]
	push	esi
	call	??0gxGraphics@@QAE@PAVgxRuntime@@PAUIDirectDraw7@@PAUIDirectDrawSurface7@@2_N@Z ; gxGraphics::gxGraphics
	jmp	SHORT $LN1@openExclus
$LN7@openExclus:

; 854  : 				}
; 855  : 				ps->Release();

	mov	eax, DWORD PTR _ps$4[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
$LN6@openExclus:

; 856  : 			}
; 857  : 			dd->RestoreDisplayMode();

	mov	eax, DWORD PTR _dd$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+76]
$LN4@openExclus:

; 858  : 		}
; 859  : 	}
; 860  : 	dd->Release();

	mov	eax, DWORD PTR _dd$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
$LN13@openExclus:

; 861  : 	return 0;

	xor	eax, eax
$LN1@openExclus:

; 862  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z$0:
	push	2184					; 00000888H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-176]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?openExclusiveGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z ENDP ; gxRuntime::openExclusiveGraphics
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
_TEXT	SEGMENT
$T2 = -288						; size = 4
_d3d$GSCopy$ = -284					; size = 1
_ps$3 = -280						; size = 4
_fs$4 = -276						; size = 4
_cp$5 = -272						; size = 4
_dd$ = -268						; size = 4
_desc$6 = -264						; size = 124
_desc$7 = -140						; size = 124
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_d$ = 16						; size = 4
_d3d$ = 20						; size = 1
?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z PROC ; gxRuntime::openWindowedGraphics, COMDAT
; _this$ = ecx

; 778  : gxGraphics *gxRuntime::openWindowedGraphics( int w,int h,int d,bool d3d ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 276				; 00000114H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	bl, BYTE PTR _d3d$[ebp]

; 779  : 
; 780  : 	IDirectDraw7 *dd;
; 781  : 	if( DirectDrawCreateEx( curr_driver->guid,(void**)&dd,IID_IDirectDraw7,0 )<0 ) return 0;

	lea	eax, DWORD PTR _dd$[ebp]
	push	0
	push	OFFSET _IID_IDirectDraw7
	push	eax
	mov	eax, DWORD PTR [esi+136]
	mov	BYTE PTR _d3d$GSCopy$[ebp], bl
	push	DWORD PTR [eax]
	call	_DirectDrawCreateEx@16
	test	eax, eax
	js	$LN16@openWindow

; 782  : 
; 783  : 	//set coop level
; 784  : 	if( dd->SetCooperativeLevel( hwnd,DDSCL_NORMAL )>=0 ){

	mov	eax, DWORD PTR _dd$[ebp]
	push	8
	push	DWORD PTR [esi]
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+80]
	test	eax, eax
	js	$LN4@openWindow

; 785  : 		//create primary surface
; 786  : 		IDirectDrawSurface7 *ps;
; 787  : 		DDSURFACEDESC2 desc={sizeof(desc)};

	push	120					; 00000078H
	lea	eax, DWORD PTR _desc$6[ebp+4]
	mov	DWORD PTR _desc$6[ebp], 124		; 0000007cH
	push	0
	push	eax
	call	_memset

; 788  : 		desc.dwFlags=DDSD_CAPS;
; 789  : 		desc.ddsCaps.dwCaps=DDSCAPS_PRIMARYSURFACE;
; 790  : 		if( dd->CreateSurface( &desc,&ps,0 )>=0 ){

	mov	eax, DWORD PTR _dd$[ebp]
	lea	edx, DWORD PTR _ps$3[ebp]
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _desc$6[ebp+4], 1
	mov	DWORD PTR _desc$6[ebp+104], 512		; 00000200H
	mov	ecx, DWORD PTR [eax]
	push	0
	push	edx
	lea	edx, DWORD PTR _desc$6[ebp]
	push	edx
	push	eax
	call	DWORD PTR [ecx+24]
	test	eax, eax
	js	$LN4@openWindow

; 791  : 			//create clipper
; 792  : 			IDirectDrawClipper *cp;
; 793  : 			if( dd->CreateClipper( 0,&cp,0 )>=0 ){

	mov	eax, DWORD PTR _dd$[ebp]
	lea	edx, DWORD PTR _cp$5[ebp]
	push	0
	push	edx
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+16]
	test	eax, eax
	js	$LN5@openWindow

; 794  : 				//attach clipper 
; 795  : 				if( ps->SetClipper( cp )>=0 ){

	mov	eax, DWORD PTR _ps$3[ebp]
	push	DWORD PTR _cp$5[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+112]
	test	eax, eax
	js	$LN9@openWindow

; 796  : 					//set clipper HWND
; 797  : 					if( cp->SetHWnd( 0,hwnd )>=0 ){

	mov	eax, DWORD PTR _cp$5[ebp]
	push	DWORD PTR [esi]
	push	0
	mov	ecx, DWORD PTR [eax]
	push	eax
	call	DWORD PTR [ecx+32]
	test	eax, eax
	js	$LN9@openWindow

; 798  : 						//create front buffer
; 799  : 						IDirectDrawSurface7 *fs;
; 800  : 						DDSURFACEDESC2 desc={sizeof(desc)};

	push	120					; 00000078H
	lea	eax, DWORD PTR _desc$7[ebp+4]
	mov	DWORD PTR _desc$7[ebp], 124		; 0000007cH
	push	0
	push	eax
	call	_memset

; 801  : 						desc.dwFlags=DDSD_WIDTH|DDSD_HEIGHT|DDSD_CAPS;
; 802  : 						desc.dwWidth=w;desc.dwHeight=h;

	mov	eax, DWORD PTR _w$[ebp]

; 803  : 						desc.ddsCaps.dwCaps=DDSCAPS_OFFSCREENPLAIN;
; 804  : 
; 805  : 						if( d3d ) desc.ddsCaps.dwCaps|=DDSCAPS_3DDEVICE;
; 806  : 
; 807  : 						if( dd->CreateSurface( &desc,&fs,0 )>=0 ){

	lea	edx, DWORD PTR _fs$4[ebp]
	mov	DWORD PTR _desc$7[ebp+12], eax
	add	esp, 12					; 0000000cH
	mov	eax, DWORD PTR _h$[ebp]
	mov	ecx, 8256				; 00002040H
	mov	DWORD PTR _desc$7[ebp+8], eax
	test	bl, bl
	mov	eax, 64					; 00000040H
	mov	DWORD PTR _desc$7[ebp+4], 7
	cmovne	eax, ecx
	mov	DWORD PTR _desc$7[ebp+104], eax
	mov	eax, DWORD PTR _dd$[ebp]
	push	0
	push	edx
	lea	edx, DWORD PTR _desc$7[ebp]
	mov	ecx, DWORD PTR [eax]
	push	edx
	push	eax
	call	DWORD PTR [ecx+24]
	test	eax, eax
	js	$LN9@openWindow

; 808  : 							if( timerID=timeSetEvent( 100,10,timerCallback,0,TIME_PERIODIC ) ){

	push	1
	push	0
	push	OFFSET ?timerCallback@@YGXIIKKK@Z	; timerCallback
	push	10					; 0000000aH
	push	100					; 00000064H
	call	DWORD PTR __imp__timeSetEvent@20
	mov	DWORD PTR ?timerID@@3IA, eax
	test	eax, eax
	je	SHORT $LN10@openWindow

; 809  : 								//Success!
; 810  : 								clipper=cp;

	mov	eax, DWORD PTR _cp$5[ebp]
	mov	DWORD PTR ?clipper@@3PAUIDirectDrawClipper@@A, eax

; 811  : 								primSurf=ps;

	mov	eax, DWORD PTR _ps$3[ebp]
	mov	DWORD PTR ?primSurf@@3PAUIDirectDrawSurface7@@A, eax

; 812  : 								mod_cnt=0;
; 813  : 								fs->AddRef();

	mov	eax, DWORD PTR _fs$4[ebp]
	push	eax
	mov	DWORD PTR ?mod_cnt@@3HA, 0
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+4]

; 814  : 								return d_new gxGraphics( this,dd,fs,fs,d3d );

	push	2184					; 00000888H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN16@openWindow
	push	DWORD PTR _d3d$GSCopy$[ebp]
	mov	ecx, DWORD PTR _fs$4[ebp]
	push	ecx
	push	ecx
	push	DWORD PTR _dd$[ebp]
	mov	ecx, eax
	push	esi
	call	??0gxGraphics@@QAE@PAVgxRuntime@@PAUIDirectDraw7@@PAUIDirectDrawSurface7@@2_N@Z ; gxGraphics::gxGraphics
	jmp	SHORT $LN1@openWindow
$LN10@openWindow:

; 815  : 							}
; 816  : 							fs->Release();

	mov	eax, DWORD PTR _fs$4[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
$LN9@openWindow:

; 817  : 						}
; 818  : 					}
; 819  : 				}
; 820  : 				cp->Release();

	mov	eax, DWORD PTR _cp$5[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
$LN5@openWindow:

; 821  : 			}
; 822  : 			ps->Release();

	mov	eax, DWORD PTR _ps$3[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
$LN4@openWindow:

; 823  : 		}
; 824  : 	}
; 825  : 	dd->Release();

	mov	eax, DWORD PTR _dd$[ebp]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+8]
$LN16@openWindow:

; 826  : 	return 0;

	xor	eax, eax
$LN1@openWindow:

; 827  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z$0:
	push	2184					; 00000888H
	mov	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?openWindowedGraphics@gxRuntime@@AAEPAVgxGraphics@@HHH_N@Z ENDP ; gxRuntime::openWindowedGraphics
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?setDisplayMode@gxRuntime@@AAE_NHHH_NPAUIDirectDraw7@@@Z
_TEXT	SEGMENT
_best_d$1$ = -392					; size = 4
_best_n$1$ = -388					; size = 4
_caps$1 = -384						; size = 380
__$ArrayPad$ = -4					; size = 4
_w$ = 8							; size = 4
_h$ = 12						; size = 4
_d$ = 16						; size = 4
_d3d$ = 20						; size = 1
_dirDraw$ = 24						; size = 4
?setDisplayMode@gxRuntime@@AAE_NHHH_NPAUIDirectDraw7@@@Z PROC ; gxRuntime::setDisplayMode, COMDAT
; _this$ = ecx

; 743  : bool gxRuntime::setDisplayMode( int w,int h,int d,bool d3d,IDirectDraw7 *dirDraw ){

	push	ebp
	mov	ebp, esp
	sub	esp, 392				; 00000188H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 744  : 
; 745  : 	if( d ) return dirDraw->SetDisplayMode( w,h,d,0,0 )>=0;

	mov	edx, DWORD PTR _d$[ebp]
	mov	eax, ecx
	push	edi
	mov	edi, DWORD PTR _dirDraw$[ebp]
	test	edx, edx
	je	SHORT $LN5@setDisplay
	mov	eax, DWORD PTR [edi]
	push	0
	push	0
	push	edx
	push	DWORD PTR _h$[ebp]
	push	DWORD PTR _w$[ebp]
	push	edi
	call	DWORD PTR [eax+84]
	xor	ecx, ecx
	test	eax, eax
	pop	edi
	setns	al

; 776  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN5@setDisplay:

; 746  : 
; 747  : 	int best_d=0;

	xor	ecx, ecx
	push	ebx

; 748  : 
; 749  : 	if( d3d ){

	mov	ebx, DWORD PTR _h$[ebp]
	push	esi
	mov	DWORD PTR _best_d$1$[ebp], ecx
	cmp	BYTE PTR _d3d$[ebp], cl
	je	SHORT $LN6@setDisplay

; 750  : #ifdef PRO
; 751  : 		int bd=curr_driver->d3d_desc.dwDeviceRenderBitDepth;

	mov	eax, DWORD PTR [eax+136]
	mov	eax, DWORD PTR [eax+156]

; 752  : 		if( bd & DDBD_32 ) best_d=32;

	test	eax, 256				; 00000100H
	je	SHORT $LN8@setDisplay
	mov	ecx, 32					; 00000020H
	jmp	$LN28@setDisplay
$LN8@setDisplay:

; 753  : 		else if( bd & DDBD_24 ) best_d=24;

	test	eax, 512				; 00000200H
	je	SHORT $LN10@setDisplay
	mov	ecx, 24					; 00000018H
	jmp	$LN28@setDisplay
$LN10@setDisplay:

; 754  : 		else if( bd & DDBD_16 ) best_d=16;

	test	eax, 1024				; 00000400H
	je	$LN21@setDisplay
	mov	ecx, 16					; 00000010H

; 755  : #endif
; 756  : 	}else{

	jmp	$LN28@setDisplay
$LN6@setDisplay:

; 757  : 		int best_n=0;

	mov	DWORD PTR _best_n$1$[ebp], ecx

; 758  : 		for( d=16;d<=32;d+=8 ){

	mov	esi, 16					; 00000010H
	npad	7
$LL4@setDisplay:

; 759  : 			if( dirDraw->SetDisplayMode( w,h,d,0,0 )<0 ) continue;

	mov	eax, DWORD PTR [edi]
	push	0
	push	0
	push	esi
	push	ebx
	push	DWORD PTR _w$[ebp]
	push	edi
	call	DWORD PTR [eax+84]
	test	eax, eax
	js	$LN2@setDisplay

; 760  : 			DDCAPS caps={ sizeof(caps)  };

	push	376					; 00000178H
	lea	eax, DWORD PTR _caps$1[ebp+4]
	mov	DWORD PTR _caps$1[ebp], 380		; 0000017cH
	push	0
	push	eax
	call	_memset

; 761  : 			dirDraw->GetCaps( &caps,0 );

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _caps$1[ebp]
	add	esp, 12					; 0000000cH
	push	0
	push	ecx
	push	edi
	call	DWORD PTR [eax+44]
	mov	ecx, DWORD PTR _caps$1[ebp+4]
	shr	ecx, 6
	and	ecx, 1

; 762  : 			int n=0;
; 763  : 			if( caps.dwCaps & DDCAPS_BLT ) ++n;
; 764  : 			if( caps.dwCaps & DDCAPS_BLTCOLORFILL ) ++n;

	test	DWORD PTR _caps$1[ebp+4], 67108864	; 04000000H
	lea	eax, DWORD PTR [ecx+1]
	cmove	eax, ecx

; 765  : 			if( caps.dwCKeyCaps & DDCKEYCAPS_SRCBLT ) ++n;

	test	DWORD PTR _caps$1[ebp+12], 512		; 00000200H
	lea	ecx, DWORD PTR [eax+1]
	cmove	ecx, eax

; 766  : 			if( caps.dwCaps2 & DDCAPS2_WIDESURFACES ) ++n;

	test	DWORD PTR _caps$1[ebp+8], 4096		; 00001000H
	lea	ebx, DWORD PTR [ecx+1]
	cmove	ebx, ecx
	cmp	ebx, 4

; 767  : 			if( n==4 ) return true;

	je	SHORT $LN24@setDisplay

; 768  : 			if( n>best_n ){

	mov	eax, DWORD PTR _best_d$1$[ebp]
	cmp	ebx, DWORD PTR _best_n$1$[ebp]

; 769  : 				best_d=d;
; 770  : 				best_n=n;
; 771  : 			}
; 772  : 			dirDraw->RestoreDisplayMode();

	push	edi
	cmovg	eax, esi
	mov	DWORD PTR _best_d$1$[ebp], eax
	mov	eax, DWORD PTR [edi]
	call	DWORD PTR [eax+76]
	cmp	ebx, DWORD PTR _best_n$1$[ebp]
	cmovle	ebx, DWORD PTR _best_n$1$[ebp]
	mov	DWORD PTR _best_n$1$[ebp], ebx
	mov	ebx, DWORD PTR _h$[ebp]
$LN2@setDisplay:

; 758  : 		for( d=16;d<=32;d+=8 ){

	add	esi, 8
	cmp	esi, 32					; 00000020H
	jle	$LL4@setDisplay

; 773  : 		}
; 774  : 	}
; 775  : 	return best_d ? dirDraw->SetDisplayMode( w,h,best_d,0,0 )>=0 : false;

	mov	ecx, DWORD PTR _best_d$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN21@setDisplay
$LN28@setDisplay:
	mov	eax, DWORD PTR [edi]
	push	0
	push	0
	push	ecx
	push	ebx
	push	DWORD PTR _w$[ebp]
	push	edi
	call	DWORD PTR [eax+84]
	xor	ecx, ecx
	test	eax, eax
	setns	cl
	jmp	SHORT $LN22@setDisplay
$LN24@setDisplay:
	pop	esi
	pop	ebx

; 767  : 			if( n==4 ) return true;

	mov	al, 1
	pop	edi

; 776  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN21@setDisplay:

; 773  : 		}
; 774  : 	}
; 775  : 	return best_d ? dirDraw->SetDisplayMode( w,h,best_d,0,0 )>=0 : false;

	xor	ecx, ecx
$LN22@setDisplay:
	mov	al, cl

; 776  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	pop	ebx
	xor	ecx, ebp
	pop	edi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?setDisplayMode@gxRuntime@@AAE_NHHH_NPAUIDirectDraw7@@@Z ENDP ; gxRuntime::setDisplayMode
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?restoreWindowState@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?restoreWindowState@gxRuntime@@AAEXXZ PROC		; gxRuntime::restoreWindowState, COMDAT
; _this$ = ecx

; 735  : void gxRuntime::restoreWindowState(){

	push	edi
	mov	edi, ecx

; 736  : 	SetWindowLong( hwnd,GWL_STYLE,t_style );

	push	DWORD PTR [edi+40]
	push	-16					; fffffff0H
	push	DWORD PTR [edi]
	call	DWORD PTR __imp__SetWindowLongA@12

; 737  : 	SetWindowPos( 

	mov	edx, DWORD PTR [edi+28]
	mov	eax, DWORD PTR [edi+36]
	push	36					; 00000024H
	sub	eax, edx
	push	eax
	mov	eax, DWORD PTR [edi+32]
	sub	eax, DWORD PTR [edi+24]
	push	eax
	push	edx
	push	DWORD PTR [edi+24]
	push	0
	push	DWORD PTR [edi]
	call	DWORD PTR __imp__SetWindowPos@28
	pop	edi

; 738  : 		hwnd,0,t_rect.left,t_rect.top,
; 739  : 		t_rect.right-t_rect.left,t_rect.bottom-t_rect.top,
; 740  : 		SWP_NOZORDER|SWP_FRAMECHANGED );
; 741  : }

	ret	0
?restoreWindowState@gxRuntime@@AAEXXZ ENDP		; gxRuntime::restoreWindowState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?backupWindowState@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?backupWindowState@gxRuntime@@AAEXXZ PROC		; gxRuntime::backupWindowState, COMDAT
; _this$ = ecx

; 730  : void gxRuntime::backupWindowState(){

	push	esi
	mov	esi, ecx

; 731  : 	GetWindowRect( hwnd,&t_rect );

	lea	eax, DWORD PTR [esi+24]
	push	eax
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__GetWindowRect@8

; 732  : 	t_style=GetWindowLong( hwnd,GWL_STYLE );

	push	-16					; fffffff0H
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__GetWindowLongA@8
	mov	DWORD PTR [esi+40], eax
	pop	esi

; 733  : }

	ret	0
?backupWindowState@gxRuntime@@AAEXXZ ENDP		; gxRuntime::backupWindowState
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?forceResume@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?forceResume@gxRuntime@@AAEXXZ PROC			; gxRuntime::forceResume, COMDAT
; _this$ = ecx

; 246  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	push	esi
	mov	esi, ecx
	jne	SHORT $LN2@forceResum

; 247  : 		SetForegroundWindow( hwnd );

	push	DWORD PTR [esi]
	call	DWORD PTR __imp__SetForegroundWindow@4

; 248  : 		ShowWindow( hwnd,SW_SHOWMAXIMIZED );

	push	3
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__ShowWindow@8
	pop	esi

; 251  : 	}
; 252  : }

	ret	0
$LN2@forceResum:
	pop	esi

; 249  : 	}else{
; 250  : 		resume();

	jmp	?resume@gxRuntime@@AAEXXZ		; gxRuntime::resume
?forceResume@gxRuntime@@AAEXXZ ENDP			; gxRuntime::forceResume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?resume@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?resume@gxRuntime@@AAEXXZ PROC				; gxRuntime::resume, COMDAT
; _this$ = ecx

; 219  : 	if( gfx_mode==3 ) ShowCursor(0);

	mov	eax, DWORD PTR ?gfx_mode@@3HA
	push	esi
	mov	esi, ecx
	cmp	eax, 3
	jne	SHORT $LN2@resume
	push	0
	call	DWORD PTR __imp__ShowCursor@4
	mov	eax, DWORD PTR ?gfx_mode@@3HA
$LN2@resume:

; 183  : 	if( !input ) return;

	mov	ecx, DWORD PTR [esi+12]

; 220  : 	busy=true;

	mov	BYTE PTR ?busy@@3_NA, 1

; 183  : 	if( !input ) return;

	test	ecx, ecx
	je	SHORT $LN5@resume

; 184  : 	if( gfx_mode==3 ){

	cmp	eax, 3
	jne	SHORT $LN8@resume

; 185  : 		if( use_di ){

	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN8@resume

; 186  : 			use_di=input->acquire();

	call	?acquire@gxInput@@QAE_NXZ		; gxInput::acquire
	movzx	eax, al
	mov	DWORD PTR [esi+140], eax
$LN8@resume:

; 187  : 		}else{
; 188  : 		}
; 189  : 	}
; 190  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]
	call	?reset@gxInput@@QAEXXZ			; gxInput::reset
$LN5@resume:

; 173  : 	if( auto_suspend ){

	cmp	BYTE PTR ?auto_suspend@@3_NA, 0
	je	SHORT $LN13@resume

; 174  : 		if( !graphics->restore() ) gfx_lost=true;

	mov	ecx, DWORD PTR [esi+16]
	call	?restore@gxGraphics@@QAE_NXZ		; gxGraphics::restore
	movzx	ecx, BYTE PTR ?gfx_lost@@3_NA
	test	al, al
	mov	edx, 1
	cmove	ecx, edx
	mov	BYTE PTR ?gfx_lost@@3_NA, cl
$LN13@resume:

; 163  : 	if( audio ) audio->resume();

	mov	ecx, DWORD PTR [esi+8]
	pop	esi
	test	ecx, ecx
	je	SHORT $LN16@resume
	call	?resume@gxAudio@@QAEXXZ			; gxAudio::resume
$LN16@resume:

; 221  : 	acquireInput();
; 222  : 	restoreGraphics();
; 223  : 	resumeAudio();
; 224  : 	suspended=false;
; 225  : 	busy=false;
; 226  : 
; 227  : 	if( debugger ) debugger->debugRun();

	mov	ecx, DWORD PTR ?debugger@@3PAVDebugger@@A
	mov	BYTE PTR ?suspended@@3_NA, 0
	mov	BYTE PTR ?busy@@3_NA, 0
	test	ecx, ecx
	je	SHORT $LN3@resume
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax]
$LN3@resume:

; 228  : }

	ret	0
?resume@gxRuntime@@AAEXXZ ENDP				; gxRuntime::resume
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?forceSuspend@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?forceSuspend@gxRuntime@@AAEXXZ PROC			; gxRuntime::forceSuspend, COMDAT
; _this$ = ecx

; 234  : 	if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN2@forceSuspe

; 235  : 		SetForegroundWindow( GetDesktopWindow() );

	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__SetForegroundWindow@4

; 236  : 		ShowWindow( GetDesktopWindow(),SW_SHOW );

	push	5
	call	DWORD PTR __imp__GetDesktopWindow@0
	push	eax
	call	DWORD PTR __imp__ShowWindow@8

; 239  : 	}
; 240  : }

	ret	0
$LN2@forceSuspe:

; 237  : 	}else{
; 238  : 		suspend();

	jmp	?suspend@gxRuntime@@AAEXXZ		; gxRuntime::suspend
?forceSuspend@gxRuntime@@AAEXXZ ENDP			; gxRuntime::forceSuspend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?suspend@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
?suspend@gxRuntime@@AAEXXZ PROC				; gxRuntime::suspend, COMDAT
; _this$ = ecx

; 202  : void gxRuntime::suspend(){

	push	esi
	mov	esi, ecx

; 203  : 	busy=true;

	mov	BYTE PTR ?busy@@3_NA, 1

; 159  : 	if( audio ) audio->pause();

	mov	ecx, DWORD PTR [esi+8]
	test	ecx, ecx
	je	SHORT $LN6@suspend
	call	?pause@gxAudio@@QAEXXZ			; gxAudio::pause
$LN6@suspend:

; 167  : 	if( auto_suspend ){

	cmp	BYTE PTR ?auto_suspend@@3_NA, 0
	je	SHORT $LN9@suspend

; 168  : 		graphics->backup();

	mov	ecx, DWORD PTR [esi+16]
	call	?backup@gxGraphics@@QAEXXZ		; gxGraphics::backup
$LN9@suspend:

; 194  : 	if( !input ) return;

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	SHORT $LN11@suspend

; 195  : 	if( gfx_mode==3 && use_di ) input->unacquire();

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN13@suspend
	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN13@suspend
	call	?unacquire@gxInput@@QAEXXZ		; gxInput::unacquire
$LN13@suspend:

; 196  : 	input->reset();

	mov	ecx, DWORD PTR [esi+12]
	call	?reset@gxInput@@QAEXXZ			; gxInput::reset
$LN11@suspend:

; 204  : 	pauseAudio();
; 205  : 	backupGraphics();
; 206  : 	unacquireInput();
; 207  : 	suspended=true;
; 208  : 	busy=false;
; 209  : 
; 210  : 	if( gfx_mode==3 ) ShowCursor(1);

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	mov	BYTE PTR ?suspended@@3_NA, 1
	mov	BYTE PTR ?busy@@3_NA, 0
	pop	esi
	jne	SHORT $LN2@suspend
	push	1
	call	DWORD PTR __imp__ShowCursor@4
$LN2@suspend:

; 211  : 
; 212  : 	if( debugger ) debugger->debugStop();

	mov	ecx, DWORD PTR ?debugger@@3PAVDebugger@@A
	test	ecx, ecx
	je	SHORT $LN3@suspend
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+4]
$LN3@suspend:

; 213  : }

	ret	0
?suspend@gxRuntime@@AAEXXZ ENDP				; gxRuntime::suspend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?paint@gxRuntime@@AAEXXZ
_TEXT	SEGMENT
_p$1 = -44						; size = 8
_src$2 = -36						; size = 16
_dest$3 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
?paint@gxRuntime@@AAEXXZ PROC				; gxRuntime::paint, COMDAT
; _this$ = ecx

; 257  : void gxRuntime::paint(){

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 258  : 	switch( gfx_mode ){

	mov	eax, DWORD PTR ?gfx_mode@@3HA
	dec	eax
	push	esi
	mov	esi, ecx
	cmp	eax, 1
	ja	$LN6@paint

; 259  : 	case 0:
; 260  : 		{
; 261  : 		}
; 262  : 		break;
; 263  : 	case 1:case 2:	//scaled windowed mode.
; 264  : 		{
; 265  : 			RECT src,dest;
; 266  : 			src.left=src.top=0;
; 267  : 			GetClientRect( hwnd,&dest );

	lea	eax, DWORD PTR _dest$3[ebp]
	mov	DWORD PTR _src$2[ebp+4], 0
	push	eax
	push	DWORD PTR [esi]
	mov	DWORD PTR _src$2[ebp], 0
	call	DWORD PTR __imp__GetClientRect@8

; 268  : 			src.right=gfx_mode==1 ? graphics->getWidth() : dest.right;

	mov	ecx, DWORD PTR ?gfx_mode@@3HA
	cmp	ecx, 1
	jne	SHORT $LN8@paint
	mov	ecx, DWORD PTR [esi+16]
	call	?getWidth@gxGraphics@@QBEHXZ		; gxGraphics::getWidth
	mov	ecx, DWORD PTR ?gfx_mode@@3HA
	jmp	SHORT $LN12@paint
$LN8@paint:
	mov	eax, DWORD PTR _dest$3[ebp+8]
$LN12@paint:
	mov	DWORD PTR _src$2[ebp+8], eax

; 269  : 			src.bottom=gfx_mode==1 ? graphics->getHeight() : dest.bottom;

	cmp	ecx, 1
	jne	SHORT $LN10@paint
	mov	ecx, DWORD PTR [esi+16]
	call	?getHeight@gxGraphics@@QBEHXZ		; gxGraphics::getHeight
	jmp	SHORT $LN13@paint
$LN10@paint:
	mov	eax, DWORD PTR _dest$3[ebp+12]
$LN13@paint:
	mov	DWORD PTR _src$2[ebp+12], eax

; 270  : 			POINT p;p.x=p.y=0;ClientToScreen( hwnd,&p );

	lea	eax, DWORD PTR _p$1[ebp]
	push	eax
	push	DWORD PTR [esi]
	mov	DWORD PTR _p$1[ebp+4], 0
	mov	DWORD PTR _p$1[ebp], 0
	call	DWORD PTR __imp__ClientToScreen@8

; 271  : 			dest.left+=p.x;dest.right+=p.x;

	mov	eax, DWORD PTR _p$1[ebp]
	add	DWORD PTR _dest$3[ebp], eax
	add	DWORD PTR _dest$3[ebp+8], eax

; 272  : 			dest.top+=p.y;dest.bottom+=p.y;

	mov	eax, DWORD PTR _p$1[ebp+4]

; 273  : 			gxCanvas *f=graphics->getFrontCanvas();

	mov	ecx, DWORD PTR [esi+16]
	add	DWORD PTR _dest$3[ebp+4], eax
	add	DWORD PTR _dest$3[ebp+12], eax
	call	?getFrontCanvas@gxGraphics@@QBEPAVgxCanvas@@XZ ; gxGraphics::getFrontCanvas

; 274  : 			primSurf->Blt( &dest,f->getSurface(),&src,0,0 );

	mov	ecx, DWORD PTR ?primSurf@@3PAUIDirectDrawSurface7@@A
	push	0
	push	0
	mov	esi, DWORD PTR [ecx]
	lea	ecx, DWORD PTR _src$2[ebp]
	push	ecx
	mov	ecx, eax
	call	?getSurface@gxCanvas@@QBEPAUIDirectDrawSurface7@@XZ ; gxCanvas::getSurface
	push	eax
	lea	eax, DWORD PTR _dest$3[ebp]
	push	eax
	push	DWORD PTR ?primSurf@@3PAUIDirectDrawSurface7@@A
	call	DWORD PTR [esi+20]
$LN6@paint:

; 275  : 		}
; 276  : 		break;
; 277  : 	case 3:
; 278  : 		{
; 279  : 			//exclusive mode
; 280  : 		}
; 281  : 		break;
; 282  : 	}
; 283  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?paint@gxRuntime@@AAEXXZ ENDP				; gxRuntime::paint
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ??1gxRuntime@@AAE@XZ
_TEXT	SEGMENT
_tc$ = -44						; size = 8
__Ans$2 = -36						; size = 8
__Ans$3 = -28						; size = 8
$T4 = -20						; size = 4
$T5 = -16						; size = 1
_t$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
??1gxRuntime@@AAE@XZ PROC				; gxRuntime::~gxRuntime, COMDAT
; _this$ = ecx

; 143  : gxRuntime::~gxRuntime(){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1gxRuntime@@AAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 144  : 	while( timers.size() ) freeTimer( *timers.begin() );

	cmp	DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A+4, 0
	je	$LN3@gxRuntime
	mov	ebx, DWORD PTR $T5[ebp]
	npad	6
$LL2@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A

; 1595 : 		return (_Eqrange(_Keyval));

	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A

; 43   : 		: _Ptr(_Pnode)

	mov	eax, DWORD PTR [eax]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 144  : 	while( timers.size() ) freeTimer( *timers.begin() );

	mov	edi, DWORD PTR [eax+16]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1595 : 		return (_Eqrange(_Keyval));

	lea	eax, DWORD PTR _t$[ebp]
	push	eax
	lea	eax, DWORD PTR __Ans$3[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 144  : 	while( timers.size() ) freeTimer( *timers.begin() );

	mov	DWORD PTR _t$[ebp], edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 1595 : 		return (_Eqrange(_Keyval));

	push	eax
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 1126 : 	return (_Distance1(_First, _Last, _Iter_cat_t<_InIt>()));

	push	ebx
	push	DWORD PTR __Ans$3[ebp+4]
	push	DWORD PTR __Ans$3[ebp]
	call	??$_Distance1@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@@std@@YGHV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@0@0Uinput_iterator_tag@0@@Z ; std::_Distance1<std::_Tree_const_iterator<std::_Tree_val<std::_Tree_simple_types<gxTimer *> > > >
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1120 : 	if( !timers.count( t ) ) return;

	test	eax, eax
	je	SHORT $LN550@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xtree

; 2025 : 		_Paircc _Ans(static_cast<const _Myt *>(this)->_Eqrange(_Keyval));

	lea	eax, DWORD PTR _t$[ebp]
	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	eax
	lea	eax, DWORD PTR __Ans$2[ebp]
	push	eax
	call	??$_Eqrange@PAVgxTimer@@@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@IBE?AU?$pair@V?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@std@@V12@@1@ABQAVgxTimer@@@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::_Eqrange<gxTimer *>

; 1462 : 		erase(_Where.first, _Where.second);

	push	DWORD PTR __Ans$2[ebp+4]
	lea	eax, DWORD PTR $T4[ebp]
	mov	ecx, OFFSET ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A
	push	DWORD PTR __Ans$2[ebp]
	push	eax
	call	?erase@?$_Tree@V?$_Tset_traits@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@$0A@@std@@@std@@QAE?AV?$_Tree_const_iterator@V?$_Tree_val@U?$_Tree_simple_types@PAVgxTimer@@@std@@@std@@@2@V32@0@Z ; std::_Tree<std::_Tset_traits<gxTimer *,std::less<gxTimer *>,std::allocator<gxTimer *>,0> >::erase
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 1122 : 	delete t;

	test	edi, edi
	je	SHORT $LN550@gxRuntime
	mov	ecx, edi
	call	??1gxTimer@@QAE@XZ			; gxTimer::~gxTimer
	push	20					; 00000014H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN550@gxRuntime:

; 144  : 	while( timers.size() ) freeTimer( *timers.begin() );

	cmp	DWORD PTR ?timers@@3V?$set@PAVgxTimer@@U?$less@PAVgxTimer@@@std@@V?$allocator@PAVgxTimer@@@3@@std@@A+4, 0
	jne	SHORT $LL2@gxRuntime
$LN3@gxRuntime:

; 145  : 	if( audio ) closeAudio( audio );

	mov	edi, DWORD PTR [esi+8]
	test	edi, edi
	je	SHORT $LN127@gxRuntime
	mov	ecx, edi
	call	??1gxAudio@@QAE@XZ			; gxAudio::~gxAudio
	push	4
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 689  : 	audio=0;

	mov	DWORD PTR [esi+8], 0
$LN127@gxRuntime:

; 146  : 	if( graphics ) closeGraphics( graphics );

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN5@gxRuntime
	push	eax
	mov	ecx, esi
	call	?closeGraphics@gxRuntime@@QAEXPAVgxGraphics@@@Z ; gxRuntime::closeGraphics
$LN5@gxRuntime:

; 147  : 	if( input ) closeInput( input );

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN6@gxRuntime
	push	eax
	mov	ecx, esi
	call	?closeInput@gxRuntime@@QAEXPAVgxInput@@@Z ; gxRuntime::closeInput
$LN6@gxRuntime:

; 148  : 	TIMECAPS tc;
; 149  : 	timeGetDevCaps( &tc,sizeof(tc) );

	push	8
	lea	eax, DWORD PTR _tc$[ebp]
	push	eax
	call	DWORD PTR __imp__timeGetDevCaps@8

; 150  : 	timeEndPeriod( tc.wPeriodMin );

	push	DWORD PTR _tc$[ebp]
	call	DWORD PTR __imp__timeEndPeriod@4

; 151  : 	denumGfx();

	mov	ecx, esi
	call	?denumGfx@gxRuntime@@AAEXXZ		; gxRuntime::denumGfx

; 152  : 	DestroyWindow( hwnd );

	push	DWORD PTR [esi]
	call	DWORD PTR __imp__DestroyWindow@4

; 153  : 	UnregisterClass( "Blitz Runtime Class",hinst );

	push	DWORD PTR [esi+4]
	push	OFFSET ??_C@_0BE@BCECDIAH@Blitz?5Runtime?5Class?$AA@
	call	DWORD PTR __imp__UnregisterClassA@8

; 154  : 
; 155  : 	CoUninitialize();

	call	DWORD PTR __imp__CoUninitialize@0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR [esi+124]
	test	ecx, ecx
	je	SHORT $LN139@gxRuntime

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	eax, DWORD PTR [esi+132]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	4
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	sar	eax, 2
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ecx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 1643 : 			this->_Myfirst() = pointer();

	mov	DWORD PTR [esi+124], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	DWORD PTR [esi+128], 0

; 1645 : 			this->_Myend() = pointer();

	mov	DWORD PTR [esi+132], 0
$LN139@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+116]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 156  : }

	lea	edi, DWORD PTR [esi+96]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN238@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [edi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN238@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN331@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN331@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 156  : }

	lea	edi, DWORD PTR [esi+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN343@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [edi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN343@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [edi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [edi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN436@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN436@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+64]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN448@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi+44]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN448@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+64], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+64], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+60], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN540@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi+44]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 156  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN540@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+44], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 156  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1gxRuntime@@AAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-48]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1gxRuntime@@AAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1gxRuntime@@AAE@XZ ENDP				; gxRuntime::~gxRuntime
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z
_TEXT	SEGMENT
_tc$ = -24						; size = 8
_this$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_hi$ = 8						; size = 4
_cl$ = 12						; size = 4
_hw$ = 16						; size = 4
??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z PROC ; gxRuntime::gxRuntime, COMDAT
; _this$ = ecx

; 122  : pointer_visible(true),audio(0),input(0),graphics(0),fileSystem(0),use_di(false){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$[ebp], edi

; 121  : hinst(hi),cmd_line(cl),hwnd(hw),curr_driver(0),enum_all(false),

	mov	eax, DWORD PTR _hw$[ebp]
	lea	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _hi$[ebp]
	mov	DWORD PTR [edi+4], eax
	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
	mov	DWORD PTR [edi+16], 0
	mov	DWORD PTR [edi+20], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN131@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN132@gxRuntime
$LN131@gxRuntime:
	mov	eax, ecx
$LN132@gxRuntime:

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR _cl$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 122  : pointer_visible(true),audio(0),input(0),graphics(0),fileSystem(0),use_di(false){

	lea	eax, DWORD PTR [edi+72]
	mov	BYTE PTR [edi+68], 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 121  : hinst(hi),cmd_line(cl),hwnd(hw),curr_driver(0),enum_all(false),

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN243@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN243@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 122  : pointer_visible(true),audio(0),input(0),graphics(0),fileSystem(0),use_di(false){

	lea	eax, DWORD PTR [edi+96]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [eax+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [eax+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN354@gxRuntime
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN354@gxRuntime:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 122  : pointer_visible(true),audio(0),input(0),graphics(0),fileSystem(0),use_di(false){

	lea	esi, DWORD PTR [edi+124]
	mov	BYTE PTR [edi+120], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector

; 485  : 		: _Myfirst(),

	mov	DWORD PTR [esi], 0

; 486  : 		_Mylast(),

	mov	DWORD PTR [esi+4], 0

; 487  : 		_Myend()

	mov	DWORD PTR [esi+8], 0
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 124  : 	CoInitialize( 0 );

	push	0
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	DWORD PTR [edi+136], 0
	mov	DWORD PTR [edi+140], 0
	call	DWORD PTR __imp__CoInitialize@4

; 1040 : 	denumGfx();

	mov	ecx, edi
	call	?denumGfx@gxRuntime@@AAEXXZ		; gxRuntime::denumGfx

; 1041 : 	if( enum_all ){

	cmp	BYTE PTR [edi+120], 0
	je	SHORT $LN370@gxRuntime

; 1042 : 		DirectDrawEnumerateEx( enumDriver,&drivers,DDENUM_ATTACHEDSECONDARYDEVICES|DDENUM_NONDISPLAYDEVICES );

	push	5

; 1043 : 	}else{

	jmp	SHORT $LN375@gxRuntime
$LN370@gxRuntime:

; 1044 : 		DirectDrawEnumerateEx( enumDriver,&drivers,0 );

	push	0
$LN375@gxRuntime:
	push	esi
	push	OFFSET ?enumDriver@@YGHPAU_GUID@@PAD1PAXPAUHMONITOR__@@@Z ; enumDriver
	call	_DirectDrawEnumerateExA@12

; 125  : 
; 126  : 	enumGfx();
; 127  : 	TIMECAPS tc;
; 128  : 	timeGetDevCaps( &tc,sizeof(tc) );

	push	8
	lea	eax, DWORD PTR _tc$[ebp]
	push	eax
	call	DWORD PTR __imp__timeGetDevCaps@8

; 129  : 	timeBeginPeriod( tc.wPeriodMin );

	push	DWORD PTR _tc$[ebp]
	call	DWORD PTR __imp__timeBeginPeriod@4

; 130  : 
; 131  : 	memset( &osinfo,0,sizeof(osinfo) );

	push	148					; 00000094H
	lea	esi, DWORD PTR [edi+144]
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH

; 132  : 	osinfo.dwOSVersionInfoSize=sizeof(osinfo);

	mov	DWORD PTR [esi], 148			; 00000094H

; 133  : 	GetVersionEx( &osinfo );

	push	esi
	call	DWORD PTR __imp__GetVersionExA@4

; 134  : 
; 135  : 	HMODULE ddraw=LoadLibraryA( "ddraw.dll" );

	push	OFFSET ??_C@_09FCFFOIDA@ddraw?4dll?$AA@
	call	DWORD PTR __imp__LoadLibraryA@4
	mov	esi, eax

; 136  : 	if( ddraw ){

	test	esi, esi
	je	SHORT $LN373@gxRuntime

; 137  : 		SetAppCompatDataFunc SetAppCompatData=(SetAppCompatDataFunc)GetProcAddress( ddraw,"SetAppCompatData" );

	push	OFFSET ??_C@_0BB@HABCIGJF@SetAppCompatData?$AA@
	push	esi
	call	DWORD PTR __imp__GetProcAddress@8

; 138  : 		if( SetAppCompatData ) SetAppCompatData( 12,0 );

	test	eax, eax
	je	SHORT $LN3@gxRuntime
	push	0
	push	12					; 0000000cH
	call	eax
$LN3@gxRuntime:

; 139  : 		FreeLibrary( ddraw );

	push	esi
	call	DWORD PTR __imp__FreeLibrary@4
$LN373@gxRuntime:

; 140  : 	}
; 141  : }

	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 44					; 0000002cH
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$1:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 72					; 00000048H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 96					; 00000060H
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z$3:
	mov	ecx, DWORD PTR _this$[ebp]
	add	ecx, 124				; 0000007cH
	jmp	??1?$vector@PAUGfxDriver@gxRuntime@@V?$allocator@PAUGfxDriver@gxRuntime@@@std@@@std@@QAE@XZ ; std::vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >::~vector<gxRuntime::GfxDriver *,std::allocator<gxRuntime::GfxDriver *> >
__ehhandler$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-24]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0gxRuntime@@AAE@PAUHINSTANCE__@@ABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@PAUHWND__@@@Z ENDP ; gxRuntime::gxRuntime
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?windowProc@gxRuntime@@QAEJPAUHWND__@@IIJ@Z
_TEXT	SEGMENT
_p$1 = -92						; size = 8
_p$2 = -92						; size = 8
_x$1$ = -88						; size = 4
_ps$ = -84						; size = 64
_rect$3 = -20						; size = 16
_r$4 = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_hwnd$ = 8						; size = 4
_msg$ = 12						; size = 4
_wparam$ = 16						; size = 4
_lparam$ = 20						; size = 4
?windowProc@gxRuntime@@QAEJPAUHWND__@@IIJ@Z PROC	; gxRuntime::windowProc, COMDAT
; _this$ = ecx

; 342  : LRESULT gxRuntime::windowProc( HWND hwnd,UINT msg,WPARAM wparam,LPARAM lparam ){

	push	ebp
	mov	ebp, esp
	sub	esp, 92					; 0000005cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 343  : 
; 344  : 	if( busy ){

	cmp	BYTE PTR ?busy@@3_NA, 0
	push	esi
	push	edi
	mov	edi, DWORD PTR _hwnd$[ebp]
	mov	esi, ecx
	je	SHORT $LN6@windowProc

; 345  : 		return DefWindowProc( hwnd,msg,wparam,lparam );

	push	DWORD PTR _lparam$[ebp]
	push	DWORD PTR _wparam$[ebp]
	push	DWORD PTR _msg$[ebp]
	push	edi
	call	DWORD PTR __imp__DefWindowProcA@16
	pop	edi
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN6@windowProc:

; 346  : 	}
; 347  : 
; 348  : 	PAINTSTRUCT ps;
; 349  : 
; 350  : 	//handle 'special' messages!
; 351  : 	switch( msg ){

	mov	edx, DWORD PTR _msg$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _wparam$[ebp]
	lea	eax, DWORD PTR [edx-15]
	cmp	eax, 17					; 00000011H
	ja	$LN109@windowProc
	movzx	eax, BYTE PTR $LN108@windowProc[eax]
	jmp	DWORD PTR $LN123@windowProc[eax*4]
$LN7@windowProc:

; 352  : 	case WM_PAINT:
; 353  : 		if( gfx_mode && !auto_suspend ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 0
	je	SHORT $LN9@windowProc
	cmp	BYTE PTR ?auto_suspend@@3_NA, 0
	jne	SHORT $LN9@windowProc

; 354  : 			if( !graphics->restore() ) gfx_lost=true;

	mov	ecx, DWORD PTR [esi+16]
	call	?restore@gxGraphics@@QAE_NXZ		; gxGraphics::restore
	movzx	edx, BYTE PTR ?gfx_lost@@3_NA
	test	al, al
	mov	ecx, 1
	cmove	edx, ecx
	mov	BYTE PTR ?gfx_lost@@3_NA, dl
$LN9@windowProc:

; 355  : 		}
; 356  : 		BeginPaint( hwnd,&ps );

	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__BeginPaint@8

; 357  : 		paint();

	mov	ecx, esi
	call	?paint@gxRuntime@@AAEXXZ		; gxRuntime::paint

; 358  : 		EndPaint( hwnd,&ps );

	lea	eax, DWORD PTR _ps$[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__EndPaint@8

; 359  : 		return DefWindowProc( hwnd,msg,wparam,lparam );

	push	DWORD PTR _lparam$[ebp]
	push	DWORD PTR _wparam$[ebp]
	push	DWORD PTR _msg$[ebp]
	jmp	$LN118@windowProc
$LN10@windowProc:

; 360  : 	case WM_ERASEBKGND:
; 361  : 		return gfx_mode ? 1 : DefWindowProc( hwnd,msg,wparam,lparam );

	cmp	DWORD PTR ?gfx_mode@@3HA, 0
	jne	$LN121@windowProc
	push	DWORD PTR _lparam$[ebp]
	push	DWORD PTR _wparam$[ebp]
	jmp	$LN119@windowProc
$LN11@windowProc:

; 362  : 	case WM_CLOSE:
; 363  : 		if( app_close.size() ){

	cmp	DWORD PTR [esi+112], 0
	je	SHORT $LN13@windowProc
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+92], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 320  : 		return (_Myval2);

	lea	eax, DWORD PTR [esi+72]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN85@windowProc
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN85@windowProc:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+116], 16			; 00000010H
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility

; 320  : 		return (_Myval2);

	lea	ecx, DWORD PTR [esi+96]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN102@windowProc
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN102@windowProc:
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 364  : 			int n=MessageBox( hwnd,app_close.c_str(),app_title.c_str(),MB_OKCANCEL|MB_ICONWARNING|MB_SETFOREGROUND|MB_TOPMOST );

	push	327729					; 00050031H
	push	eax
	push	ecx
	push	edi
	call	DWORD PTR __imp__MessageBoxA@16

; 365  : 			if( n!=IDOK ) return 0;

	cmp	eax, 1
	jne	$LN4@windowProc
$LN13@windowProc:

; 491  : 	PostMessage( hwnd,WM_END,0,0 );

	push	0
	push	0
	push	1027					; 00000403H
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__PostMessageA@16
	pop	ebx
	pop	edi

; 366  : 		}
; 367  : 		asyncEnd();
; 368  : 		return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN14@windowProc:

; 369  : 	case WM_SETCURSOR:
; 370  : 		if( !suspended ){

	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	$LN109@windowProc

; 371  : 			if( gfx_mode==3 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	je	SHORT $LN120@windowProc

; 372  : 				SetCursor( 0 );
; 373  : 				return 1; 
; 374  : 			}else if( !pointer_visible ){

	cmp	BYTE PTR [esi+68], 0
	jne	$LN109@windowProc

; 375  : 				POINT p;
; 376  : 				GetCursorPos( &p );

	lea	eax, DWORD PTR _p$2[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 377  : 				ScreenToClient( hwnd,&p );

	lea	eax, DWORD PTR _p$2[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__ScreenToClient@8

; 378  : 				RECT r;GetClientRect( hwnd,&r );

	lea	eax, DWORD PTR _r$4[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__GetClientRect@8

; 379  : 				if( p.x>=0 && p.y>=0 && p.x<r.right && p.y<r.bottom ){

	mov	ecx, DWORD PTR _p$2[ebp]
	test	ecx, ecx
	js	SHORT $LN115@windowProc
	mov	eax, DWORD PTR _p$2[ebp+4]
	test	eax, eax
	js	SHORT $LN115@windowProc
	cmp	ecx, DWORD PTR _r$4[ebp+8]
	jge	SHORT $LN115@windowProc
	cmp	eax, DWORD PTR _r$4[ebp+12]
	jge	SHORT $LN115@windowProc
$LN120@windowProc:

; 380  : 					SetCursor( 0 );

	push	0
	call	DWORD PTR __imp__SetCursor@4
$LN121@windowProc:

; 381  : 					return 1;

	pop	ebx
	pop	edi
	mov	eax, 1
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN20@windowProc:

; 382  : 				}
; 383  : 			}
; 384  : 		}
; 385  : 		break;
; 386  : 	case WM_ACTIVATEAPP:
; 387  : 		if( auto_suspend ){

	cmp	BYTE PTR ?auto_suspend@@3_NA, 0
	je	SHORT $LN109@windowProc

; 388  : 			if( wparam ){

	test	ebx, ebx
	je	SHORT $LN22@windowProc

; 389  : 				if( suspended ) resume();

	cmp	BYTE PTR ?suspended@@3_NA, 0
	je	SHORT $LN109@windowProc
	call	?resume@gxRuntime@@AAEXXZ		; gxRuntime::resume

; 390  : 			}else{

	jmp	SHORT $LN115@windowProc
$LN22@windowProc:

; 391  : 				if( !suspended ) suspend();

	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	SHORT $LN109@windowProc
	call	?suspend@gxRuntime@@AAEXXZ		; gxRuntime::suspend
$LN115@windowProc:
	mov	edx, DWORD PTR _msg$[ebp]
$LN109@windowProc:

; 392  : 			}
; 393  : 		}
; 394  : 		break;
; 395  : 	}
; 396  : 
; 397  : 	if( !input || suspended ) return DefWindowProc( hwnd,msg,wparam,lparam );

	mov	ecx, DWORD PTR [esi+12]
	test	ecx, ecx
	je	$LN27@windowProc
	cmp	BYTE PTR ?suspended@@3_NA, 0
	jne	$LN27@windowProc

; 398  : 
; 399  : 	if( gfx_mode==3 && use_di ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN28@windowProc
	cmp	DWORD PTR [esi+140], 0
	je	SHORT $LN28@windowProc

; 400  : 		use_di=input->acquire();

	call	?acquire@gxInput@@QAE_NXZ		; gxInput::acquire

; 401  : 		return DefWindowProc( hwnd,msg,wparam,lparam );

	push	DWORD PTR _lparam$[ebp]
	movzx	eax, al
	push	ebx
	push	DWORD PTR _msg$[ebp]
	mov	DWORD PTR [esi+140], eax
	jmp	$LN118@windowProc
$LN28@windowProc:

; 402  : 	}
; 403  : 
; 404  : 	static const int MK_ALLBUTTONS=MK_LBUTTON|MK_RBUTTON|MK_MBUTTON;
; 405  : 
; 406  : 	//handle input messages
; 407  : 	switch( msg ){

	cmp	edx, 512				; 00000200H
	ja	$LN59@windowProc
	je	$LN38@windowProc
	lea	eax, DWORD PTR [edx-256]
	cmp	eax, 5
	ja	$LN27@windowProc
	jmp	DWORD PTR $LN124@windowProc[eax*4]
$LN50@windowProc:

; 453  : 		break;
; 454  : 	case WM_KEYDOWN:case WM_SYSKEYDOWN:
; 455  : 		if( lparam & 0x40000000 ) break;

	mov	edx, DWORD PTR _lparam$[ebp]
	test	edx, 1073741824				; 40000000H
	jne	$LN4@windowProc

; 456  : 		if( int n=((lparam>>17)&0x80)|((lparam>>16)&0x7f) ) input->wm_keydown( n );

	mov	eax, edx
	and	edx, 8323072				; 007f0000H
	sar	eax, 1
	and	eax, 8388608				; 00800000H
	or	eax, edx
	shr	eax, 16					; 00000010H
	test	eax, eax
	je	$LN4@windowProc
	push	eax
	call	?wm_keydown@gxInput@@QAEXH@Z		; gxInput::wm_keydown
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN53@windowProc:

; 457  : 		break;
; 458  : 	case WM_KEYUP:case WM_SYSKEYUP:
; 459  : 		if( int n=((lparam>>17)&0x80)|((lparam>>16)&0x7f) ) input->wm_keyup( n );

	mov	eax, DWORD PTR _lparam$[ebp]
	mov	edx, eax
	sar	edx, 1
	and	eax, 8323072				; 007f0000H
	and	edx, 8388608				; 00800000H
	or	edx, eax
	shr	edx, 16					; 00000010H
	test	edx, edx
	je	$LN4@windowProc
	push	edx
	call	?wm_keyup@gxInput@@QAEXH@Z		; gxInput::wm_keyup
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN38@windowProc:

; 431  : 		break;
; 432  : 	case WM_MOUSEMOVE:
; 433  : 		if( !graphics ) break;

	cmp	DWORD PTR [esi+16], 0
	je	$LN4@windowProc

; 434  : 		if( gfx_mode==3 && !use_di ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 3
	jne	SHORT $LN40@windowProc
	cmp	DWORD PTR [esi+140], 0
	jne	SHORT $LN40@windowProc

; 435  : 			POINT p;GetCursorPos( &p );

	lea	eax, DWORD PTR _p$1[ebp]
	push	eax
	call	DWORD PTR __imp__GetCursorPos@4

; 436  : 			input->wm_mousemove( p.x,p.y );

	push	DWORD PTR _p$1[ebp+4]
	mov	ecx, DWORD PTR [esi+12]
	push	DWORD PTR _p$1[ebp]
	call	?wm_mousemove@gxInput@@QAEXHH@Z		; gxInput::wm_mousemove
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN40@windowProc:

; 437  : 		}else{
; 438  : 			int x=(short)(lparam&0xffff),y=lparam>>16;

	mov	ebx, DWORD PTR _lparam$[ebp]
	movsx	eax, bx
	sar	ebx, 16					; 00000010H

; 439  : 			if( gfx_mode==1 ){

	cmp	DWORD PTR ?gfx_mode@@3HA, 1
	mov	DWORD PTR _x$1$[ebp], eax
	jne	SHORT $LN116@windowProc

; 440  : 				RECT rect;GetClientRect( hwnd,&rect );

	lea	eax, DWORD PTR _rect$3[ebp]
	push	eax
	push	edi
	call	DWORD PTR __imp__GetClientRect@8

; 441  : 				x=x*graphics->getWidth()/(rect.right-rect.left);

	mov	ecx, DWORD PTR [esi+16]
	call	?getWidth@gxGraphics@@QBEHXZ		; gxGraphics::getWidth
	imul	eax, DWORD PTR _x$1$[ebp]
	mov	ecx, DWORD PTR _rect$3[ebp+8]
	sub	ecx, DWORD PTR _rect$3[ebp]
	cdq
	idiv	ecx

; 442  : 				y=y*graphics->getHeight()/(rect.bottom-rect.top);

	mov	ecx, DWORD PTR [esi+16]
	mov	edi, eax
	call	?getHeight@gxGraphics@@QBEHXZ		; gxGraphics::getHeight
	mov	ecx, DWORD PTR _rect$3[ebp+12]
	sub	ecx, DWORD PTR _rect$3[ebp+4]
	imul	eax, ebx
	cdq
	idiv	ecx
	mov	ebx, eax
	jmp	SHORT $LN42@windowProc
$LN116@windowProc:
	mov	edi, eax
$LN42@windowProc:

; 443  : 			}
; 444  : 			if( x<0 ) x=0;

	test	edi, edi
	jns	SHORT $LN43@windowProc
	xor	edi, edi
	jmp	SHORT $LN45@windowProc
$LN43@windowProc:

; 445  : 			else if( x>=graphics->getWidth() ) x=graphics->getWidth()-1;

	mov	ecx, DWORD PTR [esi+16]
	call	?getWidth@gxGraphics@@QBEHXZ		; gxGraphics::getWidth
	cmp	edi, eax
	jl	SHORT $LN45@windowProc
	mov	ecx, DWORD PTR [esi+16]
	call	?getWidth@gxGraphics@@QBEHXZ		; gxGraphics::getWidth
	lea	edi, DWORD PTR [eax-1]
$LN45@windowProc:

; 446  : 			if( y<0 ) y=0;

	test	ebx, ebx
	jns	SHORT $LN46@windowProc

; 448  : 			input->wm_mousemove( x,y );

	mov	ecx, DWORD PTR [esi+12]
	xor	ebx, ebx
	push	ebx
	push	edi
	call	?wm_mousemove@gxInput@@QAEXHH@Z		; gxInput::wm_mousemove
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN46@windowProc:

; 447  : 			else if( y>=graphics->getHeight() ) y=graphics->getHeight()-1;

	mov	ecx, DWORD PTR [esi+16]
	call	?getHeight@gxGraphics@@QBEHXZ		; gxGraphics::getHeight
	cmp	ebx, eax
	jl	SHORT $LN48@windowProc
	mov	ecx, DWORD PTR [esi+16]
	call	?getHeight@gxGraphics@@QBEHXZ		; gxGraphics::getHeight
	lea	ebx, DWORD PTR [eax-1]
$LN48@windowProc:

; 448  : 			input->wm_mousemove( x,y );

	mov	ecx, DWORD PTR [esi+12]
	push	ebx
	push	edi
	call	?wm_mousemove@gxInput@@QAEXHH@Z		; gxInput::wm_mousemove
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN59@windowProc:

; 402  : 	}
; 403  : 
; 404  : 	static const int MK_ALLBUTTONS=MK_LBUTTON|MK_RBUTTON|MK_MBUTTON;
; 405  : 
; 406  : 	//handle input messages
; 407  : 	switch( msg ){

	lea	eax, DWORD PTR [edx-513]
	cmp	eax, 9
	ja	$LN27@windowProc
	jmp	DWORD PTR $LN125@windowProc[eax*4]
$LN29@windowProc:

; 408  : 	case WM_LBUTTONDOWN:
; 409  : 		input->wm_mousedown(1);

	push	1
	call	?wm_mousedown@gxInput@@QAEXH@Z		; gxInput::wm_mousedown

; 410  : 		SetCapture(hwnd);

	push	edi
	call	DWORD PTR __imp__SetCapture@4
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN30@windowProc:

; 411  : 		break;
; 412  : 	case WM_LBUTTONUP:
; 413  : 		input->wm_mouseup(1);

	push	1
	call	?wm_mouseup@gxInput@@QAEXH@Z		; gxInput::wm_mouseup

; 414  : 		if( !(wparam&MK_ALLBUTTONS) ) ReleaseCapture();

	test	bl, 19					; 00000013H
	jne	$LN4@windowProc
	call	DWORD PTR __imp__ReleaseCapture@0
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN32@windowProc:

; 415  : 		break;
; 416  : 	case WM_RBUTTONDOWN:
; 417  : 		input->wm_mousedown(2);

	push	2
	call	?wm_mousedown@gxInput@@QAEXH@Z		; gxInput::wm_mousedown

; 418  : 		SetCapture( hwnd );

	push	edi
	call	DWORD PTR __imp__SetCapture@4
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN33@windowProc:

; 419  : 		break;
; 420  : 	case WM_RBUTTONUP:
; 421  : 		input->wm_mouseup(2);

	push	2
	call	?wm_mouseup@gxInput@@QAEXH@Z		; gxInput::wm_mouseup

; 422  : 		if( !(wparam&MK_ALLBUTTONS) ) ReleaseCapture();

	test	bl, 19					; 00000013H
	jne	SHORT $LN4@windowProc
	call	DWORD PTR __imp__ReleaseCapture@0
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN35@windowProc:

; 423  : 		break;
; 424  : 	case WM_MBUTTONDOWN:
; 425  : 		input->wm_mousedown(3);

	push	3
	call	?wm_mousedown@gxInput@@QAEXH@Z		; gxInput::wm_mousedown

; 426  : 		SetCapture( hwnd );

	push	edi
	call	DWORD PTR __imp__SetCapture@4
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN36@windowProc:

; 427  : 		break;
; 428  : 	case WM_MBUTTONUP:
; 429  : 		input->wm_mouseup(3);

	push	3
	call	?wm_mouseup@gxInput@@QAEXH@Z		; gxInput::wm_mouseup

; 430  : 		if( !(wparam&MK_ALLBUTTONS) ) ReleaseCapture();

	test	bl, 19					; 00000013H
	jne	SHORT $LN4@windowProc
	call	DWORD PTR __imp__ReleaseCapture@0
	pop	ebx
	pop	edi

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN49@windowProc:

; 449  : 		}
; 450  : 		break;
; 451  : 	case WM_MOUSEWHEEL:
; 452  : 		input->wm_mousewheel( (short)HIWORD( wparam ) );

	shr	ebx, 16					; 00000010H
	movsx	eax, bx
	push	eax
	call	?wm_mousewheel@gxInput@@QAEXH@Z		; gxInput::wm_mousewheel
$LN4@windowProc:

; 460  : 		break;
; 461  : 	default:
; 462  : 		return DefWindowProc( hwnd,msg,wparam,lparam );
; 463  : 	}
; 464  : 
; 465  : 	return 0;

	pop	ebx
	pop	edi
	xor	eax, eax
	pop	esi

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN27@windowProc:

; 392  : 			}
; 393  : 		}
; 394  : 		break;
; 395  : 	}
; 396  : 
; 397  : 	if( !input || suspended ) return DefWindowProc( hwnd,msg,wparam,lparam );

	push	DWORD PTR _lparam$[ebp]
	push	ebx
$LN119@windowProc:
	push	edx
$LN118@windowProc:
	push	edi
	call	DWORD PTR __imp__DefWindowProcA@16

; 466  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	ebx
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
	npad	2
$LN123@windowProc:
	DD	$LN7@windowProc
	DD	$LN11@windowProc
	DD	$LN10@windowProc
	DD	$LN20@windowProc
	DD	$LN14@windowProc
	DD	$LN109@windowProc
$LN108@windowProc:
	DB	0
	DB	1
	DB	5
	DB	5
	DB	5
	DB	2
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	5
	DB	3
	DB	5
	DB	5
	DB	5
	DB	4
	npad	2
$LN124@windowProc:
	DD	$LN50@windowProc
	DD	$LN53@windowProc
	DD	$LN27@windowProc
	DD	$LN27@windowProc
	DD	$LN50@windowProc
	DD	$LN53@windowProc
$LN125@windowProc:
	DD	$LN29@windowProc
	DD	$LN30@windowProc
	DD	$LN27@windowProc
	DD	$LN32@windowProc
	DD	$LN33@windowProc
	DD	$LN27@windowProc
	DD	$LN35@windowProc
	DD	$LN36@windowProc
	DD	$LN27@windowProc
	DD	$LN49@windowProc
?windowProc@gxRuntime@@QAEJPAUHWND__@@IIJ@Z ENDP	; gxRuntime::windowProc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?moveMouse@gxRuntime@@QAEXHH@Z
_TEXT	SEGMENT
_p$ = -28						; size = 8
_rect$ = -20						; size = 16
__$ArrayPad$ = -4					; size = 4
_x$ = 8							; size = 4
_y$ = 12						; size = 4
?moveMouse@gxRuntime@@QAEXHH@Z PROC			; gxRuntime::moveMouse, COMDAT
; _this$ = ecx

; 319  : void gxRuntime::moveMouse( int x,int y ){

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax

; 320  : 	POINT p;
; 321  : 	RECT rect;
; 322  : 	switch( gfx_mode ){

	mov	eax, DWORD PTR ?gfx_mode@@3HA
	push	esi
	mov	esi, ecx
	push	edi
	sub	eax, 1
	je	SHORT $LN4@moveMouse
	sub	eax, 1
	je	SHORT $LN10@moveMouse
	sub	eax, 1
	jne	SHORT $LN1@moveMouse

; 329  : 		break;
; 330  : 	case 3:
; 331  : 		if( use_di ) return;

	cmp	DWORD PTR [esi+140], eax
	jne	SHORT $LN1@moveMouse

; 332  : 		break;

	mov	eax, DWORD PTR _y$[ebp]
	mov	ecx, DWORD PTR _x$[ebp]
	jmp	SHORT $LN2@moveMouse
$LN10@moveMouse:

; 326  : 		y=y*(rect.bottom-rect.top)/graphics->getHeight();

	mov	eax, DWORD PTR _y$[ebp]
	mov	edi, DWORD PTR _x$[ebp]
	jmp	SHORT $LN5@moveMouse
$LN4@moveMouse:

; 323  : 	case 1:
; 324  : 		GetClientRect( hwnd,&rect );

	lea	eax, DWORD PTR _rect$[ebp]
	push	eax
	push	DWORD PTR [esi]
	call	DWORD PTR __imp__GetClientRect@8

; 325  : 		x=x*(rect.right-rect.left)/graphics->getWidth();

	mov	ecx, DWORD PTR [esi+16]
	call	?getWidth@gxGraphics@@QBEHXZ		; gxGraphics::getWidth
	mov	ecx, eax
	mov	eax, DWORD PTR _rect$[ebp+8]
	sub	eax, DWORD PTR _rect$[ebp]
	imul	eax, DWORD PTR _x$[ebp]
	cdq
	idiv	ecx

; 326  : 		y=y*(rect.bottom-rect.top)/graphics->getHeight();

	mov	ecx, DWORD PTR [esi+16]
	mov	edi, eax
	call	?getHeight@gxGraphics@@QBEHXZ		; gxGraphics::getHeight
	mov	ecx, eax
	mov	eax, DWORD PTR _rect$[ebp+12]
	sub	eax, DWORD PTR _rect$[ebp+4]
	imul	eax, DWORD PTR _y$[ebp]
	cdq
	idiv	ecx
$LN5@moveMouse:

; 327  : 	case 2:
; 328  : 		p.x=x;p.y=y;ClientToScreen( hwnd,&p );x=p.x;y=p.y;

	mov	DWORD PTR _p$[ebp+4], eax
	lea	eax, DWORD PTR _p$[ebp]
	push	eax
	push	DWORD PTR [esi]
	mov	DWORD PTR _p$[ebp], edi
	call	DWORD PTR __imp__ClientToScreen@8
	mov	ecx, DWORD PTR _p$[ebp]
	mov	eax, DWORD PTR _p$[ebp+4]
$LN2@moveMouse:

; 333  : 	default:
; 334  : 		return;
; 335  : 	}
; 336  : 	SetCursorPos( x,y );

	push	eax
	push	ecx
	call	DWORD PTR __imp__SetCursorPos@8
$LN1@moveMouse:

; 337  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?moveMouse@gxRuntime@@QAEXHH@Z ENDP			; gxRuntime::moveMouse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp
;	COMDAT ?flip@gxRuntime@@QAEX_N@Z
_TEXT	SEGMENT
_vb$2 = -68						; size = 4
$T3 = -64						; size = 24
_t$4 = -40						; size = 24
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_vwait$ = 8						; size = 1
?flip@gxRuntime@@QAEX_N@Z PROC				; gxRuntime::flip, COMDAT
; _this$ = ecx

; 288  : void gxRuntime::flip( bool vwait ){

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?flip@gxRuntime@@QAEX_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 56					; 00000038H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 289  : 	gxCanvas *b=graphics->getBackCanvas();

	mov	ecx, DWORD PTR [esi+16]
	call	?getBackCanvas@gxGraphics@@QBEPAVgxCanvas@@XZ ; gxGraphics::getBackCanvas

; 290  : 	gxCanvas *f=graphics->getFrontCanvas();

	mov	ecx, DWORD PTR [esi+16]
	mov	ebx, eax
	call	?getFrontCanvas@gxGraphics@@QBEPAVgxCanvas@@XZ ; gxGraphics::getFrontCanvas

; 291  : 	int n;
; 292  : 	switch( gfx_mode ){

	mov	ecx, DWORD PTR ?gfx_mode@@3HA
	mov	edi, eax
	test	ecx, ecx
	jle	$LN8@flip
	cmp	ecx, 2
	jle	$LN6@flip
	cmp	ecx, 3
	jne	$LN8@flip

; 299  : 		}
; 300  : 		break;
; 301  : 	case 3:
; 302  : 		if( vwait ){

	cmp	BYTE PTR _vwait$[ebp], 0
	je	SHORT $LN10@flip
$LL4@flip:

; 303  : 			BOOL vb;
; 304  : 			while( graphics->dirDraw->GetVerticalBlankStatus( &vb )>=0 && vb ) {}

	mov	eax, DWORD PTR [esi+16]
	lea	edx, DWORD PTR _vb$2[ebp]
	push	edx
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR [eax]
	call	DWORD PTR [ecx+68]
	test	eax, eax
	js	SHORT $LN5@flip
	cmp	DWORD PTR _vb$2[ebp], 0
	jne	SHORT $LL4@flip
$LN5@flip:

; 305  : 			n=f->getSurface()->Flip( 0,DDFLIP_WAIT );

	mov	ecx, edi
	call	?getSurface@gxCanvas@@QBEPAUIDirectDrawSurface7@@XZ ; gxCanvas::getSurface
	push	1

; 306  : 		}else{

	jmp	SHORT $LN40@flip
$LN10@flip:

; 307  : 			n=f->getSurface()->Flip( 0,DDFLIP_NOVSYNC|DDFLIP_WAIT );

	mov	ecx, edi
	call	?getSurface@gxCanvas@@QBEPAUIDirectDrawSurface7@@XZ ; gxCanvas::getSurface
	push	9
$LN40@flip:
	mov	ecx, DWORD PTR [eax]
	push	0
	push	eax
	call	DWORD PTR [ecx+44]

; 308  : 		}
; 309  : 		if( n>=0 ) return;

	test	eax, eax
	jns	$LN8@flip

; 310  : 		string t="Flip Failed! Return code:"+itoa(n&0x7fff);

	and	eax, 32767				; 00007fffH
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?itoa@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@H@Z ; itoa
	push	eax
	push	OFFSET ??_C@_0BK@PLKHMFPL@Flip?5Failed?$CB?5Return?5code?3?$AA@
	lea	eax, DWORD PTR _t$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	eax
	call	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YG?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@PBD$$QAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
	lea	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR _t$4[ebp+20], 16		; 00000010H
	lea	edx, DWORD PTR _t$4[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 595  : 	if( debugger ) debugger->debugLog( t );

	mov	ecx, DWORD PTR ?debugger@@3PAVDebugger@@A
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmovae	edx, DWORD PTR _t$4[ebp]
; File e:\repositories\blitz3d-modernized\gxruntime\gxruntime.cpp

; 595  : 	if( debugger ) debugger->debugLog( t );

	test	ecx, ecx
	je	SHORT $LN34@flip
	mov	eax, DWORD PTR [ecx]
	push	edx
	call	DWORD PTR [eax+20]
$LN34@flip:

; 311  : 		debugLog( t.c_str() );
; 312  : 		break;

	lea	ecx, DWORD PTR _t$4[ebp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
	jmp	SHORT $LN8@flip
$LN6@flip:

; 293  : 	case 1:case 2:
; 294  : 		if( vwait ) graphics->vwait();

	cmp	BYTE PTR _vwait$[ebp], 0
	je	SHORT $LN7@flip
	mov	ecx, DWORD PTR [esi+16]
	call	?vwait@gxGraphics@@QAEXXZ		; gxGraphics::vwait
$LN7@flip:

; 295  : 		f->setModify( b->getModify() );

	mov	ecx, ebx
	call	?getModify@gxCanvas@@QBEHXZ		; gxCanvas::getModify
	push	eax
	mov	ecx, edi
	call	?setModify@gxCanvas@@QAEXH@Z		; gxCanvas::setModify

; 296  : 		if( f->getModify()!=mod_cnt ){

	mov	ecx, edi
	call	?getModify@gxCanvas@@QBEHXZ		; gxCanvas::getModify
	cmp	eax, DWORD PTR ?mod_cnt@@3HA
	je	SHORT $LN8@flip

; 297  : 			mod_cnt=f->getModify();

	mov	ecx, edi
	call	?getModify@gxCanvas@@QBEHXZ		; gxCanvas::getModify

; 298  : 			paint();

	mov	ecx, esi
	mov	DWORD PTR ?mod_cnt@@3HA, eax
	call	?paint@gxRuntime@@AAEXXZ		; gxRuntime::paint
$LN8@flip:

; 313  : 	}
; 314  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?flip@gxRuntime@@QAEX_N@Z$0:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__unwindfunclet$?flip@gxRuntime@@QAEX_N@Z$1:
	lea	ecx, DWORD PTR _t$4[ebp]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
__ehhandler$?flip@gxRuntime@@QAEX_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-72]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?flip@gxRuntime@@QAEX_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?flip@gxRuntime@@QAEX_N@Z ENDP				; gxRuntime::flip
; Function compile flags: /Ogtp
;	COMDAT ??_GgxTimer@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GgxTimer@@QAEPAXI@Z PROC				; gxTimer::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1gxTimer@@QAE@XZ			; gxTimer::~gxTimer
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	20					; 00000014H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GgxTimer@@QAEPAXI@Z ENDP				; gxTimer::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GgxFileSystem@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GgxFileSystem@@QAEPAXI@Z PROC			; gxFileSystem::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1gxFileSystem@@QAE@XZ			; gxFileSystem::~gxFileSystem
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	1
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GgxFileSystem@@QAEPAXI@Z ENDP			; gxFileSystem::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GgxGraphics@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GgxGraphics@@QAEPAXI@Z PROC				; gxGraphics::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1gxGraphics@@QAE@XZ			; gxGraphics::~gxGraphics
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	2184					; 00000888H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GgxGraphics@@QAEPAXI@Z ENDP				; gxGraphics::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z PROC ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator(), COMDAT
; _this$ = ecx

; 238  : 		{	// apply operator< to operands

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	ecx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN28@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN28@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 729  : 		return (_Get_data()._Mysize);

	mov	edx, DWORD PTR __Left$[ebp]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	edi, DWORD PTR [edx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN51@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN51@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	esi, DWORD PTR [esi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, esi

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [edi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	ecx
	push	edx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN58@operator

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN60@operator

; 2102 : 			return (-1);

	or	eax, -1
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		}

	pop	ebp
	ret	8
$LN60@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN58@operator:
	pop	edi

; 2520 : 	return (_Left.compare(_Right) < 0);

	shr	eax, 31					; 0000001fH
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 240  : 		}

	pop	ebp
	ret	8
??R?$less@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@QBE_NABV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@0@Z ENDP ; std::less<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >::operator()
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GgxInput@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GgxInput@@QAEPAXI@Z PROC				; gxInput::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1gxInput@@QAE@XZ			; gxInput::~gxInput
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GgxInput@@QAEPAXI@Z ENDP				; gxInput::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_GgxAudio@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_GgxAudio@@QAEPAXI@Z PROC				; gxAudio::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1gxAudio@@QAE@XZ			; gxAudio::~gxAudio
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	4
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_GgxAudio@@QAEPAXI@Z ENDP				; gxAudio::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _==@8
_TEXT	SEGMENT
tv79 = 8						; size = 4
_guidOne$ = 8						; size = 4
_guidOther$ = 12					; size = 4
_==@8	PROC						; COMDAT

; 193  : {

	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, DWORD PTR _guidOne$[ebp]
	mov	eax, DWORD PTR _guidOther$[ebp]
	push	esi
	mov	esi, 12					; 0000000cH
	npad	1
$LL7@:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN6@
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL7@
	mov	DWORD PTR tv79[ebp], 1

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

	mov	al, BYTE PTR tv79[ebp]
	pop	esi

; 195  : }

	pop	ebp
	ret	8
$LN6@:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	DWORD PTR tv79[ebp], 0

; 194  :     return !!IsEqualGUID(guidOne,guidOther);

	mov	al, BYTE PTR tv79[ebp]
	pop	esi

; 195  : }

	pop	ebp
	ret	8
_==@8	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\8.1\include\shared\guiddef.h
;	COMDAT _IsEqualGUID@8
_TEXT	SEGMENT
_rguid1$ = 8						; size = 4
_rguid2$ = 12						; size = 4
_IsEqualGUID@8 PROC					; COMDAT

; 160  : {

	push	ebp
	mov	ebp, esp

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	mov	edx, DWORD PTR _rguid1$[ebp]
	mov	eax, DWORD PTR _rguid2$[ebp]
	push	esi
	mov	esi, 12					; 0000000cH
	npad	1
$LL5@IsEqualGUI:
	mov	ecx, DWORD PTR [edx]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@IsEqualGUI
	add	edx, 4
	add	eax, 4
	sub	esi, 4
	jae	SHORT $LL5@IsEqualGUI
	mov	eax, 1
	pop	esi

; 162  : }

	pop	ebp
	ret	8
$LN4@IsEqualGUI:

; 161  :     return !memcmp(&rguid1, &rguid2, sizeof(GUID));

	xor	eax, eax
	pop	esi

; 162  : }

	pop	ebp
	ret	8
_IsEqualGUID@8 ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran, COMDAT
; _this$ = ecx

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN4@Xran:
$LN3@Xran:
	int	3
?_Xran@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset, COMDAT
; _this$ = ecx

; 2270 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR __Off$[ebp]
	jb	SHORT $LN17@Check_offs

; 2272 : 			_Xran();
; 2273 : 		}

	pop	ebp
	ret	4
$LN17@Check_offs:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN19@Check_offs:
$LN16@Check_offs:
	int	3
?_Check_offset@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT
; _this$ = ecx

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN4@Xlen:
$LN3@Xlen:
	int	3
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z
_TEXT	SEGMENT
__Built$ = 8						; size = 1
__Newsize$ = 12						; size = 4
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT
; _this$ = ecx

; 2248 : 		{	// initialize buffer, deallocating any storage

	push	ebp
	mov	ebp, esp

; 2249 : 		if (!_Built)

	cmp	BYTE PTR __Built$[ebp], 0
	push	esi
	push	edi
	mov	edi, DWORD PTR __Newsize$[ebp]
	mov	esi, ecx
	je	SHORT $LN4@Tidy

; 2250 : 			;
; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN4@Tidy

; 2252 : 			{	// copy any leftovers to small buffer and deallocate
; 2253 : 			pointer _Ptr = this->_Bx()._Ptr;

	push	ebx
	mov	ebx, DWORD PTR [esi]

; 2254 : 			this->_Getal().destroy(_STD addressof(this->_Bx()._Ptr));
; 2255 : 			if (0 < _Newsize)

	test	edi, edi
	je	SHORT $LN57@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	ebx
	push	esi
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN57@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	mov	eax, DWORD PTR [esi+20]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	ebx
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
	pop	ebx
$LN4@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN96@Tidy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
$LN96@Tidy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+edi], 0
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2262 : 		}

	pop	ebp
	ret	8
?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside, COMDAT
; _this$ = ecx

; 2238 : 		{	// test if _Ptr points inside string

	push	ebp
	mov	ebp, esp

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	test	edx, edx
	je	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN16@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN17@Inside
$LN16@Inside:
	mov	esi, ecx
$LN17@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	edx, esi
	jb	SHORT $LN4@Inside

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN30@Inside
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN31@Inside
$LN30@Inside:
	mov	esi, ecx
$LN31@Inside:

; 2239 : 		if (_Ptr == nullptr_t{} || _Ptr < this->_Myptr()
; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [ecx+16]
	add	eax, esi
	cmp	eax, edx
	jbe	SHORT $LN4@Inside

; 2242 : 		else
; 2243 : 			return (true);

	mov	al, 1
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
$LN4@Inside:

; 2241 : 			return (false);	// don't ask

	xor	al, al
	pop	esi

; 2244 : 		}

	pop	ebp
	ret	4
?_Inside@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Inside
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
__Trim$ = 12						; size = 1
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow, COMDAT
; _this$ = ecx

; 2224 : 		{	// ensure buffer is big enough, trim to size if _Trim is true

	push	ebp
	mov	ebp, esp
	push	esi

; 2225 : 		if (max_size() < _Newsize)

	mov	esi, DWORD PTR __Newsize$[ebp]
	cmp	esi, -2					; fffffffeH
	ja	SHORT $LN89@Grow

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [ecx+20], esi
	jae	SHORT $LN3@Grow

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [ecx+16]
	push	esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	test	esi, esi
	pop	esi
	setne	al

; 2235 : 		}

	pop	ebp
	ret	8
$LN3@Grow:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)

	cmp	BYTE PTR __Trim$[ebp], 0
	je	SHORT $LN5@Grow
	cmp	esi, 16					; 00000010H
	jae	SHORT $LN5@Grow

; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string

	mov	eax, DWORD PTR [ecx+16]
	cmp	esi, eax
	cmovb	eax, esi
	push	eax
	push	1
	call	?_Tidy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX_NI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy
	test	esi, esi
	pop	esi
	setne	al

; 2235 : 		}

	pop	ebp
	ret	8
$LN5@Grow:

; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	test	esi, esi
	jne	SHORT $LN88@Grow

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], esi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN80@Grow
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN80@Grow:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
	test	esi, esi
$LN88@Grow:
	setne	al
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2235 : 		}

	pop	ebp
	ret	8
$LN89@Grow:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN91@Grow:
$LN87@Grow:
	int	3
?_Grow@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE_NI_N@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Grow
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z
_TEXT	SEGMENT
__Newsize$ = 8						; size = 4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT
; _this$ = ecx

; 2217 : 		{	// set new length and null terminator

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 2218 : 		auto& _Dx = this->_Get_data();
; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	edx, DWORD PTR __Newsize$[ebp]
	mov	DWORD PTR [ecx+16], edx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN11@Eos
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
$LN11@Eos:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx+edx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2220 : 		}

	pop	ebp
	ret	4
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
_TEXT	SEGMENT
__Ptr$ = -24						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -16						; size = 16
__Newres$ = 8						; size = 4
__Newsize$ = 8						; size = 4
__Oldlen$ = 12						; size = 4
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy, COMDAT
; _this$ = ecx

; 2182 : 		{	// copy _Oldlen elements to newly allocated buffer

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 2183 : 		size_type _Newres = _Newsize | this->_ALLOC_MASK;

	mov	eax, DWORD PTR __Newsize$[ebp]
	mov	edi, eax
	or	edi, 15					; 0000000fH

; 2184 : 		if (max_size() < _Newres)

	cmp	edi, -2					; fffffffeH
	jbe	SHORT $LN2@Copy

; 2185 : 			_Newres = _Newsize;	// undo roundup if too big

	mov	edi, eax

; 2186 : 		else if (this->_Myres() / 2 <= _Newres / 3)

	jmp	SHORT $LN108@Copy
$LN2@Copy:
	mov	ebx, DWORD PTR [esi+20]
	mov	eax, -1431655765			; aaaaaaabH
	mul	edi
	mov	ecx, ebx
	shr	ecx, 1
	shr	edx, 1
	cmp	ecx, edx
	jbe	SHORT $LN108@Copy

; 2187 : 			;
; 2188 : 		else if (this->_Myres() <= max_size() - this->_Myres() / 2)

	mov	eax, -2					; fffffffeH

; 2189 : 			_Newres = this->_Myres()

	lea	edi, DWORD PTR [ecx+ebx]
	sub	eax, ecx
	cmp	ebx, eax
	jbe	SHORT $LN108@Copy

; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	edi, -2					; fffffffeH
$LN108@Copy:

; 2190 : 				+ this->_Myres() / 2;	// grow exponentially if possible
; 2191 : 		else
; 2192 : 			_Newres = max_size();	// settle for max_size()
; 2193 : 
; 2194 : 		pointer _Ptr;
; 2195 : 		_TRY_BEGIN
; 2196 : 			_Ptr = this->_Getal().allocate(_Newres + 1);

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 51   : 	if (_Count == 0)

	test	eax, eax
	jne	SHORT $LN136@Copy

; 52   : 		return (_Ptr);

	xor	ebx, ebx
	jmp	SHORT $LN19@Copy
$LN136@Copy:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)
; 56   : 		_Xbad_alloc();	// report no memory
; 57   : 	const size_t _User_size = _Count * _Sz;
; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN138@Copy

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	ja	SHORT $LN140@Copy

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN443@Copy:
$LN140@Copy:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	eax, eax
	jne	SHORT $LN141@Copy
	call	__invalid_parameter_noinfo_noreturn
$LN444@Copy:
$LN141@Copy:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	ebx, DWORD PTR [eax+35]
	and	ebx, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [ebx-4], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

	jmp	SHORT $LN19@Copy
$LN138@Copy:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ebx, eax
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	ebx, ebx
	jne	SHORT $LN19@Copy
	call	__invalid_parameter_noinfo_noreturn
$LN445@Copy:
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$0:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2198 : 			_Newres = _Newsize;	// allocation failed, undo roundup and retry

	mov	eax, DWORD PTR __Newsize$[ebp]

; 2199 : 			_TRY_BEGIN
; 2200 : 				_Ptr = this->_Getal().allocate(_Newres + 1);

	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR __Newres$[ebp], eax
	inc	eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	push	eax
	mov	BYTE PTR __$EHRec$[ebp+12], 2
	call	?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ; std::_Wrap_alloc<std::allocator<char> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 2204 : 			_CATCH_END
; 2205 : 		_CATCH_END

	mov	eax, $LN440@Copy
	ret	0
$LN440@Copy:
	mov	esi, DWORD PTR _this$[ebp]
	mov	edi, DWORD PTR __Newres$[ebp]
	mov	ebx, DWORD PTR __Ptr$[ebp]
$LN19@Copy:

; 2206 : 
; 2207 : 		if (0 < _Oldlen)

	mov	eax, DWORD PTR __Oldlen$[ebp]
	test	eax, eax
	je	SHORT $LN274@Copy

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN265@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN266@Copy
$LN265@Copy:
	mov	ecx, esi
$LN266@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN274@Copy
	push	eax
	push	ecx
	push	ebx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN274@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN278@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN278@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN370@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN371@Copy
$LN370@Copy:
	mov	eax, esi
$LN371@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	eax, DWORD PTR __Oldlen$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	DWORD PTR [esi], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2212 : 		this->_Myres() = _Newres;

	mov	DWORD PTR [esi+20], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN434@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, ebx
$LN434@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2214 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	8
__catch$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z$1:

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR _this$[ebp]

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN156@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN156@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN249@Copy
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	esi, DWORD PTR [esi]
$LN249@Copy:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	push	0
	push	0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2203 : 			_RERAISE;

	call	__CxxThrowException@8
$LN446@Copy:
$LN442@Copy:
	int	3
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-28]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign, COMDAT
; _this$ = ecx

; 2174 : 		{	// assign _Count copies of _Ch beginning at _Off

	push	ebp
	mov	ebp, esp

; 2175 : 		if (_Count == 1)

	mov	eax, DWORD PTR __Count$[ebp]
	mov	edx, ecx
	cmp	eax, 1
	jne	SHORT $LN2@Chassign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN16@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN16@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	eax, DWORD PTR __Off$[ebp]
	mov	cl, BYTE PTR __Ch$[ebp]
	mov	BYTE PTR [edx+eax], cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Chassign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H
	jb	SHORT $LN33@Chassign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN33@Chassign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2178 : 			_Traits::assign(this->_Myptr() + _Off, _Count, _Ch);

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	eax
	call	_memset
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2179 : 		}

	pop	ebp
	ret	12					; 0000000cH
?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT
; _this$ = ecx

; 2168 : 		{	// return allocator object for values

	push	ebp
	mov	ebp, esp

; 2169 : 		allocator_type _Ret(this->_Getal());
; 2170 : 		return (_Ret);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 2171 : 		}

	pop	ebp
	ret	4
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2144 : 		{	// compare [0, _Mysize()) with [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, DWORD PTR __Ptr$[ebp]
	push	esi
	push	edi
	cmp	BYTE PTR [edx], 0
	jne	SHORT $LN5@compare
	xor	esi, esi
	jmp	SHORT $LN6@compare
$LN5@compare:
	mov	esi, edx
	lea	edi, DWORD PTR [esi+1]
$LL35@compare:
	mov	al, BYTE PTR [esi]
	inc	esi
	test	al, al
	jne	SHORT $LL35@compare
	sub	esi, edi
$LN6@compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	edi, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN26@compare
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN26@compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2146 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [edi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, esi
	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	edx
	push	ecx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN33@compare

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN36@compare

; 2146 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	pop	edi
	or	eax, -1
	pop	esi

; 2147 : 			_Ptr, _Traits::length(_Ptr)));
; 2148 : 		}

	pop	ebp
	ret	4
$LN36@compare:

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN33@compare:
	pop	edi
	pop	esi

; 2147 : 			_Ptr, _Traits::length(_Ptr)));
; 2148 : 		}

	pop	ebp
	ret	4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare, COMDAT
; _this$ = ecx

; 2120 : 		{	// compare [0, _Mysize()) with _Right

	push	ebp
	mov	ebp, esp

; 729  : 		return (_Get_data()._Mysize);

	mov	edx, DWORD PTR __Right$[ebp]
	push	esi
	push	edi

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	esi, DWORD PTR [edx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN22@compare
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [edx]
$LN22@compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 729  : 		return (_Get_data()._Mysize);

	lea	edi, DWORD PTR [ecx+16]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN45@compare
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN45@compare:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	esi, DWORD PTR [esi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	eax, esi

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	mov	edi, DWORD PTR [edi]

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	edx
	push	ecx
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN52@compare

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN54@compare

; 2121 : 		return (_Traits_compare(this->_Myptr(), this->_Mysize(),

	pop	edi
	or	eax, -1
	pop	esi

; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}

	pop	ebp
	ret	4
$LN54@compare:

; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN52@compare:
	pop	edi
	pop	esi

; 2122 : 			_Right._Myptr(), _Right._Mysize()));
; 2123 : 		}

	pop	ebp
	ret	4
?compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEHABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Size$ = 12						; size = 4
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size, COMDAT
; _this$ = ecx

; 2111 : 		{	// trims _Size to the longest it can be assuming a string starting at _Off

	push	ebp
	mov	ebp, esp

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	eax, DWORD PTR [ecx+16]
	sub	eax, DWORD PTR __Off$[ebp]

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	DWORD PTR __Size$[ebp], eax
	cmovbe	eax, DWORD PTR __Size$[ebp]

; 2114 : 			return (_Size);
; 2115 : 		else
; 2116 : 			return (_Max_effective_size);
; 2117 : 		}

	pop	ebp
	ret	8
?_Clamp_suffix_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SGHQBDI0I@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Left_size$ = 12					; size = 4
__Right$ = 16						; size = 4
__Right_size$ = 20					; size = 4
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SGHQBDI0I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare, COMDAT

; 2094 : 		{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits

	push	ebp
	mov	ebp, esp
	push	esi

; 2095 : 		const size_type _Min_size = _Left_size < _Right_size ? _Left_size : _Right_size;

	mov	esi, DWORD PTR __Right_size$[ebp]
	mov	eax, esi
	push	edi
	mov	edi, DWORD PTR __Left_size$[ebp]
	cmp	edi, esi
	cmovb	eax, edi

; 2096 : 		const int _Ans = _Traits::compare(_Left, _Right, _Min_size);

	push	eax
	push	DWORD PTR __Right$[ebp]
	push	DWORD PTR __Left$[ebp]
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH

; 2097 : 
; 2098 : 		if (_Ans != 0)

	test	eax, eax
	jne	SHORT $LN4@Traits_com

; 2099 : 			return (_Ans);
; 2100 : 
; 2101 : 		if (_Left_size < _Right_size)

	cmp	esi, edi
	jbe	SHORT $LN6@Traits_com

; 2102 : 			return (-1);

	pop	edi
	or	eax, -1
	pop	esi

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN6@Traits_com:

; 2103 : 
; 2104 : 		if (_Left_size > _Right_size)

	sbb	eax, eax
	neg	eax
$LN4@Traits_com:
	pop	edi
	pop	esi

; 2105 : 			return (1);
; 2106 : 
; 2107 : 		return (0);
; 2108 : 		}

	pop	ebp
	ret	16					; 00000010H
?_Traits_compare@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SGHQBDI0I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Traits_compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z
_TEXT	SEGMENT
$T1 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT
; _this$ = ecx

; 2088 : 		{	// return [_Off, _Off + _Count) as new string

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi

; 817  : 		assign(_Right, _Roff, _Count);

	push	DWORD PTR __Count$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]

; 817  : 		assign(_Right, _Roff, _Count);

	push	DWORD PTR __Off$[ebp]
	mov	DWORD PTR $T1[ebp], 0
	push	ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 817  : 		assign(_Right, _Roff, _Count);

	mov	ecx, esi

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 817  : 		assign(_Right, _Roff, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2089 : 		return (_Myt(*this, _Off, _Count, get_allocator()));

	mov	eax, esi
	pop	esi

; 2090 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBE?AV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of, COMDAT
; _this$ = ecx

; 2012 : 		{	// look for _Ch before _Off

	push	ebp
	mov	ebp, esp

; 2013 : 		return (rfind((const _Elem *)&_Ch, _Off, 1));

	push	1
	push	DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	call	?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind

; 2014 : 		}

	pop	ebp
	ret	8
?find_last_of@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find_last_of
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
tv298 = 15						; size = 1
__Count$ = 16						; size = 4
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind, COMDAT
; _this$ = ecx

; 1912 : 		{	// look for [_Ptr, _Ptr + _Count) beginning before _Off

	push	ebp
	mov	ebp, esp
	push	ebx

; 1913 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1914 : 		if (_Count == 0)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	edi
	mov	edi, ecx
	test	ebx, ebx
	jne	SHORT $LN5@rfind

; 1915 : 			return (_Off < this->_Mysize() ? _Off

	mov	eax, DWORD PTR [edi+16]
	cmp	DWORD PTR __Off$[ebp], eax
	pop	edi
	cmovb	eax, DWORD PTR __Off$[ebp]
	pop	ebx

; 1931 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN5@rfind:

; 1916 : 				: this->_Mysize());	// null always matches
; 1917 : 		if (_Count <= this->_Mysize())

	mov	ecx, DWORD PTR [edi+16]
	push	esi
	cmp	ebx, ecx
	ja	SHORT $LN93@rfind

; 1918 : 			{	// room for match, look for it
; 1919 : 			const _Elem *_Uptr = this->_Myptr() +

	sub	ecx, ebx
	cmp	DWORD PTR __Off$[ebp], ecx
	cmovb	ecx, DWORD PTR __Off$[ebp]

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN70@rfind
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [edi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN71@rfind
$LN70@rfind:
	mov	eax, edi
$LN71@rfind:

; 1918 : 			{	// room for match, look for it
; 1919 : 			const _Elem *_Uptr = this->_Myptr() +

	lea	esi, DWORD PTR [eax+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 571  : 		return (_Left == _Right);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	BYTE PTR tv298[ebp], cl
$LL4@rfind:
	cmp	BYTE PTR [esi], cl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1924 : 					&& _Traits::compare(_Uptr, _Ptr, _Count) == 0)

	jne	SHORT $LN7@rfind
	push	ebx
	push	eax
	push	esi
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN92@rfind
$LN7@rfind:

; 1926 : 				else if (_Uptr == this->_Myptr())

	mov	ecx, edi
	call	?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
	cmp	esi, eax
	je	SHORT $LN93@rfind

; 1920 : 				(_Off < this->_Mysize() - _Count ? _Off
; 1921 : 					: this->_Mysize() - _Count);
; 1922 : 			for (; ; --_Uptr)

	mov	eax, DWORD PTR __Ptr$[ebp]
	dec	esi
	mov	cl, BYTE PTR tv298[ebp]
	jmp	SHORT $LL4@rfind
$LN92@rfind:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [edi+20], 16			; 00000010H
	jb	SHORT $LN87@rfind
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [edi]
$LN87@rfind:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1925 : 					return (_Uptr - this->_Myptr());	// found a match

	sub	esi, edi
	mov	eax, esi
	pop	esi
	pop	edi
	pop	ebx

; 1931 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN93@rfind:
	pop	esi
	pop	edi

; 1927 : 					break;	// at beginning, no more chance for match
; 1928 : 			}
; 1929 : 
; 1930 : 		return (npos);	// no match

	or	eax, -1
	pop	ebx

; 1931 : 		}

	pop	ebp
	ret	12					; 0000000cH
?rfind@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::rfind
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
__Off$ = 12						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1901 : 		{	// look for _Ch at or after _Off

	push	ebp
	mov	ebp, esp

; 1902 : 		return (find((const _Elem *)&_Ch, _Off, 1));

	push	1
	push	DWORD PTR __Off$[ebp]
	lea	eax, DWORD PTR __Ch$[ebp]
	push	eax
	call	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find

; 1903 : 		}

	pop	ebp
	ret	8
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
__Ptr$ = 8						; size = 4
__Off$ = 12						; size = 4
__Count$ = 16						; size = 4
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT
; _this$ = ecx

; 1875 : 		{	// look for [_Ptr, _Ptr + _Count) beginning at or after _Off

	push	ebp
	mov	ebp, esp
	push	ecx

; 1876 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1877 : 		if (_Count == 0 && _Off <= this->_Mysize())

	mov	edx, DWORD PTR __Off$[ebp]
	push	ebx
	mov	ebx, DWORD PTR __Count$[ebp]
	mov	DWORD PTR _this$1$[ebp], ecx
	test	ebx, ebx
	jne	SHORT $LN5@find
	cmp	edx, DWORD PTR [ecx+16]
	ja	SHORT $LN5@find

; 1878 : 			return (_Off);	// null string always matches (if inside string)

	mov	eax, edx
	pop	ebx

; 1892 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@find:
	push	esi

; 1879 : 
; 1880 : 		size_type _Nm;
; 1881 : 		if (_Off < this->_Mysize() && _Count <= (_Nm = this->_Mysize() - _Off))

	mov	esi, DWORD PTR [ecx+16]
	push	edi
	cmp	edx, esi
	jae	SHORT $LN3@find
	sub	esi, edx
	cmp	ebx, esi
	ja	SHORT $LN3@find

; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

	mov	eax, 1
	sub	eax, ebx
	add	esi, eax

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN46@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN46@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1884 : 			for (_Nm -= _Count - 1, _Vptr = this->_Myptr() + _Off;

	lea	ebx, DWORD PTR [ecx+edx]
$LL4@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 546  : 		return (_Count == 0 ? (const _Elem *)0

	test	esi, esi
	je	SHORT $LN3@find
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	esi
	movsx	eax, BYTE PTR [eax]
	push	eax
	push	ebx
	call	_memchr
	mov	edi, eax
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1885 : 				(_Uptr = _Traits::find(_Vptr, _Nm, *_Ptr)) != 0;

	test	edi, edi
	je	SHORT $LN3@find

; 1887 : 				if (_Traits::compare(_Uptr, _Ptr, _Count) == 0)

	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	push	edi
	call	?compare@?$char_traits@D@std@@SAHPBD0I@Z ; std::char_traits<char>::compare
	add	esp, 12					; 0000000cH
	test	eax, eax
	je	SHORT $LN69@find

; 1886 : 				_Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1)

	sub	ebx, edi
	dec	ebx
	add	esi, ebx
	lea	ebx, DWORD PTR [edi+1]
	jmp	SHORT $LL4@find
$LN69@find:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR _this$1$[ebp]
	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN64@find
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN64@find:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1888 : 					return (_Uptr - this->_Myptr());	// found a match

	sub	edi, eax
	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 1892 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN3@find:
	pop	edi
	pop	esi

; 1889 : 			}
; 1890 : 
; 1891 : 		return (npos);	// no match

	or	eax, -1
	pop	ebx

; 1892 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIPBDII@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1770 : 		const size_type _Num = this->_Getal().max_size();
; 1771 : 		return (_Num <= 1 ? 1 : _Num - 1);

	mov	eax, -2					; fffffffeH

; 1772 : 		}

	ret	0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ
_TEXT	SEGMENT
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT
; _this$ = ecx

; 1765 : 		return (this->_Mysize());

	mov	eax, DWORD PTR [ecx+16]

; 1766 : 		}

	ret	0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEIXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ
_TEXT	SEGMENT
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN13@c_str

; 1743 : 		return (this->_Myptr());

	mov	eax, DWORD PTR [ecx]

; 1744 : 		}

	ret	0
$LN13@c_str:

; 1743 : 		return (this->_Myptr());

	mov	eax, ecx

; 1744 : 		}

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QBEPBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT
; _this$ = ecx

; 1679 : 		{	// subscript mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 1688 : 		return (this->_Myptr()[_Off]);

	mov	eax, DWORD PTR __Off$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN13@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN13@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1688 : 		return (this->_Myptr()[_Off]);

	add	eax, ecx

; 1689 : 		}

	pop	ebp
	ret	4
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAADI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end, COMDAT
; _this$ = ecx

; 1606 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@end
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, eax

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1609 : 		}

	pop	ebp
	ret	4
$LN11@end:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 1608 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()) + _Mydata->_Mysize, _Mydata));

	mov	ecx, DWORD PTR [ecx+16]
	add	ecx, eax

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx

; 1609 : 		}

	pop	ebp
	ret	4
?end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::end
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT
; _this$ = ecx

; 1594 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H

; 48   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN11@begin
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN11@begin:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 48   : 		: _Ptr(_Parg)

	mov	DWORD PTR [eax], ecx

; 1595 : 		auto _Mydata = &this->_Get_data();
; 1596 : 		return (iterator(this->_Getal().address(*_Mydata->_Myptr()), _Mydata));
; 1597 : 		}

	pop	ebp
	ret	4
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__First2$ = 16						; size = 4
__Last2$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

	push	ebp
	mov	ebp, esp

; 222  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR __First2$[ebp]
	mov	edx, DWORD PTR __Last2$[ebp]
	push	esi

; 1584 : 		{	// replace [_First, _Last) with [_First2, _Last2), const_iterators

	mov	esi, ecx

; 222  : 		return (_Ptr == _Right._Ptr);

	cmp	eax, edx

; 1585 : 		if (_First2 == _Last2)

	jne	SHORT $LN2@replace

; 211  : 		return (_Ptr - _Right._Ptr);

	mov	ecx, DWORD PTR __Last$[ebp]
	mov	eax, DWORD PTR __First$[ebp]
	sub	ecx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN24@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	eax, edx

; 1586 : 			erase(_First - begin(), _Last - _First);

	push	ecx
	push	eax
	mov	ecx, esi
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1591 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN24@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi

; 1586 : 			erase(_First - begin(), _Last - _First);

	push	ecx

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	eax, edx

; 1586 : 			erase(_First - begin(), _Last - _First);

	mov	ecx, esi
	push	eax
	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1591 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN2@replace:

; 211  : 		return (_Ptr - _Right._Ptr);

	mov	ecx, DWORD PTR __First$[ebp]
	sub	edx, eax
	push	ebx
	mov	ebx, DWORD PTR __Last$[ebp]
	sub	ebx, ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	push	edi
	jb	SHORT $LN76@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN77@replace
$LN76@replace:
	mov	edi, esi
$LN77@replace:

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

	push	edx
	push	eax

; 211  : 		return (_Ptr - _Right._Ptr);

	sub	ecx, edi

; 1587 : 		else
; 1588 : 			replace(_First - begin(), _Last - _First,

	push	ebx
	push	ecx
	mov	ecx, esi
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
	pop	edi
	pop	ebx

; 1589 : 				&*_First2, _Last2 - _First2);
; 1590 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1591 : 		}

	pop	ebp
	ret	16					; 00000010H
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@V?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@0V?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@1@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z
_TEXT	SEGMENT
__Nm$1$ = -8						; size = 4
tv890 = -4						; size = 4
tv887 = -4						; size = 4
__Off$ = 8						; size = 4
tv891 = 12						; size = 4
tv888 = 12						; size = 4
__N0$ = 12						; size = 4
__Ptr$ = 16						; size = 4
__Count$ = 20						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	edx, DWORD PTR __Ptr$[ebp]

; 1453 : 		{	// replace [_Off, _Off + _N0) with [_Ptr, _Ptr + _Count)

	sub	esp, 8
	push	esi
	mov	esi, ecx
	push	edi

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	edx, edx
	je	SHORT $LN2@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN24@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN25@replace
$LN24@replace:
	mov	eax, esi
$LN25@replace:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	edx, eax
	jb	SHORT $LN2@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN38@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edi, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN39@replace
$LN38@replace:
	mov	edi, esi
$LN39@replace:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edi
	cmp	eax, edx
	jbe	SHORT $LN2@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN61@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN62@replace
$LN61@replace:
	mov	eax, esi
$LN62@replace:

; 1454 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1455 : 		if (_Inside(_Ptr))
; 1456 : 			return (replace(_Off, _N0, *this,

	push	DWORD PTR __Count$[ebp]
	sub	edx, eax
	mov	ecx, esi
	push	edx
	push	esi
	push	DWORD PTR __N0$[ebp]
	push	DWORD PTR __Off$[ebp]
	call	?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
	pop	edi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN2@replace:

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	mov	eax, DWORD PTR __Off$[ebp]
	cmp	ecx, eax
	jb	$LN312@replace

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	mov	edx, DWORD PTR __Count$[ebp]

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	edi, ecx
	sub	edi, eax

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	mov	eax, edx
	push	ebx

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	ebx, DWORD PTR __N0$[ebp]

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	not	eax

; 2113 : 		if (_Size <= _Max_effective_size)

	cmp	ebx, edi
	cmova	ebx, edi

; 1457 : 				_Ptr - this->_Myptr(),
; 1458 : 				_Count));	// substring, replace carefully
; 1459 : 		_Check_offset(_Off);
; 1460 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1461 : 		if (npos - _Count <= this->_Mysize() - _N0)

	sub	ecx, ebx
	cmp	eax, ecx
	jbe	$LN314@replace

; 1462 : 			_Xlen();	// result too long
; 1463 : 		size_type _Nm = this->_Mysize() - _N0 - _Off;

	sub	edi, ebx
	mov	DWORD PTR __Nm$1$[ebp], edi

; 1464 : 
; 1465 : 		if (_Count < _N0)

	cmp	edx, ebx
	jae	SHORT $LN145@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN124@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv891[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN125@replace
$LN124@replace:
	mov	DWORD PTR tv891[ebp], esi
$LN125@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN138@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv890[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN139@replace
$LN138@replace:
	mov	DWORD PTR tv890[ebp], esi
$LN139@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN145@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv891[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1466 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv890[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	edx, DWORD PTR __Count$[ebp]
	add	esp, 12					; 0000000cH
$LN145@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1469 : 		const size_type _Num = this->_Mysize() + _Count - _N0;

	mov	eax, DWORD PTR [esi+16]
	mov	edi, eax
	sub	edi, ebx
	add	edi, edx

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

	test	edx, edx
	jne	SHORT $LN6@replace
	test	ebx, ebx
	je	$LN306@replace
$LN6@replace:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN315@replace

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN157@replace

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	eax
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	edx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1470 : 		if ((0 < _Count || 0 < _N0)
; 1471 : 			&& _Grow(_Num))

	je	$LN306@replace
$LN311@replace:

; 1472 : 			{	// make room and rearrange
; 1473 : 			if (_N0 < _Count)

	cmp	ebx, edx
	jae	SHORT $LN272@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN251@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv888[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN252@replace
$LN157@replace:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN311@replace

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN234@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1479 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN234@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	ebx
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN251@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv888[ebp], esi
$LN252@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN265@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv887[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN266@replace
$LN265@replace:
	mov	DWORD PTR tv887[ebp], esi
$LN266@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Nm$1$[ebp]
	test	eax, eax
	je	SHORT $LN272@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv888[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1474 : 				_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv887[ebp]
	add	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	edx, DWORD PTR __Count$[ebp]
	add	esp, 12					; 0000000cH
$LN272@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN283@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN284@replace
$LN283@replace:
	mov	eax, esi
$LN284@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edx, edx
	je	SHORT $LN290@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1476 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

	add	eax, DWORD PTR __Off$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edx
	push	DWORD PTR __Ptr$[ebp]
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN290@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN301@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1479 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN301@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN306@replace:
	pop	ebx
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1479 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1480 : 		}

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN312@replace:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN316@replace:
$LN314@replace:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN317@replace:
$LN315@replace:
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN318@replace:
$LN309@replace:
	int	3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z
_TEXT	SEGMENT
tv1828 = -8						; size = 4
tv1825 = -8						; size = 4
__Max_effective_size$1$ = -8				; size = 4
__Nm$1$ = -4						; size = 4
tv1824 = 8						; size = 4
tv1821 = 8						; size = 4
tv1817 = 8						; size = 4
tv1813 = 8						; size = 4
__Off$ = 8						; size = 4
__N0$ = 12						; size = 4
tv1809 = 16						; size = 4
tv1807 = 16						; size = 4
tv1805 = 16						; size = 4
__Right$ = 16						; size = 4
tv1819 = 20						; size = 4
__Roff$ = 20						; size = 4
tv1798 = 24						; size = 4
__Newsize$1$ = 24					; size = 4
__Count$ = 24						; size = 4
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace, COMDAT
; _this$ = ecx

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Off$[ebp]
	push	esi

; 1389 : 		{	// replace [_Off, _Off + _N0) with _Right [_Roff, _Roff + _Count)

	mov	esi, ecx
	push	edi

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR [esi+16]
	cmp	eax, ebx
	jb	$LN600@replace
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edi, DWORD PTR [ecx+16]
	cmp	edi, DWORD PTR __Roff$[ebp]
	jb	$LN602@replace

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edx, DWORD PTR __N0$[ebp]
	sub	eax, ebx
	cmp	edx, eax
	mov	DWORD PTR __Nm$1$[ebp], eax
	cmova	edx, eax

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	sub	edi, DWORD PTR __Roff$[ebp]

; 1390 : 		_Check_offset(_Off);
; 1391 : 		_Right._Check_offset(_Roff);
; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

	mov	eax, DWORD PTR [esi+16]

; 2112 : 		const size_type _Max_effective_size = this->_Mysize() - _Off;

	mov	DWORD PTR __Max_effective_size$1$[ebp], edi

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, DWORD PTR __Max_effective_size$1$[ebp]
	mov	DWORD PTR __N0$[ebp], edx
	cmova	edi, DWORD PTR __Max_effective_size$1$[ebp]

; 1390 : 		_Check_offset(_Off);
; 1391 : 		_Right._Check_offset(_Roff);
; 1392 : 		_N0 = _Clamp_suffix_size(_Off, _N0);
; 1393 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1394 : 		if (npos - _Count <= this->_Mysize() - _N0)

	sub	eax, edx
	mov	DWORD PTR tv1798[ebp], eax
	mov	eax, edi
	not	eax
	cmp	eax, DWORD PTR tv1798[ebp]
	jbe	$LN603@replace

; 1395 : 			_Xlen();	// result too long
; 1396 : 
; 1397 : 		const size_type _Nm = this->_Mysize() - _N0 - _Off;	// length of kept tail
; 1398 : 		const size_type _Newsize = this->_Mysize() + _Count - _N0;

	mov	ebx, DWORD PTR tv1798[ebp]
	mov	eax, DWORD PTR __Nm$1$[ebp]
	add	ebx, edi
	sub	eax, edx
	mov	DWORD PTR __Newsize$1$[ebp], ebx

; 1399 : 		if (this->_Mysize() < _Newsize)

	cmp	DWORD PTR [esi+16], ebx
	mov	ebx, DWORD PTR __Off$[ebp]
	mov	DWORD PTR __Nm$1$[ebp], eax
	jae	SHORT $LN194@replace

; 2225 : 		if (max_size() < _Newsize)

	cmp	DWORD PTR __Newsize$1$[ebp], -2		; fffffffeH
	ja	$LN604@replace

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	mov	ebx, DWORD PTR __Newsize$1$[ebp]
	cmp	DWORD PTR [esi+20], ebx
	mov	ebx, DWORD PTR __Off$[ebp]
	jae	SHORT $LN112@replace

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	DWORD PTR __Newsize$1$[ebp]
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __N0$[ebp]
	mov	eax, DWORD PTR __Nm$1$[ebp]
	jmp	SHORT $LN194@replace
$LN112@replace:

; 2229 : 		else if (_Trim && _Newsize < this->_BUF_SIZE)
; 2230 : 			_Tidy(true,	// copy and deallocate if trimming to small string
; 2231 : 				_Newsize < this->_Mysize() ? _Newsize : this->_Mysize());
; 2232 : 		else if (_Newsize == 0)

	cmp	DWORD PTR __Newsize$1$[ebp], 0
	jne	SHORT $LN194@replace

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN189@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR tv1828[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN190@replace
$LN189@replace:
	mov	DWORD PTR tv1828[ebp], esi
$LN190@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	ebx, DWORD PTR tv1828[ebp]
	mov	BYTE PTR [ebx], 0
	mov	ebx, DWORD PTR __Off$[ebp]
$LN194@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1402 : 		if (_Count == _N0)

	cmp	edi, edx
	jne	SHORT $LN4@replace

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN206@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN206@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN220@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN221@replace
$LN220@replace:
	mov	edx, esi
$LN221@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	$LN579@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1404 : 			_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1404 : 			_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [edx+ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 555  : 		}

	jmp	$LN598@replace
$LN4@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1407 : 		else if (this != &_Right)

	cmp	esi, ecx
	je	SHORT $LN6@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN238@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [esi]
	mov	DWORD PTR tv1825[ebp], ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ebx, DWORD PTR __Off$[ebp]
	jmp	SHORT $LN239@replace
$LN238@replace:
	mov	DWORD PTR tv1825[ebp], esi
$LN239@replace:
	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN252@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR tv1824[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, DWORD PTR __N0$[ebp]
	jmp	SHORT $LN253@replace
$LN252@replace:
	mov	DWORD PTR tv1824[ebp], esi
$LN253@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN259@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1825[ebp]
	add	eax, ebx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1409 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1824[ebp]
	add	eax, ebx
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	ecx, DWORD PTR __Right$[ebp]
	add	esp, 12					; 0000000cH
$LN259@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN270@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [ecx]
$LN270@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN284@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN285@replace
$LN284@replace:
	mov	edx, esi
$LN285@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	$LN579@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1411 : 			_Traits::copy(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [edx+ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	jmp	$LN599@replace
$LN6@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1414 : 		else if (_Count < _N0)

	cmp	edi, edx
	jae	SHORT $LN8@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN302@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1821[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN303@replace
$LN302@replace:
	mov	DWORD PTR tv1821[ebp], esi
$LN303@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN316@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN317@replace
$LN316@replace:
	mov	ecx, esi
$LN317@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN323@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1416 : 			_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv1821[ebp]
	add	eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1416 : 			_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	edx, DWORD PTR __N0$[ebp]
	add	esp, 12					; 0000000cH
$LN323@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN334@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1819[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN335@replace
$LN334@replace:
	mov	DWORD PTR tv1819[ebp], esi
$LN335@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN348@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN349@replace
$LN348@replace:
	mov	ecx, esi
$LN349@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Nm$1$[ebp]
	test	eax, eax
	je	$LN579@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1819[ebp]
	add	eax, ebx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1418 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+ebx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 555  : 		}

	jmp	$LN598@replace
$LN8@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1421 : 		else if (_Roff <= _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	cmp	ecx, ebx
	ja	SHORT $LN10@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN366@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR tv1817[ebp], edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, DWORD PTR __N0$[ebp]
	jmp	SHORT $LN367@replace
$LN366@replace:
	mov	DWORD PTR tv1817[ebp], esi
$LN367@replace:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN380@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN381@replace
$LN380@replace:
	mov	ecx, esi
$LN381@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	eax, eax
	je	SHORT $LN387@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1817[ebp]
	add	eax, ebx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1423 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+ebx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$LN387@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN398@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN399@replace
$LN398@replace:
	mov	edx, esi
$LN399@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN412@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN413@replace
$LN412@replace:
	mov	ecx, esi
$LN413@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	$LN579@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1425 : 			_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR __Roff$[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1425 : 			_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 555  : 		}

	jmp	$LN598@replace
$LN10@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1428 : 		else if (_Off + _N0 <= _Roff)

	lea	eax, DWORD PTR [ebx+edx]
	cmp	eax, ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]

; 1428 : 		else if (_Off + _N0 <= _Roff)

	ja	SHORT $LN12@replace

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN430@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1813[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN431@replace
$LN430@replace:
	mov	DWORD PTR tv1813[ebp], esi
$LN431@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN444@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN445@replace
$LN444@replace:
	mov	ecx, esi
$LN445@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Nm$1$[ebp]
	test	eax, eax
	je	SHORT $LN451@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1813[ebp]
	add	eax, ebx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1430 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+ebx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	edx, DWORD PTR __N0$[ebp]
	add	esp, 12					; 0000000cH
$LN451@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN462@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN463@replace
$LN462@replace:
	mov	eax, esi
$LN463@replace:
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN476@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN477@replace
$LN476@replace:
	mov	ecx, esi
$LN477@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	$LN579@replace
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1432 : 			_Traits::move(this->_Myptr() + _Off,

	add	eax, DWORD PTR __Roff$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1432 : 			_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ecx+ebx]

; 1433 : 				this->_Myptr() + (_Roff + _Count - _N0),
; 1434 : 				_Count);	// fill hole
; 1435 : 			}
; 1436 : 		else

	jmp	$LN598@replace
$LN12@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	eax, 16					; 00000010H
	jb	SHORT $LN494@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1809[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN495@replace
$LN494@replace:
	mov	DWORD PTR tv1809[ebp], esi
$LN495@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN508@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN509@replace
$LN508@replace:
	mov	ecx, esi
$LN509@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edx, edx
	je	SHORT $LN515@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1438 : 			_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv1809[ebp]
	add	eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edx
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1438 : 			_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ecx+ebx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	edx, DWORD PTR __N0$[ebp]
	add	esp, 12					; 0000000cH
$LN515@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN526@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1807[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN527@replace
$LN526@replace:
	mov	DWORD PTR tv1807[ebp], esi
$LN527@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN540@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN541@replace
$LN540@replace:
	mov	ecx, esi
$LN541@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Nm$1$[ebp]
	test	eax, eax
	je	SHORT $LN547@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv1807[ebp]
	add	eax, ebx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1440 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+ebx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	add	esp, 12					; 0000000cH
$LN547@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN558@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv1805[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN559@replace
$LN558@replace:
	mov	DWORD PTR tv1805[ebp], esi
$LN559@replace:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN572@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN573@replace
$LN572@replace:
	mov	edx, esi
$LN573@replace:

; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

	mov	ecx, DWORD PTR __N0$[ebp]
	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN579@replace
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

	mov	eax, DWORD PTR tv1805[ebp]
	add	eax, DWORD PTR __Roff$[ebp]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1442 : 			_Traits::move(this->_Myptr() + _Off + _N0,

	mov	eax, DWORD PTR __Off$[ebp]
	add	eax, edx
	add	eax, ecx
$LN598@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
$LN599@replace:
	add	esp, 12					; 0000000cH
$LN579@replace:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	ecx, DWORD PTR __Newsize$1$[ebp]
	mov	DWORD PTR [esi+16], ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN590@replace
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1448 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN590@replace:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1449 : 		}

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN600@replace:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN605@replace:
$LN602@replace:
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN606@replace:
$LN603@replace:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN607@replace:
$LN604@replace:
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN608@replace:
$LN597@replace:
	int	3
?replace@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IIABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::replace
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Count$ = 12						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1347 : 		{	// erase elements [_Off, _Off + _Count)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Off$[ebp]
	push	edi
	mov	edi, DWORD PTR [esi+16]
	cmp	edi, ecx
	jb	SHORT $LN93@erase

; 1348 : 		_Check_offset(_Off);
; 1349 : 		if (this->_Mysize() - _Off <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, edi
	sub	eax, ecx
	cmp	eax, edx
	ja	SHORT $LN2@erase

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN41@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN41@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1359 : 		}

	pop	ebp
	ret	8
$LN2@erase:

; 1350 : 			_Eos(_Off);	// erase elements [_Off, ...)
; 1351 : 		else if (0 < _Count)

	test	edx, edx
	je	SHORT $LN90@erase

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN58@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN59@erase
$LN58@erase:
	mov	eax, esi
$LN59@erase:

; 1352 : 			{	// move elements down
; 1353 : 			value_type *_Ptr = this->_Myptr() + _Off;
; 1354 : 			size_type _Newsize = this->_Mysize() - _Count;

	sub	edi, edx
	push	ebx
	lea	ebx, DWORD PTR [eax+ecx]

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	mov	eax, edi
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN74@erase
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1355 : 			_Traits::move(_Ptr, _Ptr + _Count, _Newsize - _Off);

	lea	eax, DWORD PTR [ebx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	push	ebx
	call	_memmove
	add	esp, 12					; 0000000cH
$LN74@erase:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi
	pop	ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN85@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN85@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN90@erase:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1358 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1359 : 		}

	pop	ebp
	ret	8
$LN93@erase:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN95@erase:
$LN92@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT
; _this$ = ecx

; 1340 : 		{	// erase elements [_Off, ...)

	push	ebp
	mov	ebp, esp

; 2271 : 		if (this->_Mysize() < _Off)

	mov	eax, DWORD PTR __Off$[ebp]
	cmp	DWORD PTR [ecx+16], eax
	jb	SHORT $LN37@erase

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN29@erase
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN29@erase:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1343 : 		return (*this);

	mov	eax, ecx

; 1344 : 		}

	pop	ebp
	ret	4
$LN37@erase:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN39@erase:
$LN36@erase:
	int	3
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@I@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z
_TEXT	SEGMENT
__Off$ = 8						; size = 4
__Ptr$ = 12						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1271 : 		{	// insert [_Ptr, <null>) at _Off

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@insert
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
$LN5@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@insert:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@insert
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1273 : 		return (insert(_Off, _Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi

; 1274 : 		}

	pop	ebp
	ret	8
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z
_TEXT	SEGMENT
tv774 = -4						; size = 4
__Off$ = 8						; size = 4
tv775 = 12						; size = 4
__Ptr$ = 12						; size = 4
__Count$ = 16						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1250 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN21@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN22@insert
$LN21@insert:
	mov	eax, esi
$LN22@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN35@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN36@insert
$LN35@insert:
	mov	edx, esi
$LN36@insert:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@insert

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN58@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN59@insert
$LN58@insert:
	mov	eax, esi
$LN59@insert:

; 1251 : 		_DEBUG_POINTER_IF(_Count != 0, _Ptr);
; 1252 : 		if (_Inside(_Ptr))
; 1253 : 			return (insert(_Off, *this,

	push	DWORD PTR __Count$[ebp]
	sub	ebx, eax
	mov	ecx, esi
	push	ebx
	push	esi
	push	DWORD PTR __Off$[ebp]
	call	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN2@insert:

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jb	$LN264@insert

; 1254 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1255 : 		_Check_offset(_Off);
; 1256 : 		if (npos - this->_Mysize() <= _Count)

	mov	edx, DWORD PTR __Count$[ebp]
	mov	eax, ecx
	not	eax
	cmp	eax, edx
	jbe	$LN266@insert

; 1257 : 			_Xlen();	// result too long
; 1258 : 		const size_type _Num = this->_Mysize() + _Count;

	push	edi
	lea	edi, DWORD PTR [ecx+edx]

; 1259 : 		if (0 < _Count && _Grow(_Num))

	test	edx, edx
	je	$LN258@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN267@insert

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN100@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	edx, DWORD PTR __Count$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1259 : 		if (0 < _Count && _Grow(_Num))

	je	$LN258@insert
$LN263@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN203@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv775[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN204@insert
$LN100@insert:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN263@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN177@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN177@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN203@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv775[ebp], esi
$LN204@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN217@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR tv774[ebp], eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN218@insert
$LN217@insert:
	mov	DWORD PTR tv774[ebp], esi
$LN218@insert:

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR [esi+16]
	mov	ecx, DWORD PTR __Off$[ebp]
	sub	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN224@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv775[ebp]
	add	eax, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1261 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv774[ebp]
	add	eax, ecx
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	ecx, DWORD PTR __Off$[ebp]
	add	esp, 12					; 0000000cH
$LN224@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN235@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN236@insert
$LN235@insert:
	mov	edx, esi
$LN236@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	je	SHORT $LN242@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1264 : 			_Traits::copy(this->_Myptr() + _Off, _Ptr, _Count);	// fill hole

	lea	eax, DWORD PTR [edx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN242@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN253@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN253@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN258@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1267 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1268 : 		}

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN264@insert:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN268@insert:
$LN266@insert:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN269@insert:
$LN267@insert:
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN270@insert:
$LN261@insert:
	int	3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IPBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z
_TEXT	SEGMENT
tv864 = 8						; size = 4
tv861 = 8						; size = 4
__Off$ = 8						; size = 4
__Right$ = 12						; size = 4
tv853 = 16						; size = 4
__Roff$ = 16						; size = 4
tv866 = 20						; size = 4
__Count$ = 20						; size = 4
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT
; _this$ = ecx

; 1223 : 		{	// insert _Right [_Roff, _Roff + _Count) at _Off

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR [esi+16]
	cmp	ecx, DWORD PTR __Off$[ebp]
	jb	$LN285@insert
	mov	eax, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR __Roff$[ebp]
	mov	eax, DWORD PTR [eax+16]
	cmp	eax, edx
	jb	$LN287@insert

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, edx
	cmp	edi, eax
	cmova	edi, eax

; 1224 : 		_Check_offset(_Off);
; 1225 : 		_Right._Check_offset(_Roff);
; 1226 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1227 : 		if (npos - this->_Mysize() <= _Count)

	mov	eax, ecx
	not	eax
	cmp	eax, edi
	jbe	$LN288@insert

; 1228 : 			_Xlen();	// result too long
; 1229 : 
; 1230 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	ebx, DWORD PTR [ecx+edi]

; 1231 : 		if (0 < _Count && _Grow(_Num))

	test	edi, edi
	je	$LN279@insert

; 2225 : 		if (max_size() < _Newsize)

	cmp	ebx, -2					; fffffffeH
	ja	$LN289@insert

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], ebx
	jae	SHORT $LN75@insert

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	ebx
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	ebx, ebx

; 1231 : 		if (0 < _Count && _Grow(_Num))

	je	$LN279@insert
$LN283@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN178@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv866[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN179@insert
$LN75@insert:

; 2232 : 		else if (_Newsize == 0)

	test	ebx, ebx
	jne	SHORT $LN283@insert

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN152@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], bl
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN152@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN178@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	DWORD PTR tv866[ebp], esi
$LN179@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN192@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN193@insert
$LN192@insert:
	mov	ecx, esi
$LN193@insert:

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR [esi+16]
	mov	edx, DWORD PTR __Off$[ebp]
	sub	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN199@insert
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	mov	eax, DWORD PTR tv866[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1233 : 			_Traits::move(this->_Myptr() + _Off + _Count,

	lea	eax, DWORD PTR [ecx+edx]
	add	eax, edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
	mov	edx, DWORD PTR __Off$[ebp]
	add	esp, 12					; 0000000cH
$LN199@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1236 : 			if (this == &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	esi, eax
	jne	SHORT $LN4@insert
	mov	eax, DWORD PTR __Roff$[ebp]
	cmp	edx, eax
	lea	ecx, DWORD PTR [eax+edi]
	cmovae	ecx, eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR tv853[ebp], ecx
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN210@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv864[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN211@insert
$LN210@insert:
	mov	DWORD PTR tv864[ebp], esi
$LN211@insert:
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN224@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN225@insert
$LN224@insert:
	mov	ecx, esi
$LN225@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN263@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv853[ebp]
	add	eax, DWORD PTR tv864[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1237 : 				_Traits::move(this->_Myptr() + _Off,

	lea	eax, DWORD PTR [ecx+edx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memmove
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1240 : 			else

	jmp	SHORT $LN284@insert
$LN4@insert:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [eax+20], 16			; 00000010H
	jb	SHORT $LN242@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [eax]
$LN242@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN256@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR tv861[ebp], ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN257@insert
$LN256@insert:
	mov	DWORD PTR tv861[ebp], esi
$LN257@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN263@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

	add	eax, DWORD PTR __Roff$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	edi
	push	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1241 : 				_Traits::copy(this->_Myptr() + _Off,

	mov	eax, DWORD PTR tv861[ebp]
	add	eax, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	call	_memcpy
$LN284@insert:
	add	esp, 12					; 0000000cH
$LN263@insert:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], ebx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN274@insert
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN274@insert:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+ebx], 0
$LN279@insert:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1245 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1246 : 		}

	pop	ebp
	ret	16					; 00000010H
$LN285@insert:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN290@insert:
$LN287@insert:
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN291@insert:
$LN288@insert:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN292@insert:
$LN289@insert:
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN293@insert:
$LN281@insert:
	int	3
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@IABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1180 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN5@assign
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
$LN5@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL7@assign:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL7@assign
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1183 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	ebx, DWORD PTR __Ptr$[ebp]
	push	esi

; 1165 : 		{	// assign [_Ptr, _Ptr + _Count)

	mov	esi, ecx

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	test	ebx, ebx
	je	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	ecx, DWORD PTR [esi+20]
	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN20@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN21@assign
$LN20@assign:
	mov	eax, esi
$LN21@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	cmp	ebx, eax
	jb	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN34@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN35@assign
$LN34@assign:
	mov	edx, esi
$LN35@assign:

; 2240 : 			|| this->_Myptr() + this->_Mysize() <= _Ptr)

	mov	eax, DWORD PTR [esi+16]
	add	eax, edx
	cmp	eax, ebx
	jbe	SHORT $LN2@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	ecx, 16					; 00000010H
	jb	SHORT $LN57@assign

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN57@assign:

; 1168 : 			return (assign(*this,

	push	DWORD PTR __Count$[ebp]

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi

; 1168 : 			return (assign(*this,

	mov	ecx, esi
	sub	ebx, eax
	push	ebx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN2@assign:
	push	edi

; 2225 : 		if (max_size() < _Newsize)

	mov	edi, DWORD PTR __Count$[ebp]
	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN187@assign

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN63@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1169 : 				_Ptr - this->_Myptr(), _Count));	// substring
; 1170 : 
; 1171 : 		if (_Grow(_Count))

	je	SHORT $LN181@assign
$LN186@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN158@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN159@assign
$LN63@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN186@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN140@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN140@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1177 : 		}

	pop	ebp
	ret	8
$LN158@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
$LN159@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN165@assign
	push	edi
	push	ebx
	push	eax
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN165@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN176@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN176@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN181@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1176 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1177 : 		}

	pop	ebp
	ret	8
$LN187@assign:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN189@assign:
$LN184@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	push	ebp
	mov	ebp, esp
	push	ebx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ebx, DWORD PTR __Right$[ebp]
	push	esi

; 1149 : 		{	// assign _Right [_Roff, _Roff + _Count)

	mov	esi, ecx

; 2271 : 		if (this->_Mysize() < _Off)

	mov	ecx, DWORD PTR __Roff$[ebp]
	push	edi
	mov	eax, DWORD PTR [ebx+16]
	cmp	eax, ecx
	jb	$LN208@assign

; 2113 : 		if (_Size <= _Max_effective_size)

	mov	edi, DWORD PTR __Count$[ebp]
	sub	eax, ecx
	cmp	edi, eax
	cmova	edi, eax

; 1150 : 		_Right._Check_offset(_Roff);
; 1151 : 		_Count = _Right._Clamp_suffix_size(_Roff, _Count);
; 1152 : 
; 1153 : 		if (this == &_Right)

	cmp	esi, ebx
	jne	SHORT $LN2@assign

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	lea	eax, DWORD PTR [ecx+edi]

; 2271 : 		if (this->_Mysize() < _Off)

	cmp	DWORD PTR [esi+16], eax
	jb	$LN210@assign

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], eax

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN63@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN63@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	push	ecx
	push	0
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [edx+eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1154 : 			erase((size_type)(_Roff + _Count)), erase(0, _Roff);	// substring

	call	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
	pop	edi

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN2@assign:

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	$LN211@assign

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN72@assign

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	DWORD PTR [esi+16]
	mov	ecx, esi
	push	edi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy
	mov	ecx, DWORD PTR __Roff$[ebp]

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1155 : 		else if (_Grow(_Count))

	je	SHORT $LN203@assign
$LN207@assign:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ebx+20], 16			; 00000010H
	jb	SHORT $LN166@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	ebx, DWORD PTR [ebx]
$LN166@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN180@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	edx, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN181@assign
$LN72@assign:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN207@assign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN149@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN149@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN180@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	edx, esi
$LN181@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	test	edi, edi
	je	SHORT $LN187@assign
	push	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1157 : 			_Traits::copy(this->_Myptr(),

	lea	eax, DWORD PTR [ebx+ecx]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 530  : 		return (_Count == 0 ? _First1

	push	eax
	push	edx
	call	_memcpy
	add	esp, 12					; 0000000cH
$LN187@assign:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN198@assign
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN198@assign:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN203@assign:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1161 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1162 : 		}

	pop	ebp
	ret	12					; 0000000cH
$LN208@assign:

; 2283 : 		_Xout_of_range("invalid string position");

	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN212@assign:
$LN210@assign:
	push	OFFSET ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
	call	?_Xout_of_range@std@@YAXPBD@Z		; std::_Xout_of_range
$LN213@assign:
$LN211@assign:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN214@assign:
$LN205@assign:
	int	3
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT
; _this$ = ecx

; 1143 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1145 : 		}

	pop	ebp
	ret	4
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Ch$ = 12						; size = 1
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; _this$ = ecx

; 1111 : 		{	// append _Count * _Ch

	push	ebp
	mov	ebp, esp
	push	ebx

; 1112 : 		if (npos - this->_Mysize() <= _Count)

	mov	ebx, DWORD PTR __Count$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	ecx, DWORD PTR [esi+16]
	mov	eax, ecx
	not	eax
	cmp	eax, ebx
	jbe	SHORT $LN141@append

; 1113 : 			_Xlen();	// result too long
; 1114 : 
; 1115 : 		const size_type _Num = this->_Mysize() + _Count;

	lea	edi, DWORD PTR [ecx+ebx]

; 1116 : 		if (0 < _Count && _Grow(_Num))

	test	ebx, ebx
	je	SHORT $LN136@append

; 2225 : 		if (max_size() < _Newsize)

	cmp	edi, -2					; fffffffeH
	ja	SHORT $LN143@append

; 2226 : 			_Xlen();	// result too long
; 2227 : 		if (this->_Myres() < _Newsize)

	cmp	DWORD PTR [esi+20], edi
	jae	SHORT $LN28@append

; 2228 : 			_Copy(_Newsize, this->_Mysize());	// reallocate to grow

	push	ecx
	push	edi
	mov	ecx, esi
	call	?_Copy@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXII@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Copy

; 2233 : 			_Eos(0);	// new size is zero, just null terminate
; 2234 : 		return (0 < _Newsize);	// return true only if more work to do

	test	edi, edi

; 1116 : 		if (0 < _Count && _Grow(_Num))

	je	SHORT $LN136@append
$LN140@append:

; 1117 : 			{	// make room and append new stuff using assign
; 1118 : 			_Chassign(this->_Mysize(), _Count, _Ch);

	push	DWORD PTR __Ch$[ebp]
	mov	ecx, esi
	push	ebx
	push	DWORD PTR [esi+16]
	call	?_Chassign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEXIID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Chassign

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN131@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN28@append:

; 2232 : 		else if (_Newsize == 0)

	test	edi, edi
	jne	SHORT $LN140@append

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], edi

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jb	SHORT $LN105@append
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN105@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
	pop	edi
	pop	esi
	pop	ebx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1122 : 		}

	pop	ebp
	ret	8
$LN131@append:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax+edi], 0
$LN136@append:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1121 : 		return (*this);

	mov	eax, esi
	pop	esi
	pop	ebx

; 1122 : 		}

	pop	ebp
	ret	8
$LN141@append:

; 2266 : 		_Xlength_error("string too long");

	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN144@append:
$LN143@append:
	push	OFFSET ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
	call	?_Xlength_error@std@@YAXPBD@Z		; std::_Xlength_error
$LN145@append:
$LN138@append:
	int	3
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z
_TEXT	SEGMENT
__Ch$ = 8						; size = 1
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; _this$ = ecx

; 1059 : 		{	// append 1 * _Ch

	push	ebp
	mov	ebp, esp

; 1060 : 		return (append((size_type)1, _Ch));

	push	DWORD PTR __Ch$[ebp]
	push	1
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ID@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1061 : 		}

	pop	ebp
	ret	4
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1039 : 		{	// assign [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	esi, DWORD PTR __Ptr$[ebp]
	cmp	BYTE PTR [esi], 0
	jne	SHORT $LN7@operator
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1040 : 		return (assign(_Ptr));
; 1041 : 		}

	pop	ebp
	ret	4
$LN7@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, esi
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL9@operator:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL9@operator
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	pop	esi

; 1040 : 		return (assign(_Ptr));
; 1041 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 1023 : 		{	// assign _Right

	push	ebp
	mov	ebp, esp

; 1024 : 		if (this != &_Right)

	mov	eax, DWORD PTR __Right$[ebp]
	push	esi
	mov	esi, ecx
	cmp	esi, eax
	je	SHORT $LN136@operator

; 1144 : 		return (assign(_Right, 0, npos));

	push	-1
	push	0
	push	eax
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
$LN136@operator:

; 1025 : 			{	// different, assign it
; 1026 : 			if (this->_Getal() != _Right._Getal()
; 1027 : 				&& _Alty::propagate_on_container_copy_assignment::value)
; 1028 : 				{	// change allocator before copying
; 1029 : 				_Tidy(true);
; 1030 : 				this->_Copy_alloc(_Right._Getal());
; 1031 : 				}
; 1032 : 
; 1033 : 			assign(_Right);
; 1034 : 			}
; 1035 : 		return (*this);

	mov	eax, esi
	pop	esi

; 1036 : 		}

	pop	ebp
	ret	4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 1016 : 		{	// destroy the string

	push	esi
	mov	esi, ecx

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN6@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN6@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN98@basic_stri
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
$LN98@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1018 : 		}

	ret	0
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv, COMDAT
; _this$ = ecx

; 961  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 734  : 		return (_Get_data()._Myres);

	mov	esi, DWORD PTR __Right$[ebp]
	push	edi

; 961  : 		{	// assign by moving _Right

	mov	edi, ecx

; 962  : 		if (_Right._Myres() < this->_BUF_SIZE)

	cmp	DWORD PTR [esi+20], 16			; 00000010H
	jae	SHORT $LN2@Assign_rv

; 963  : 			_Traits::move(this->_Bx()._Buf, _Right._Bx()._Buf,

	mov	eax, DWORD PTR [esi+16]
	add	eax, 1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 553  : 		return (_Count == 0 ? _First1

	je	SHORT $LN3@Assign_rv
	push	eax
	push	esi
	push	edi
	call	_memmove
	add	esp, 12					; 0000000cH
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 965  : 		else

	jmp	SHORT $LN3@Assign_rv
$LN2@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	test	edi, edi
	je	SHORT $LN84@Assign_rv
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi], eax
$LN84@Assign_rv:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 968  : 			_Right._Bx()._Ptr = pointer();

	mov	DWORD PTR [esi], 0
$LN3@Assign_rv:

; 969  : 			}
; 970  : 		this->_Mysize() = _Right._Mysize();

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [edi+16], eax

; 971  : 		this->_Myres() = _Right._Myres();

	mov	eax, DWORD PTR [esi+20]
	mov	DWORD PTR [edi+20], eax

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN231@Assign_rv
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
	pop	edi
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
$LN231@Assign_rv:
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
	pop	esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 973  : 		}

	pop	ebp
	ret	4
?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 928  : 		{	// assign by moving _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 929  : 		if (this != &_Right)

	cmp	esi, DWORD PTR __Right$[ebp]
	je	SHORT $LN298@operator

; 2251 : 		else if (this->_BUF_SIZE <= this->_Myres())

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, 16					; 00000010H
	jb	SHORT $LN10@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2258 : 			this->_Getal().deallocate(_Ptr, this->_Myres() + 1);

	inc	eax
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	eax
	push	DWORD PTR [esi]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate
$LN10@operator:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [esi+20], 16			; 00000010H

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jb	SHORT $LN102@operator
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR [esi]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 514  : 		return (this->_BUF_SIZE <= _Myres

	jmp	SHORT $LN103@operator
$LN102@operator:
	mov	eax, esi
$LN103@operator:

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	ecx, esi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [eax], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 940  : 				_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv
$LN298@operator:

; 941  : 			}
; 942  : 		return (*this);

	mov	eax, esi

; 943  : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV01@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 911  : 		{	// construct by moving _Right

	push	ebp
	mov	ebp, esp
	push	esi

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	push	DWORD PTR __Right$[ebp]
	mov	esi, ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 913  : 		_Assign_rv(_STD forward<_Myt>(_Right));

	call	?_Assign_rv@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEX$$QAV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv

; 914  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@$$QAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 836  : 		{	// construct from [_Ptr, <null>)

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	ecx, DWORD PTR __Ptr$[ebp]
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0

; 523  : 		return (*_First == 0 ? 0

	cmp	BYTE PTR [ecx], 0
	jne	SHORT $LN115@basic_stri
	xor	edx, edx
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
$LN115@basic_stri:
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 523  : 		return (*_First == 0 ? 0

	mov	edx, ecx
	push	edi
	lea	edi, DWORD PTR [edx+1]
$LL117@basic_stri:
	mov	al, BYTE PTR [edx]
	inc	edx
	test	al, al
	jne	SHORT $LL117@basic_stri
	sub	edx, edi
	pop	edi
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 1182 : 		return (assign(_Ptr, _Traits::length(_Ptr)));

	push	edx
	push	ecx
	mov	ecx, esi
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@PBDI@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 837  : 		_Tidy();
; 838  : 		assign(_Ptr);
; 839  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@PBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
__Roff$ = 12						; size = 4
__Count$ = 16						; size = 4
__Al$ = 20						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 815  : 		{	// construct from _Right [_Roff, _Roff + _Count) with allocator

	push	ebp
	mov	ebp, esp
	push	esi

; 817  : 		assign(_Right, _Roff, _Count);

	push	DWORD PTR __Count$[ebp]
	mov	esi, ecx
	push	DWORD PTR __Roff$[ebp]
	push	DWORD PTR __Right$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 817  : 		assign(_Right, _Roff, _Count);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 818  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@IIABV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [ecx+20], 15			; 0000000fH

; 796  : 		}

	mov	eax, ecx

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [ecx+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [ecx], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 796  : 		}

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; _this$ = ecx

; 780  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 782  : 		assign(_Right, 0, npos);

	push	-1
	push	0
	push	DWORD PTR __Right$[ebp]

; 2260 : 		this->_Myres() = this->_BUF_SIZE - 1;

	mov	DWORD PTR [esi+20], 15			; 0000000fH

; 2219 : 		_Traits::assign(_Dx._Myptr()[_Dx._Mysize = _Newsize], _Elem());

	mov	DWORD PTR [esi+16], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd

; 565  : 		_Left = _Right;

	mov	BYTE PTR [esi], 0
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring

; 782  : 		assign(_Right, 0, npos);

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAEAAV12@ABV12@II@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 783  : 		}

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QAE@ABV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
; _this$ = ecx
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 320  : 		return (_Myval2);

	mov	eax, ecx

; 321  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 315  : 		return (_Myval2);

	mov	eax, ecx

; 316  : 		}

	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 300  : 		return (*this);

	mov	eax, ecx

; 301  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 295  : 		return (*this);

	mov	eax, ecx

; 296  : 		}

	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@D@std@@@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<char> >,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres, COMDAT
; _this$ = ecx

; 734  : 		return (_Get_data()._Myres);

	lea	eax, DWORD PTR [ecx+20]

; 735  : 		}

	ret	0
?_Myres@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myres
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 729  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 730  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ
_TEXT	SEGMENT
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize, COMDAT
; _this$ = ecx

; 724  : 		return (_Get_data()._Mysize);

	lea	eax, DWORD PTR [ecx+16]

; 725  : 		}

	ret	0
?_Mysize@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAIXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Mysize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx, COMDAT
; _this$ = ecx

; 714  : 		return (_Get_data()._Bx);

	mov	eax, ecx

; 715  : 		}

	ret	0
?_Bx@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAT_Bxty@?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Bx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 707  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 708  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT
; _this$ = ecx

; 702  : 		return (_Mypair._Get_second());

	mov	eax, ecx

; 703  : 		}

	ret	0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 697  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 698  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ
_TEXT	SEGMENT
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT
; _this$ = ecx

; 692  : 		return (_Mypair._Get_first());

	mov	eax, ecx

; 693  : 		}

	ret	0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT
; _this$ = ecx

; 607  : 		_Pocma(_Getal(), _Al);
; 608  : 		}

	ret	4
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXAAU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT
; _this$ = ecx

; 602  : 		_Pocca(_Getal(), _Al);
; 603  : 		}

	ret	4
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEXABU?$_Wrap_alloc@V?$allocator@D@std@@@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 590  : 		}

	mov	eax, ecx

; 497  : 		_Myres(0)

	mov	DWORD PTR [ecx+20], 0

; 590  : 		}

	ret	0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAE@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 584  : 		}

	ret	0
$LN11@Myptr:

; 583  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 584  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QBEPBDXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN11@Myptr

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, DWORD PTR [ecx]

; 579  : 		}

	ret	0
$LN11@Myptr:

; 578  : 		return (_Get_data()._Myptr());

	mov	eax, ecx

; 579  : 		}

	ret	0
?_Myptr@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QAEPADXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx
	ret	0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT
; _this$ = ecx

; 534  : 			}

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT
; _this$ = ecx

; 529  : 			{	// user-provided, for fancy pointers
; 530  : 			}

	mov	eax, ecx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 521  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
$LN3@Myptr:

; 521  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 522  : 			? _Unfancy(_Bx._Ptr)
; 523  : 			: _Bx._Buf);
; 524  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QBEPBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ
_TEXT	SEGMENT
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT
; _this$ = ecx

; 514  : 		return (this->_BUF_SIZE <= _Myres

	cmp	DWORD PTR [ecx+20], 16			; 00000010H
	jb	SHORT $LN3@Myptr
	mov	eax, DWORD PTR [ecx]

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
$LN3@Myptr:

; 514  : 		return (this->_BUF_SIZE <= _Myres

	mov	eax, ecx

; 515  : 			? _Unfancy(_Bx._Ptr)
; 516  : 			: _Bx._Buf);
; 517  : 		}

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QAEPADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT
; _this$ = ecx

; 496  : 		_Mysize(0),

	mov	DWORD PTR [ecx+16], 0

; 499  : 		}

	mov	eax, ecx
	mov	DWORD PTR [ecx+20], 0
	ret	0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QAE@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::max_size, COMDAT
; _this$ = ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	or	eax, -1

; 1009 : 		}

	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 987  : 		_Mybase::deallocate(_Ptr, _Count);
; 988  : 		}

	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEXPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN6@allocate
$LN15@allocate:

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN8@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	jbe	SHORT $LN17@allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN19@allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 976  : 		return (_Mybase::allocate(_Count));
; 977  : 		}

	pop	ebp
	ret	4
$LN8@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN15@allocate
	jmp	SHORT $LN20@allocate
$LN17@allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN21@allocate:
$LN19@allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN22@allocate:
$LN20@allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN23@allocate:
$LN16@allocate:
	int	3
?allocate@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEPADI@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::operator=, COMDAT
; _this$ = ecx

; 963  : 		_Mybase::operator=(_STD move(_Right));
; 964  : 		return (*this);

	mov	eax, ecx

; 965  : 		}

	ret	4
??4?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAEAAU01@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 947  : 		}

	mov	eax, ecx
	ret	4
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ
_TEXT	SEGMENT
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ PROC	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >, COMDAT
; _this$ = ecx

; 937  : 		}

	mov	eax, ecx
	ret	0
??0?$_Wrap_alloc@V?$allocator@D@std@@@std@@QAE@XZ ENDP	; std::_Wrap_alloc<std::allocator<char> >::_Wrap_alloc<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

	push	ebp
	mov	ebp, esp

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 927  : 		}

	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBEPADAAD@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@D@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SG?AV?$allocator@D@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SG?AV?$allocator@D@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp

; 875  : 		return (_Al);

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

	pop	ebp
	ret	8
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@D@std@@@std@@SG?AV?$allocator@D@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SGIABV?$allocator@D@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SGIABV?$allocator@D@2@@Z PROC ; std::allocator_traits<std::allocator<char> >::max_size, COMDAT

; 869  : 		return (_Al.max_size());

	or	eax, -1

; 870  : 		}

	ret	4
?max_size@?$allocator_traits@V?$allocator@D@std@@@std@@SGIABV?$allocator@D@2@@Z ENDP ; std::allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@D@std@@QBEIXZ
_TEXT	SEGMENT
?max_size@?$allocator@D@std@@QBEIXZ PROC		; std::allocator<char>::max_size, COMDAT
; _this$ = ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	or	eax, -1

; 750  : 		}

	ret	0
?max_size@?$allocator@D@std@@QBEIXZ ENDP		; std::allocator<char>::max_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QAEPADI@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
?allocate@?$allocator@D@std@@QAEPADI@Z PROC		; std::allocator<char>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp

; 51   : 	if (_Count == 0)

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN4@allocate
$LN12@allocate:

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN4@allocate:

; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	eax, 4096				; 00001000H
	jb	SHORT $LN6@allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	ecx, DWORD PTR [eax+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	ecx, eax
	jbe	SHORT $LN14@allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN16@allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));
; 726  : 		}

	pop	ebp
	ret	4
$LN6@allocate:

; 83   : 		_Ptr = ::operator new(_User_size);

	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN12@allocate
	jmp	SHORT $LN17@allocate
$LN14@allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN18@allocate:
$LN16@allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN19@allocate:
$LN17@allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN20@allocate:
$LN13@allocate:
	int	3
?allocate@?$allocator@D@std@@QAEPADI@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QAEXPADI@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@D@std@@QAEXPADI@Z PROC		; std::allocator<char>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	1
	push	DWORD PTR __Count$[ebp]
	push	DWORD PTR __Ptr$[ebp]
	call	?_Deallocate@std@@YGXPAXII@Z		; std::_Deallocate

; 721  : 		}

	pop	ebp
	ret	8
?deallocate@?$allocator@D@std@@QAEXPADI@Z ENDP		; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
??0?$allocator@D@std@@QAE@ABV01@@Z PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, ecx
	ret	4
??0?$allocator@D@std@@QAE@ABV01@@Z ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QAE@XZ
_TEXT	SEGMENT
??0?$allocator@D@std@@QAE@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT
; _this$ = ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, ecx
	ret	0
??0?$allocator@D@std@@QAE@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YGXPAXII@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YGXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	mov	ecx, DWORD PTR __Count$[ebp]
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	ecx, eax
	ja	SHORT $LN11@Deallocate

; 95   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN9@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr$[ebp]
	test	al, 31					; 0000001fH
	jne	SHORT $LN13@Deallocate

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	ecx, DWORD PTR [eax-4]

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	cmp	ecx, eax
	jae	SHORT $LN14@Deallocate

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	sub	eax, ecx
	cmp	eax, 4
	jb	SHORT $LN15@Deallocate

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	cmp	eax, 35					; 00000023H
	jbe	SHORT $LN3@Deallocate
	jmp	SHORT $LN16@Deallocate
$LN9@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	ecx, DWORD PTR __Ptr$[ebp]
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	push	ecx
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 	}

	pop	ebp
	ret	12					; 0000000cH
$LN11@Deallocate:

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	call	__invalid_parameter_noinfo_noreturn
$LN17@Deallocate:
$LN13@Deallocate:

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	call	__invalid_parameter_noinfo_noreturn
$LN18@Deallocate:
$LN14@Deallocate:

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(
; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	call	__invalid_parameter_noinfo_noreturn
$LN19@Deallocate:
$LN15@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)
; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)

	call	__invalid_parameter_noinfo_noreturn
$LN20@Deallocate:
$LN16@Deallocate:

; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	call	__invalid_parameter_noinfo_noreturn
$LN21@Deallocate:
$LN10@Deallocate:
	int	3
?_Deallocate@std@@YGXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YGPAXII_N@Z
_TEXT	SEGMENT
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YGPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp

; 49   : 	void *_Ptr = 0;
; 50   : 
; 51   : 	if (_Count == 0)

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

	xor	eax, eax
$LN1@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	pop	ebp
	ret	12					; 0000000cH
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, ecx
	jb	SHORT $LN11@Allocate

; 57   : 	const size_t _User_size = _Count * _Sz;

	imul	ecx, DWORD PTR __Sz$[ebp]

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	BYTE PTR __Try_aligned_allocation$[ebp], 0
	je	SHORT $LN4@Allocate
	cmp	ecx, 4096				; 00001000H
	jb	SHORT $LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	lea	eax, DWORD PTR [ecx+35]

; 66   : 		if (_Block_size <= _User_size)

	cmp	eax, ecx
	jbe	SHORT $LN13@Allocate

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	push	eax
	call	??2@YAPAXI@Z				; operator new
	mov	ecx, eax
	add	esp, 4

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	test	ecx, ecx
	je	SHORT $LN14@Allocate

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	lea	eax, DWORD PTR [ecx+35]
	and	eax, -32				; ffffffe0H

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	DWORD PTR [eax-4], ecx

; 85   : 		}
; 86   : 	return (_Ptr);
; 87   : 	}

	pop	ebp
	ret	12					; 0000000cH
$LN4@Allocate:

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else
; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	push	ecx
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	test	eax, eax
	jne	SHORT $LN1@Allocate
	jmp	SHORT $LN15@Allocate
$LN11@Allocate:

; 56   : 		_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN16@Allocate:
$LN13@Allocate:

; 67   : 			_Xbad_alloc();	// report no memory

	call	?_Xbad_alloc@std@@YAXXZ			; std::_Xbad_alloc
$LN17@Allocate:
$LN14@Allocate:

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN18@Allocate:
$LN15@Allocate:

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	call	__invalid_parameter_noinfo_noreturn
$LN19@Allocate:
$LN10@Allocate:
	int	3
?_Allocate@std@@YGPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QAEXPBX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT
; _this$ = ecx

; 55   : 		}

	ret	4
?_Adopt@_Iterator_base0@std@@QAEXPBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QAEXXZ
_TEXT	SEGMENT
?_Orphan_all@_Container_base0@std@@QAEXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT
; _this$ = ecx

; 44   : 		}

	ret	0
?_Orphan_all@_Container_base0@std@@QAEXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NABD0@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?eq@?$char_traits@D@std@@SA_NABD0@Z PROC		; std::char_traits<char>::eq, COMDAT

; 570  : 		{	// test for element equality

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR __Left$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Right$[ebp]
	cmp	cl, BYTE PTR [eax]
	sete	al

; 571  : 		return (_Left == _Right);
; 572  : 		}

	pop	ebp
	ret	0
?eq@?$char_traits@D@std@@SA_NABD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAADABD@Z
_TEXT	SEGMENT
__Left$ = 8						; size = 4
__Right$ = 12						; size = 4
?assign@?$char_traits@D@std@@SAXAADABD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 564  : 		{	// assign an element

	push	ebp
	mov	ebp, esp

; 565  : 		_Left = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	mov	cl, BYTE PTR [eax]
	mov	eax, DWORD PTR __Left$[ebp]
	mov	BYTE PTR [eax], cl

; 566  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAXAADABD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPADPADID@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 1
?assign@?$char_traits@D@std@@SAPADPADID@Z PROC		; std::char_traits<char>::assign, COMDAT

; 559  : 		{	// assign _Count * _Ch to [_First, ...)

	push	ebp
	mov	ebp, esp

; 560  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

	push	DWORD PTR __Count$[ebp]
	movsx	eax, BYTE PTR __Ch$[ebp]
	push	eax
	push	DWORD PTR __First$[ebp]
	call	_memset
	add	esp, 12					; 0000000cH

; 561  : 		}

	pop	ebp
	ret	0
?assign@?$char_traits@D@std@@SAPADPADID@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?move@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::move, COMDAT

; 552  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 553  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@move
	mov	eax, DWORD PTR __First1$[ebp]

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp
	ret	0
$LN3@move:

; 553  : 		return (_Count == 0 ? _First1

	mov	DWORD PTR __Count$[ebp], eax

; 554  : 			: (_Elem *)_CSTD memmove(_First1, _First2, _Count));
; 555  : 		}

	pop	ebp

; 553  : 		return (_Count == 0 ? _First1

	jmp	_memmove
?move@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPBDPBDIABD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Count$ = 12						; size = 4
__Ch$ = 16						; size = 4
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z PROC		; std::char_traits<char>::find, COMDAT

; 545  : 		{	// look for _Ch in [_First, _First + _Count)

	push	ebp
	mov	ebp, esp

; 546  : 		return (_Count == 0 ? (const _Elem *)0

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@find

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

	pop	ebp
	ret	0
$LN3@find:

; 546  : 		return (_Count == 0 ? (const _Elem *)0

	push	eax
	mov	eax, DWORD PTR __Ch$[ebp]
	movsx	eax, BYTE PTR [eax]
	push	eax
	push	DWORD PTR __First$[ebp]
	call	_memchr
	add	esp, 12					; 0000000cH

; 547  : 			: (const _Elem *)_CSTD memchr(_First, _Ch, _Count));
; 548  : 		}

	pop	ebp
	ret	0
?find@?$char_traits@D@std@@SAPBDPBDIABD@Z ENDP		; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPADPADPBDI@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z PROC		; std::char_traits<char>::copy, COMDAT

; 529  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

	push	ebp
	mov	ebp, esp

; 530  : 		return (_Count == 0 ? _First1

	mov	eax, DWORD PTR __Count$[ebp]
	test	eax, eax
	jne	SHORT $LN3@copy
	mov	eax, DWORD PTR __First1$[ebp]

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp
	ret	0
$LN3@copy:

; 530  : 		return (_Count == 0 ? _First1

	mov	DWORD PTR __Count$[ebp], eax

; 531  : 			: (_Elem *)_CSTD memcpy(_First1, _First2, _Count));
; 532  : 		}

	pop	ebp

; 530  : 		return (_Count == 0 ? _First1

	jmp	_memcpy
?copy@?$char_traits@D@std@@SAPADPADPBDI@Z ENDP		; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SAIPBD@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
?length@?$char_traits@D@std@@SAIPBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 522  : 		{	// find length of null-terminated string

	push	ebp
	mov	ebp, esp

; 523  : 		return (*_First == 0 ? 0

	mov	eax, DWORD PTR __First$[ebp]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN3@length
	xor	eax, eax

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	pop	ebp
	ret	0
$LN3@length:

; 523  : 		return (*_First == 0 ? 0

	lea	edx, DWORD PTR [eax+1]
$LL5@length:
	mov	cl, BYTE PTR [eax]
	inc	eax
	test	cl, cl
	jne	SHORT $LL5@length
	sub	eax, edx

; 524  : 			: _CSTD strlen(_First));
; 525  : 		}

	pop	ebp
	ret	0
?length@?$char_traits@D@std@@SAIPBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHPBD0I@Z
_TEXT	SEGMENT
__First1$ = 8						; size = 4
__First2$ = 12						; size = 4
__Count$ = 16						; size = 4
?compare@?$char_traits@D@std@@SAHPBD0I@Z PROC		; std::char_traits<char>::compare, COMDAT

; 516  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

	push	ebp
	mov	ebp, esp

; 517  : 		return (_Count == 0 ? 0

	mov	ecx, DWORD PTR __Count$[ebp]
	test	ecx, ecx
	jne	SHORT $LN3@compare
	xor	eax, eax

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

	pop	ebp
	ret	0
$LN3@compare:

; 517  : 		return (_Count == 0 ? 0

	mov	edx, DWORD PTR __First1$[ebp]
	push	esi
	mov	esi, DWORD PTR __First2$[ebp]
	sub	ecx, 4
	jb	SHORT $LN7@compare
	npad	6
$LL8@compare:
	mov	eax, DWORD PTR [edx]
	cmp	eax, DWORD PTR [esi]
	jne	SHORT $LN6@compare
	add	edx, 4
	add	esi, 4
	sub	ecx, 4
	jae	SHORT $LL8@compare
$LN7@compare:
	cmp	ecx, -4					; fffffffcH
	je	SHORT $LN5@compare
$LN6@compare:
	mov	al, BYTE PTR [edx]
	cmp	al, BYTE PTR [esi]
	jne	SHORT $LN9@compare
	cmp	ecx, -3					; fffffffdH
	je	SHORT $LN5@compare
	mov	al, BYTE PTR [edx+1]
	cmp	al, BYTE PTR [esi+1]
	jne	SHORT $LN9@compare
	cmp	ecx, -2					; fffffffeH
	je	SHORT $LN5@compare
	mov	al, BYTE PTR [edx+2]
	cmp	al, BYTE PTR [esi+2]
	jne	SHORT $LN9@compare
	cmp	ecx, -1
	je	SHORT $LN5@compare
	mov	al, BYTE PTR [edx+3]
	cmp	al, BYTE PTR [esi+3]
	je	SHORT $LN5@compare
$LN9@compare:
	sbb	eax, eax
	or	eax, 1
	pop	esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

	pop	ebp
	ret	0
$LN5@compare:

; 517  : 		return (_Count == 0 ? 0

	xor	eax, eax
	pop	esi

; 518  : 			: _CSTD memcmp(_First1, _First2, _Count));
; 519  : 		}

	pop	ebp
	ret	0
?compare@?$char_traits@D@std@@SAHPBD0I@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

	push	ebp
	mov	ebp, esp

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 90   :     }

	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
END
